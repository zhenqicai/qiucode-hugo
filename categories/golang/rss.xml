<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>golang on 秋码分享</title><link>/categories/golang/</link><description>Recent content in golang on 秋码分享</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 11 Nov 2022 21:45:59 +0800</lastBuildDate><atom:link href="/categories/golang/rss.xml" rel="self" type="application/rss+xml"/><item><title>Go 语言中的 Moduels 管理（Let's Go 三十四）</title><link>/article/154/</link><pubDate>Fri, 11 Nov 2022 21:45:59 +0800</pubDate><guid>/article/154/</guid><description>&lt;p>在 &lt;code>Go 1.11&lt;/code>以前使用包管理一直被开发者所诟病。既然&lt;code>GOPATH&lt;/code>这种包管理引起了一线开发者的一片骂声，所以，&lt;code>Go&lt;/code>官方体恤一线开发者对&lt;code>GOPATH&lt;/code>这种包管理的情绪，一直致力努力提供对一线开发者友好的包管理解决方法而奋斗。从最初的&lt;code>GOPATH&lt;/code>到&lt;/p></description></item><item><title>Go 语言中的包（Let's Go 三十三）</title><link>/article/153/</link><pubDate>Mon, 07 Nov 2022 20:41:53 +0800</pubDate><guid>/article/153/</guid><description>&lt;p>Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。&lt;/p></description></item><item><title>Go 语言中的错误处理（Let's Go 三十二）</title><link>/article/152/</link><pubDate>Thu, 03 Nov 2022 11:10:28 +0000</pubDate><guid>/article/152/</guid><description>&lt;p>除了上面的 errors.New 用法之外，我们还可以实现 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。&lt;/p></description></item><item><title>Go 语言中的带有缓冲 Channel（Let's Go 三十一）</title><link>/article/151/</link><pubDate>Mon, 31 Oct 2022 11:27:56 +0000</pubDate><guid>/article/151/</guid><description>&lt;p>无缓冲信道 Channel 是无法保存任何值的，该类型信道要求 发送 goroutine 和 接受 goroutine 两者同时准备好，这样才能完成发送与接受的操作。&lt;/p></description></item><item><title>Go 语言中的单向 Channel（Let's Go 三十）</title><link>/article/150/</link><pubDate>Sat, 29 Oct 2022 10:53:15 +0000</pubDate><guid>/article/150/</guid><description>&lt;p>通过上篇文章，我们知道该怎么声明信道 Channel，以及发送和读取数据。然而本文要讲的是&lt;code>单向Channel&lt;/code>，可单向信道Channel到底是怎样的呢？&lt;/p></description></item><item><title>Go 语言中的 Channel（Let's Go 二十九）</title><link>/article/149/</link><pubDate>Thu, 27 Oct 2022 12:43:09 +0000</pubDate><guid>/article/149/</guid><description>&lt;p>Channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go 语言对于网络方面也有非常完善的支持。&lt;/p></description></item><item><title>Go 语言中的并发编程（Let's Go 二十八）</title><link>/article/148/</link><pubDate>Mon, 24 Oct 2022 11:13:34 +0000</pubDate><guid>/article/148/</guid><description>&lt;p>并发与并行并不相同，并发主要由切换时间片来实现“同时”运行，并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。&lt;/p></description></item><item><title>Go 语言中的空接口（Let's Go 二十七）</title><link>/article/147/</link><pubDate>Sun, 23 Oct 2022 13:25:50 +0000</pubDate><guid>/article/147/</guid><description>&lt;p>所谓空接口就是没有方法集，以至于任何类型都可实现它，换言之，也就是空接口可以保存任意类型的值。&lt;/p></description></item><item><title>Go 语言中的类型断言（Let's Go 二十六）</title><link>/article/146/</link><pubDate>Sat, 22 Oct 2022 13:26:16 +0000</pubDate><guid>/article/146/</guid><description>&lt;p>如果&lt;code>Type&lt;/code>是具体某个类型，类型断言会检查 &lt;code>varl&lt;/code>的动态类型是否等于具体类型 &lt;code>Type&lt;/code>。如果检查成功，类型断言返回的结果是 &lt;code>varl&lt;/code> 的动态值，其类型是 &lt;code>Type&lt;/code>。 - 如果 &lt;code>Type&lt;/code> 是接口类型，类型断言会检查 &lt;code>varl&lt;/code> 的动态类型是否满足&lt;/p></description></item><item><title>Go 语言中的接口（Let's Go 二十五）</title><link>/article/145/</link><pubDate>Fri, 21 Oct 2022 12:20:28 +0000</pubDate><guid>/article/145/</guid><description>&lt;p>要想实现&lt;code>Go&lt;/code>中的接口，类型实现接口方法集的方法，其类型实现的方法签名必须要与接口中的方法集中方法签名一样。 类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。&lt;/p></description></item><item><title>Go 语言中的方法（Let's Go 二十四）</title><link>/article/144/</link><pubDate>Wed, 19 Oct 2022 13:31:31 +0000</pubDate><guid>/article/144/</guid><description>&lt;p>Go中的方法是一种特殊的函数，以实现类型与函数进行绑定&lt;/p></description></item><item><title>原创 Go 语言中的结构体（Let's Go 二十三）</title><link>/article/143/</link><pubDate>Fri, 14 Oct 2022 13:33:44 +0000</pubDate><guid>/article/143/</guid><description>&lt;p>&lt;code>Go&lt;/code>中的结构体与&lt;code>c/c++&lt;/code>语言中是差不多，然而对没有接触过&lt;code>c/c++&lt;/code>语言的话，对在看到结构体这一&lt;code>复合类型&lt;/code>是新鲜事物。&lt;/p></description></item><item><title>Go 语言中的延迟执行【defer】（Let's Go 二十二）</title><link>/article/142/</link><pubDate>Wed, 12 Oct 2022 12:07:27 +0000</pubDate><guid>/article/142/</guid><description>&lt;p>函数作为另一个函数的形参，这就是Go当中的回调函数。&lt;/p></description></item><item><title>Go 语言中的闭包和可变参数（Let's Go 二十一）</title><link>/article/141/</link><pubDate>Wed, 05 Oct 2022 13:10:40 +0000</pubDate><guid>/article/141/</guid><description>&lt;p>在前面几篇文章，我们一直在使用&lt;code>Println、Printf&lt;/code>函数，你可能没有特别注意到，就是我们可以传入任意参数。而这种可以接受任意实参的函数，函数的形参极有可能是&lt;code>可变参数&lt;/code>，使用&lt;code>...type&lt;/code>可声明&lt;code>可变参数&lt;/code>，但必须是形参列表的最后&lt;/p></description></item><item><title>Go 语言中的函数变量与匿名函数（Let's Go 二十）</title><link>/article/140/</link><pubDate>Tue, 04 Oct 2022 12:50:36 +0000</pubDate><guid>/article/140/</guid><description>&lt;p>一上来乍一看，函数变量？这究竟是什么意思呢？你函数就函数，变量便是变量，这两者搞在一块，到底是几个意思呢？ 其实啊，在&lt;code>Go&lt;/code>当中，&lt;code>函数&lt;/code>也是一种类型，既然是类型，那就可以向其它类型一样，给变量定义类型啊！而这个类型是&lt;code>函数&lt;/code>，所以&lt;code>函数类型&lt;/code>&lt;/p></description></item><item><title>Go 语言中的函数详解（Let's Go 十九）</title><link>/article/139/</link><pubDate>Mon, 03 Oct 2022 11:28:50 +0000</pubDate><guid>/article/139/</guid><description>&lt;p>在前面几篇文章，接触到的最多的是&lt;code>main&lt;/code>函数。&lt;code>Go&lt;/code> 如同&lt;code>c/c++&lt;/code>语言一样，对于声明函数也有属于自己的一套规则。&lt;/p></description></item><item><title>Go 语言中的 goto、break 以及 continue 语句（Let's Go 十八）</title><link>/article/138/</link><pubDate>Sat, 01 Oct 2022 11:29:09 +0000</pubDate><guid>/article/138/</guid><description>&lt;p>在提到关键字&lt;code>goto&lt;/code>，想必很多人都心有余悸吧，毕竟&lt;code>goto&lt;/code>可是编程语言界破坏代码可读性的罪魁祸首啊！以至于像&lt;code>c/c++&lt;/code>或类 c 的编程语言，都将&lt;code>goto&lt;/code>作为保留关键字，不建议使用，但如果你非要使用，谁人可阻止呢？&lt;/p></description></item><item><title>Go 语言中的 switch 结构（Let's Go 十七）</title><link>/article/137/</link><pubDate>Fri, 30 Sep 2022 12:54:56 +0000</pubDate><guid>/article/137/</guid><description>&lt;p>相较于&lt;code>c/c++&lt;/code>等的&lt;code>switch case&lt;/code>，&lt;code>Go&lt;/code>对&lt;code>switch&lt;/code>做了很大改进，&lt;code>case&lt;/code>与&lt;code>case&lt;/code>之间是不需要写上&lt;code>break&lt;/code>，也能跳出当前&lt;code>case&lt;/code>语句，而且，&lt;code>switch&lt;/code>表达式可以是任何类型的噢！&lt;/p></description></item><item><title>Go 语言中的 for 循环结构（Let's Go 十六）</title><link>/article/136/</link><pubDate>Thu, 29 Sep 2022 12:03:10 +0000</pubDate><guid>/article/136/</guid><description>&lt;p>&lt;code>Go&lt;/code>当中只有&lt;code>for&lt;/code>循环结构，可没有像&lt;code>c/c++&lt;/code>语言有&lt;code>while&lt;/code>、&lt;code>do ... while&lt;/code>的。&lt;code>for&lt;/code>循环结构与&lt;code>if&lt;/code>分支结构一样，可以省略&lt;code>()&lt;/code>，左大括号&lt;code>{&lt;/code>必须与&lt;code>for&lt;/code>在同一行。&lt;/p></description></item><item><title>Go 语言中的 if 分支结构（Let's Go 十五）</title><link>/article/135/</link><pubDate>Wed, 28 Sep 2022 22:12:00 +0800</pubDate><guid>/article/135/</guid><description>&lt;p>&lt;code>Go&lt;/code>当中的&lt;code>if&lt;/code>分支与&lt;code>c/c++&lt;/code>大致相同，只是可以省略&lt;code>条件表达式&lt;/code>的小括号&lt;code>()&lt;/code>，真的是，```G哦·``就是要特立独行。&lt;/p></description></item><item><title>Go 语言中的列表（Let's Go 十四）</title><link>/article/134/</link><pubDate>Tue, 27 Sep 2022 14:05:01 +0000</pubDate><guid>/article/134/</guid><description>&lt;p>列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。&lt;/p></description></item><item><title>Go 语言中的字典【map】（Let's Go 十三）</title><link>/article/133/</link><pubDate>Tue, 27 Sep 2022 12:40:09 +0000</pubDate><guid>/article/133/</guid><description>&lt;p>其实，&lt;code>map&lt;/code>是一对&lt;code>key（键）&lt;/code>与&lt;code>value（值）&lt;/code>对应的无序集合，又称为&lt;code>关联数组&lt;/code>或&lt;code>字典&lt;/code>。&lt;/p></description></item><item><title>Go 语言中的数组（Let's Go 十二）</title><link>/article/132/</link><pubDate>Mon, 26 Sep 2022 12:32:58 +0000</pubDate><guid>/article/132/</guid><description>&lt;p>其实啊，切片就好像一个完整的蛋糕，你用刀切了一小块，而这一块就是从那完整的蛋糕切了下来。&lt;/p></description></item><item><title>Go 语言中的数组（Let's Go 十一）</title><link>/article/131/</link><pubDate>Sun, 25 Sep 2022 12:51:06 +0000</pubDate><guid>/article/131/</guid><description>&lt;p>与&lt;code>c/c++&lt;/code>语言一样，数组的每个元素可以通过&lt;code>索引下标&lt;/code>进行访问，&lt;code>索引下标&lt;/code>是从&lt;code>0&lt;/code>开始到数组长度减去1的位置。&lt;code>内置函数 len()&lt;/code>可以返回数组中元素的个数。&lt;/p></description></item><item><title>Go 语言中的类型定义与类型别名（Let's Go 十）</title><link>/article/130/</link><pubDate>Sun, 25 Sep 2022 11:18:22 +0000</pubDate><guid>/article/130/</guid><description>&lt;p>类型别名顾名思义就是给类型起个别名。就像上学时候，同学间开玩笑，给人以某种特征起了个外号，又或是英语老师给你起个英文名字，不管是外号、小名还是英文名字，最终都是指向你。&lt;/p></description></item><item><title>Go 语言中的指针（Let's Go 九）</title><link>/article/129/</link><pubDate>Sun, 25 Sep 2022 07:34:56 +0000</pubDate><guid>/article/129/</guid><description>&lt;p>&lt;code>*&lt;/code>操作符作为&lt;code>右值&lt;/code>时，意义是&lt;code>取指针的值&lt;/code>，作为&lt;code>左值&lt;/code>时，也就是放在&lt;code>赋值操作符的左边&lt;/code>时，表示 &lt;code>a 指针指向的变量&lt;/code>。其实归纳起来，&lt;code>*&lt;/code>操作符的根本意义就是操作&lt;code>指针指向的变量&lt;/code>。当操作在&lt;code>右值&lt;/code>时，就是&lt;code>取指向变量的值&lt;/code>，当操作&lt;/p></description></item><item><title>Go 语言中的关键字与标识符（Let's Go 八）</title><link>/article/128/</link><pubDate>Sat, 24 Sep 2022 12:34:00 +0000</pubDate><guid>/article/128/</guid><description>&lt;p>标识符是指&lt;code>Go语言&lt;/code>对各种变量、方法、函数等命名时使用的&lt;code>字符序列&lt;/code>，&lt;code>标识符&lt;/code>由若干个&lt;code>字母&lt;/code>、&lt;code>下划线 _ &lt;/code> 、和&lt;code>数字&lt;/code>组成，&lt;code>且第一个字符必须是字母&lt;/code>。通俗的讲就是凡可以自己定义的名称都可以叫做&lt;code>标识符&lt;/code>。&lt;/p></description></item><item><title>Go 语言中的常量定义（Let's Go 七）</title><link>/article/127/</link><pubDate>Sat, 24 Sep 2022 11:34:30 +0000</pubDate><guid>/article/127/</guid><description>&lt;p>&lt;code>Go&lt;/code>中定义常量与&lt;code>C语言&lt;/code>一样，也是使用&lt;code>const&lt;/code>关键字来定义常量的。常量声明语法：&lt;code>const name [typeName] = value&lt;/code>，其中&lt;code>typeName&lt;/code>（类型）可省略！ 常量可以是字符、字符串、布尔值或数值。 常量不能用 &lt;code>:=&lt;/code> 语法声明。&lt;/p></description></item><item><title>Go 语言中的类型转换以及类型推导（Let's Go 六）</title><link>/article/126/</link><pubDate>Sat, 24 Sep 2022 07:50:28 +0000</pubDate><guid>/article/126/</guid><description>&lt;p>在声明一个变量而不指定其类型时（即使用不带类型的 &lt;code>:=&lt;/code> 语法或 &lt;code>var =&lt;/code> 表达式语法），变量的类型由右值推导得出。&lt;/p></description></item><item><title>Go 语言中的字符串（Let's Go 五）</title><link>/article/125/</link><pubDate>Sat, 24 Sep 2022 06:15:40 +0000</pubDate><guid>/article/125/</guid><description>&lt;p>字符串想必是所有编程语言最为基础的类型，当然，Go中也不另外，字符串可根据需要会占用&lt;code>1&lt;/code>到&lt;code>4&lt;/code>个字节内存，由于&lt;code>Go&lt;/code>采用的是&lt;code>UTF-8&lt;/code>字符集编码格式，所以&lt;code>Go&lt;/code>不需要像其他编程语言那样对使用UTF-8字符集的文本进行编码与解码。&lt;/p></description></item><item><title>Go 语言中的多变量同时赋值、匿名变量以及变量作用域（Let's Go 四）</title><link>/article/124/</link><pubDate>Thu, 22 Sep 2022 13:54:28 +0000</pubDate><guid>/article/124/</guid><description>&lt;p>在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。&lt;/p></description></item><item><title>Go 语言中的基本类型以及变量声明与初始化（Let's Go 三）</title><link>/article/123/</link><pubDate>Wed, 21 Sep 2022 13:39:14 +0000</pubDate><guid>/article/123/</guid><description>&lt;p>刚才只是声明了变量，并没有给他赋值，虽然可以只是只声明变量，而后赋值也是可以的。但可以在声明变量是并初始化变量，也就是给变量赋初始值。&lt;/p></description></item><item><title>使用集成开发环境来开发Go项目</title><link>/article/122/</link><pubDate>Tue, 20 Sep 2022 12:59:15 +0000</pubDate><guid>/article/122/</guid><description>&lt;p>工欲善其事，必先利其器。好的集成开发环境（IDE）能让你事倍功半，好了，废话少扯，下来介绍几种能开发Go项目的IDE。&lt;/p></description></item><item><title>window下安装 Go 语言开发包</title><link>/article/121/</link><pubDate>Mon, 19 Sep 2022 15:11:00 +0000</pubDate><guid>/article/121/</guid><description>&lt;p>在window下安装最新Go语言开发包&lt;/p></description></item><item><title>vue vxe-table表格标题根据内容宽度自动换行</title><link>/article/117/</link><pubDate>Thu, 02 Jun 2022 15:58:34 +0000</pubDate><guid>/article/117/</guid><description>&lt;p>表格标题内容过多时，换行显示且多余部分以省略号显示。&lt;/p></description></item></channel></rss>