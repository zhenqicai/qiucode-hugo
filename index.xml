<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>秋码分享</title>
    <link>/</link>
    <description>Recent content on 秋码分享</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 30 Dec 2023 11:47:17 +0800</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>回望这风雨飘摇的一年过后，我们终将要整束行囊继续前行</title>
      <link>/article/184/</link>
      <pubDate>Sat, 30 Dec 2023 11:47:17 +0800</pubDate>
      
      <guid>/article/184/</guid>
      <description>2023 这一年 时间倏忽而过，纵有再多的不甘，2023 这一年的日历终要翻过去了。这一年，或许还对很多事保持着一种执念，然而，随着 2023 年如东逝水一去不复返，也该放下那份执着，让我们挥手告别那处于风雨飘摇的 2023 年，毕竟，未来还很长，我们还得背上行囊踏上那远方的路，否则，赶不上停靠在路边的二路汽车了都！
2023 年年初为这一年预先设定的规划，实现了吗？然而，回答我们自己，是那无声的摇头。年初预定的规划，大抵也只有到了年末，我们对这一年复盘时，方觉得年初列出的计划清单，还是有那么多没有完成，更有甚者，清单上一项都没能实现，或许，此刻，我们会对自己发出一声苦笑，长吁责问自己，“一年的时间，竟然空不出一点时间来完成那年初既定的规划！”
无论是长吁短叹，还是责怪自己，我们总得为未来、新的一年起一份未来规划列表，顺带 2023 年还未完成的计划。
风雨过后，总能遇见太阳，只是自然界的现象，当然，也有例外，太阳有时让那厚实的云朵遮蔽了，日光便无法照耀大地，那阴郁之气却布满了上空，使这座城市处于压抑的一天，但我们相信，云朵总是会散开的，迟来的阳光，也会照射这片土地，用那光芒的温度去蒸发昨日的阴郁之气。
或许，用【风雨飘摇】这个成语来形容 2023 这一年，总觉得还不是那么恰当，因为 2023 这一年，并不像【风雨飘摇】这个词轻描淡写、一词带过，这四个字并不足以恰如其分地述说 2023 这一年。
这一年，承载着太多人的不甘；这一年，也让大部分撤离了那份职业；这一年，也让很大一部分人彻夜逃离了大城市，终将回到了可以安放灵魂的故乡。
然而，在 2023 这一年所积攒下来的诸多不甘、不忿、怨愤等阴郁之气，我们希望能借未来之光芒来吹散、蒸发那股消极、惨淡、压抑之气，在我们寄托于未来之光的时刻，我们也必须时刻充实自己，也只有这样，未来之光方能光顾到我们自己。
2023 年的既定计划 说来忏愧，2023 年年初既定要完成的计划，用这一年的时间，本是完成那份计划清单，绰绰有余，然而，一年到头了，回首这一年，却发觉，计划清单上竟然还有那么多未能实现的。或许，我们会长叹一声，“时间都去哪儿了？”
时间并没有去哪里游玩，而是一直傍我们左右，只是我们生活节奏快了，顺带也把时间扯上了。那一声，“时间都去哪儿了？”的感慨，是没来由的长吁短叹！
2023 年既定的计划：
编写一套具有 秋码记录 风格的 Wordpress主题 编写一套具有 秋码记录 风格的Typecho主题 更新基于Vue.js 2.X的开源 UI组件库 qiucode-ui 组件库 编写一套基于 React的开源UI组件库 让 秋码记录 全站使用自己开源的UI组件库 然而，到了 2023 年年末，回望计划清单时，发觉虽但没能全部完成，却在意料之外增添一项计划，实属难料的惊喜：
开源了一套由 Hugo驱动的 hugo-theme-kiwi主题 一套由 Hugo 驱动的博客主题 hugo-theme-kiwi 开源啦 实践多个Web3项目 研习人工智能领域 2023 年所欠下的计划，我们也只能将它们寄托于新的一年，希冀未来能够逐一地实现它们，以不负昨日之约。
我们将 2023 年所搁浅的计划，整理好，装进背囊，踏上远方之路，让未来之光吹散因在 2023 年所沾满了满身泄气、不甘、愤懑地压抑之气。
展望未来 昨日之事，已成定局，断然不可挽回，该是放下那份执念，去迎接明日的阳光。</description>
    </item>
    
    <item>
      <title>一套由 Hugo 驱动的博客主题 hugo-theme-kiwi 开源啦</title>
      <link>/article/185/</link>
      <pubDate>Sun, 24 Dec 2023 23:27:17 +0800</pubDate>
      
      <guid>/article/185/</guid>
      <description>自 秋码记录 没再为云服务器续费那会儿起，便选用了由Hugo驱动的博客主题，来迁移秋码记录 上的所有文章，然而，在众多Hugo博客主题之列，竟找不出一套属于自己想要的风格的主题，故而，也只能暂且套用了一个还算可以的博客主题。
那套没有秋码记录 博客风格的主题，终究是会被替换的，一切都只是时间问题。可没想到的是，暂时选用那套博客主题，竟然暂时了这么久，这一搁就是好几个月了。还记得，秋码记录 云服务器到期是在 6 月 20 日，那是一个盛夏的季节，可如今呢，却是一个寒冬腊月、冷风凌冽、大雪纷飞的残冬时节，我不禁感叹，时间真的过的好快啊！快的让人喘不过气来。
其实，一套拥有 秋码记录 风格的主题，早已在云服务器到期之际，便应运而生了，可为什么一直拖到现如今呢？想必这也是您想问的吧！拖本不是我的本意，奈何有其他事傍身，无暇他顾，故而一拖再拖，拖到这寒冬腊月，窝在室内，身披被子，势必也要写出它来。
hugo-theme-kiwi 名字的缘故 说出来不怕您笑话，我很喜欢吃猕猴桃（也可以叫奇异果），而kiwi便是奇异果的英文，所以就将这套具有 秋码记录 博客风格的主题称为 hugo-theme-kiwi了。
或许您会问，那为什么不叫qiyiguo或mihoutao，也不是不可以，只是个名称而已嘛！何必那么讲究呢！只要自己欢喜，那么起什么样的名称，又有什么关系呢！还管业内人士怎么说，说这个太 low了，然而，我们又何必去在乎那些所谓的”技术专家“呢！说这个不符合命名规范，我们不要去在意别人怎么说，人生苦短，何必将自己束缚的那么紧绷呢！我们应该摒弃掉人生当中的各种条条框框。
扯多了，还是回到为何将这套主题叫hugo-theme-kiwi呢？其实，起初，我本想将这套主题叫hugo-theme-qiucode，然而，这个想法也只在我脑中停留了几秒钟，像是一阵轻风拂过，吹乱了头发，然而，下一秒，我却及时的将头发捋好，仿佛那阵风并为吹过一般。
也许是因为qiucode比kiwi多了几个字符吧！但还是由于qiucode太过于局限了，总抵不过kiwi来得更加宽泛，没有专为某人而设计的主题！
hugo-theme-kiwi目下拥有的功能 我们讲完了hugo-theme-kiwi名称的由来，我们也该聊聊它到底有哪些功能？当然，这些才是您浏览本文的最终目的，毕竟，一套好看的hugo主题总是那么吸引人，好比我们走在街上，忽然，迎面走来一位牵手高挑的美女，我想，那一刻，任一男人都会将目光迅速地移到那位美女身上的！当然咯，相貌与身材不及那位美女的其他女人（多是相貌平平），她们对那位美女瞬间把那条街所有男人的心给俘获了，心中难免怨恨，嘴角略微上扬，轻轻地一声“啧”，和那默契的翻白眼（或许，这才是女人与男人见到美女的所表现出的天然之别的情绪）
hugo-theme-kiwi V0.01已实现如下功能：
1、首页文章列表展示，以文章缩略图和文章摘要显示（毕竟是图文内容嘛！总得给个文章缩略图吧！）
2、是列表，那它就需要分页，而这套主题摒弃了随着滚动条触底而加载下一页数据（让人感觉有种加载不完数据）
3、文章详情页，当然，与用户交互那是必须的，所以加入了评论，也就是您可以对某篇文章进行评论。
4、文章详情页右侧，自动识别出文章目录，点击目录可以快速到达您所感兴趣的目录下阅读，减少了您宝贵的时间。
5、友情链接，用于添加拥有个人博客网站链接，虽然你我身处天南地北，但能在此处以博客会友建立了（可以称为博友）“友情”。
6、右侧侧边栏，分类和标签各自跳转到各自的页面
还未实现的功能：
1、首页文章搜索 2、时间轴 3、右侧侧边栏，分类与标签跳转页面优化 …… 今夜是平安页，您吃了苹果了吗？我衷心的祝愿您和您家人一生平安，同时，我也祈愿我和我的家人以及我身边的人一生平安！</description>
    </item>
    
    <item>
      <title>机器学习中的 Transformation Pipelines（Machine Learning 研习之十）</title>
      <link>/article/189/</link>
      <pubDate>Mon, 11 Dec 2023 19:50:17 +0800</pubDate>
      
      <guid>/article/189/</guid>
      <description>Transformation Pipelines 有许多数据转换步骤需要以正确的顺序执行。幸运的是，Scikit-Learn提供了Pipeline类来帮助处理这样的转换序列。下面是一个用于数值属性的小管道，它首先对输入特性进行归并，然后对输入特性进行缩放:
from sklearn.pipeline import Pipeline num_pipeline = Pipeline([ (&amp;#34;impute&amp;#34;, SimpleImputer(strategy=&amp;#34;median&amp;#34;)), (&amp;#34;standardize&amp;#34;, StandardScaler()), ]) Pipeline构造函数采用名称/估算器对(2元组)的列表，定义了一系列步骤。名称可以是您喜欢的任何名称，只要它们是唯一的，并且不包含双下划线(__)。以后我们讨论超参数调优时，它们会很有用。估计器必须都是转换器(即，它们必须有一个fit_transform()方法)，除了最后一个，它可以是任何东西:转换器、预测器或任何其他类型的估计器。
如果你不想命名transformers你可以使用 make_pipeline() 函数； 它将transformers作为位置参数，并使用transformers类的名称（小写且不带下划线）创建管道（例如，“simpleimputer”）：
from sklearn.pipeline import make_pipeline num_pipeline = make_pipeline(SimpleImputer(strategy=&amp;#34;median&amp;#34;), StandardScaler()) 如果多个transformers具有相同的名称，则会在其名称后附加索引（例如“foo-1”、“foo-2”等）。
当您调用管道的 fit() 方法时，它会在所有transformers上顺序调用 fit_transform()，将每个调用的输出作为参数传递给下一个调用，直到到达最终估计器，为此它只调用 fit() 方法。
该管道公开与最终估计器相同的方法。 在此示例中，最后一个估计器是 StandardScaler，它是一个transformers，因此管道也充当transformers。 如果您调用管道的transform()方法，它将按顺序将所有转换应用于数据。 如果最后一个估计器是预测器而不是变换器，那么管道将具有 Predict() 方法而不是 Transform() 方法。 调用它会按顺序将所有转换应用于数据并将结果传递给预测器的 Predict()方法
让我们调用管道的 fit_transform() 方法并查看输出的前两行，四舍五入到小数点后两位：
如前所述，如果要恢复一个漂亮的DataFrame，可以使用管道的get_feature_names_ out()方法:
df_housing_num_prepared = pd.DataFrame( housing_num_prepared, columns=num_pipeline.get_feature_names_out(), index=housing_num.index) 管道支持索引;例如，管道[1]返回管道中的第二个估计值，管道[:-1]返回一个包含除最后一个估计值以外的所有估计值的管道对象。您还可以通过steps属性(它是名称/估算器对的列表)或named_steps字典属性(它将名称映射到估算器)访问估算器。例如，num_line[“ simpleimputer”]返回名为“simpleimputer”的估计器。
到目前为止，我们已经分别处理了分类列和数值列。如果有一个能够处理所有列的转换器，将适当的转换应用到每一列，那会更方便。为此，您可以使用olumnTransformer。例如，下面的ColumnTransformer将把num_pipeline(我们刚刚定义的那个)应用于数字属性，把cat_pipeline应用于类别属性:
from sklearn.compose import ColumnTransformer num_attribs = [&amp;#34;longitude&amp;#34;, &amp;#34;latitude&amp;#34;, &amp;#34;housing_median_age&amp;#34;, &amp;#34;total_rooms&amp;#34;, &amp;#34;total_bedrooms&amp;#34;, &amp;#34;population&amp;#34;, &amp;#34;households&amp;#34;, &amp;#34;median_income&amp;#34;] cat_attribs = [&amp;#34;ocean_proximity&amp;#34;] cat_pipeline = make_pipeline( SimpleImputer(strategy=&amp;#34;most_frequent&amp;#34;), OneHotEncoder(handle_unknown=&amp;#34;ignore&amp;#34;)) preprocessing = ColumnTransformer([ (&amp;#34;num&amp;#34;, num_pipeline, num_attribs), (&amp;#34;cat&amp;#34;, cat_pipeline, cat_attribs), ]) 首先导入ColumnTransformer类，然后定义数字和分类列名的列表，并为分类属性构造一个简单的管道。最后，我们构造了一个列变换器。它的构造函数需要一个三元组(3-tuple)列表，每个三元组包含一个名称(必须是唯一的且不包含双下划线)、一个转换器和一个应该应用转换器的列的名称(或索引)列表。</description>
    </item>
    
    <item>
      <title>特征缩放和转换以及自定义Transformers（Machine Learning 研习之九）</title>
      <link>/article/187/</link>
      <pubDate>Sat, 18 Nov 2023 20:53:29 +0800</pubDate>
      
      <guid>/article/187/</guid>
      <description>特征缩放和转换 您需要应用于数据的最重要的转换之一是功能扩展。除了少数例外，机器学习算法在输入数值属性具有非常不同的尺度时表现不佳。住房数据就是这种情况:房间总数约为6至39320间，而收入中位数仅为0至15间。如果没有任何缩放，大多数模型将倾向于忽略收入中位数，而更多地关注房间数。
有两种常见的方法使所有属性具有相同的尺度:最小-最大尺度和标准化。
与所有估计器一样，重要的是仅将标量拟合到训练数据:永远不要对训练集以外的任何对象使用fit()或fit_transform()。一旦你有了一个训练好的定标器，你就可以用它来变换()任何其他的集合，包括验证集、测试集和新的数据。请注意，虽然培训集值将始终缩放到指定的范围，但如果新的数据包含异常值，则这些值最终可能会缩放到该范围之外。如果要避免这种情况，只需将剪辑超参数设置为True即可。
最小-最大缩放(许多人称之为标准化)是最简单的:对于每个属性，值被移位和重新缩放，以便它们最终的范围从0到1。这是通过减去最小值并除以最小值和最大值之间的差来实现的。Scikit-Learn为此提供了一个名为MinMaxScaler的转换器。它有一个feature_range超参数，如果出于某种原因，不希望0-1(例如，神经网络在零均值输入下工作得最好，所以最好在-1到1的范围内工作)。是相当好用的:
from sklearn.preprocessing import MinMaxScaler min_max_scaler = MinMaxScaler(feature_range=(-1, 1)) housing_num_min_max_scaled = min_max_scaler.fit_transform(housing_num) 标准化是不同的:首先它减去平均值(所以标准化值有一个零均值)，然后它除以标准差(所以标准-化值的标准差等于1)。不像最小最大缩放，标准化化不会将值限制在特定的范围内。然而，标准化受到离群值的影响要小得多。例如，假设一个地区的收入中位数等于100(误打误撞)，而不是通常的0-15。将最小最大值缩放到0-1范围会将这个离群值映射到1并将所有其他值压缩到0-0.15，而标准化不会受到太大影响。Scikit-Learn提供了一个名为StandardScaler的转换器用于标准化:
from sklearn.preprocessing import StandardScaler std_scaler = StandardScaler() housing_num_std_scaled = std_scaler.fit_transform(housing_num) 如果你想缩放一个稀疏矩阵而不首先将其转换为稠密矩阵，你可以使用一个标准缩放器，它的with_mean超参数设置为False它只会除以标准差，而不会减去均值(因为这会破坏稀疏性
当特征的分布具有重尾时（即，当远离平均值的值不是指数罕见时），最小-最大缩放和标准化都会将大多数值压缩到一个小范围内。 机器学习模型通常根本不喜欢这种情况，因此，在缩放特征之前，您应该首先对其进行变换以缩小重尾，并且如果可能的话，使分布大致对称。 例如，对于右侧有重尾部的正特征，执行此操作的常见方法是用其平方根替换特征（或将特征提高到 0 到 1 之间的幂）。 如果该特征具有非常长且重的尾部，例如幂律分布，则用其对数替换该特征可能会有所帮助。 例如，人口特征大致遵循幂律：拥有 10,000 名居民的地区的出现频率仅比拥有 1,000 名居民的地区低 10 倍，而不是呈指数级下降。 下图 显示了当你计算它的对数时这个特征看起来有多好：它非常接近高斯分布（即钟形）。
另一种处理重尾特征的方法是对特征进行反向转换。这意味着将其分布切割成大致相等大小的桶，并将每个特征值替换为它所属的桶的索引，就像我们创建收入猫特征一样(尽管我们只在分层抽样时使用它)。例如，您可以将每个值替换为其百分位数。使用相同大小的bucket处理会产生一个几乎均匀分布的特性，因此不需要进一步的缩放，或者您可以只除以bucket的数目来强制值到0-1的范围。
当一个特征具有多峰分布(即，有两个或两个以上清晰的峰值，称为模式)时，例housing_median_age特征，对它进行bucket ization也是有帮助的，但这次将bucket ID作为类别处理，而不是作为数值。这意味着必须对桶索引进行编码，例如使用OneHotEncoder(所以你通常不想用太多桶)。这种方法将允许回归模型更容易地为该特征值的不同范围学习不同的规则。例如，也许35年前建造的房子有一种独特的风格，已经过时了，因此它们比它们的年龄更便宜。
转换多峰分布的另一种方法是为每个模式(至少是主要模式)添加一个特征，表示住房中位年龄和该特定模式之间的相似性。相似性度量通常使用径向基函数(RBF)来计算&amp;ndash;任何只依赖于输入值与不动点之间距离的函数。最常用的RBF是高斯RBF，其输出值随着输入值远离固定点而呈指数衰减。例如，高斯RBF相似度与房龄x和35由方程exp (-y (x-35)2)给出。超参数y(gamma)确定当x远离35时相似性度量衰减的速度。使用Scikit-Learn的rbf_kernel()函数，您可以创建一个新的高斯RBF特征来测量房屋中位年龄和35:
from sklearn.metrics.pairwise import rbf_kernel age_simil_35 = rbf_kernel(housing[[&amp;#34;housing_median_age&amp;#34;]], [[35]], gamma=0.1) 下图显示了这一新特征作为住房中位数年龄的函数(实线)。它还显示了如果使用较小的gamma值，该功能将是什么样子。如图所示，新的年龄相似性特征在35岁时达到峰值，正好在住房中位年龄分布的峰值附近:如果这个特定的年龄组与较低的价格有很好的相关性，那么这个新特征将有很好的机会发挥作用。
到目前为止，我们只看了输入特性，但是目标值可能也需要转换。例如，若目标分布具有较重的尾部，您可以选择将目标替换为其对数。但是，如果你这样做，回归模型现在将预测的房屋价值中位数的对数，而不是房屋价值中位数本身。如果您想要预测的房屋中值，则需要计算模型预测的指数值。
幸运的是，大多数Scikit-Learn的转换器都有一个inverse_transform()方法，这使得计算转换的逆运算变得很容易。例如，下面的代码示例显示了如何使用StandardScaler缩放标签(就像我们对输入所做的那样)，然后在缩放后的标签上训练一个简单的线性回归模型，并使用它对一些新数据进行预测，然后使用经过训练的缩放器的inverse_transform()方法将这些数据转换回原始尺度。请注意，我们将标签从Pandas Series转换为DataFrame，因为标准Scaler期望2D输入。此外，为了简单起见，在本示例中，我们仅使用单个原始输入特征(中值收入)对模型进行训练:
from sklearn.linear_model import LinearRegression target_scaler = StandardScaler() scaled_labels = target_scaler.</description>
    </item>
    
    <item>
      <title>为机器学习算法准备数据（Machine Learning 研习之八）</title>
      <link>/article/186/</link>
      <pubDate>Sun, 05 Nov 2023 11:30:06 +0800</pubDate>
      
      <guid>/article/186/</guid>
      <description>本文还是同样建立在前两篇的基础之上的！
属性组合实验 希望前面的部分能让您了解探索数据并获得洞察力的几种方法。您发现了一些数据怪癖，您可能希望在将数据提供给机器学习算法之前对其进行清理，并且发现了属性之间有趣的相关性，特别是与目标属性 之间的相关性。您还注意到一些属性具有向右倾斜的分布，因此您可能需要转换它们(例如，通过计算它们的对数或平方根)。当然，你的里程会因每个项目而有很大的不同，但大致的想法是相似的。
在为机器学习算法准备数据之前，您可能需要做的最后一件事是尝试各种属性组合。例如，如果你不知道一个地区有多少住户，那么这个地区的房间总数就不是很有用。你真正想要的是每个家庭的房间数量。同样，卧室总数本身也不是很有用:你可能想对比一下房间的数量。每个家庭的人口似乎也是一个有趣的属性组合。创建这些新属性如下:
housing[&amp;#34;rooms_per_house&amp;#34;] = housing[&amp;#34;total_rooms&amp;#34;] / housing[&amp;#34;households&amp;#34;] housing[&amp;#34;bedrooms_ratio&amp;#34;] = housing[&amp;#34;total_bedrooms&amp;#34;] / housing[&amp;#34;total_rooms&amp;#34;] housing[&amp;#34;people_per_house&amp;#34;] = housing[&amp;#34;population&amp;#34;] / housing[&amp;#34;households&amp;#34;] 然后你再看一遍相关矩阵:
!新的bedrooms_ratio属性与房屋中值的相关性要比与房间或卧室总数的相关性大得多。显然，卧室/房间比率较低的房子往往更贵。每个家庭的房间数量也比一个地区的房间总数更能说明问题-很明显，房 子越大，就越贵。
这一轮的探索不需要绝对彻底;关键是从正确的角度出发，并迅速获得见解，这将帮助您获得第一个相当好的原型。但是这是一个迭代的过程:一旦你建立并运行了一个原型，你就可以分析它的输出以获得更多的见解，然后再回到这个探索步骤。
为机器学习算法准备数据 是时候为您的机器学习算法准备数据了。你应该为此编写函数，而不是手工操作，这有几个很好的理由:
这将允许您在任何数据集上轻松重现这些转换(例如，下次获得新数据集时)。 您将逐步构建一个转换函数库，以便在未来的项目中重用。 您可以在实时系统中使用这些函数来转换新数据，然后再将其输入到您的算法中。 这将使您能够轻松地尝试各种转换，并查看哪种转换组合效果最好。 但首先，恢复到一个干净的训练集(通过再次复制strat_train_set)。您还应该将预测变量和标签分开，因为您不一定希望对预测变量和目标值应用相同的转换(请注意，drop()创建数据的副本，并且不影响strat_train_set):
housing = strat_train_set.drop(&amp;#34;median_house_value&amp;#34;, axis=1) housing_labels = strat_train_set[&amp;#34;median_house_value&amp;#34;].copy() 清除数据 大多数机器学习算法无法处理缺失的功能，因此您需要处理这些功能。例如，您之前注意到total_bedrooms属性有一些缺失值。你有三个选项可以解决这个问题:
去掉相应的区。
去掉整个属性。
将缺失值设置为某个值(零、均值、中位数等)。这就是所谓的归罪。
您可以使用PandasDataFrame的dropna () 、drop () 和fillna ()方法轻松完成这些任务:
housing.dropna(subset=[&amp;#34;total_bedrooms&amp;#34;], inplace=True) # option 1 housing.drop(&amp;#34;total_bedrooms&amp;#34;, axis=1) # option 2 median = housing[&amp;#34;total_bedrooms&amp;#34;].median() # option 3 housing[&amp;#34;total_bedrooms&amp;#34;].fillna(median, inplace=True) 您决定使用选项3，因为它的破坏性最小，但是您将使用一个方便的Scikit-Learn类:Simplelmputer，而不是前面的代码。这样做的好处是，它将存储每个特征的中值:这将使得它不仅可以估算训练集上的缺失值，还可以估算验证集、测试集和输入到模型的任何新数据上的缺失值。要使用它，首先需要创建一个Simplelmputer实例，指定要将每个属性的缺失值替换为该属性的中位数:
from sklearn.</description>
    </item>
    
    <item>
      <title>端到端的机器学习项目之探索数据（Machine Learning 研习之七）</title>
      <link>/article/188/</link>
      <pubDate>Tue, 24 Oct 2023 19:30:00 +0800</pubDate>
      
      <guid>/article/188/</guid>
      <description>本篇其实是承接上一篇内容，之所以没在上一篇将它写完，那是有原因的，毕竟，本着学习的态度，篇幅不应过长，方能使你有学习的欲望！
探索数据 首先，确保你已经把测试放在一边，你只是在探索训练集。此外，如果训练集非常大，您可能希望对探索进行采样设置，使操作在勘探阶段变得容易和快速。在这种情况下，培训集非常小，所以您可以直接处理完整集。由于你要试验完整训练集的各种变换，你应该制作一份原始的所以你可以在之后恢复它:
housing = strat_train_set.copy() 可视化地理数据 因为数据集包括地理信息(纬度和经度)，所以创建一个所有地区的散点图来可视化数据是一个好主意(见下图):
housing.plot(kind=&amp;#34;scatter&amp;#34;, x=&amp;#34;longitude&amp;#34;, y=&amp;#34;latitude&amp;#34;, grid=True) plt.show() 这看起来很像加州，但除此之外，很难看到任何特别的模式。将alpha选项设置为0.2可以更容易地显示数据点密度高的位置(见下图):
housing.plot(kind=&amp;#34;scatter&amp;#34;, x=&amp;#34;longitude&amp;#34;, y=&amp;#34;latitude&amp;#34;, grid=True, alpha=0.2) plt.show() 现在的情况要好得多:你可以清楚地看到高密度地区，即海湾地区、洛杉矶和圣地亚哥周围，再加上中央山谷(特别是萨克拉门托和弗雷斯诺)的一长排高密度地区。
我们的大脑非常善于发现图片中的模式，但你可能需要玩弄可视化参数，使模式脱颖而出。
接下来，你再看看房价(见下图)。每个圆圈的半径代表该地区的人口(选项s)，颜色代表价格(选项c)。这里使用了一个名为jet的预定义颜色映射(选项cmap)，其范围从蓝色(低值)到红色(高价):s
housing.plot(kind=&amp;#34;scatter&amp;#34;, x=&amp;#34;longitude&amp;#34;, y=&amp;#34;latitude&amp;#34;, grid=True, s=housing[&amp;#34;population&amp;#34;] / 100, label=&amp;#34;population&amp;#34;, c=&amp;#34;median_house_value&amp;#34;, cmap=&amp;#34;jet&amp;#34;, colorbar=True, legend=True, sharex=False, figsize=(10, 7)) plt.show() 这张图告诉你，房价与地理位置(例如，靠近大海)和人口密度密切相关，你可能已经知道了。聚类算法对于检测主集群和添加测量与集群中心的邻近性的新特性应该是有用的。海洋邻近属性也可能是有用的，尽管在北加州沿海地区的房价不是太高，所以这不是一个简单的规则。
寻找相关性 由于数据集不是太大，你可以很容易地使用corr()方法计算每对属性之间的标准相关系数(也称为皮尔逊相关系数):
corr_matrix = housing.corr() 现在您可以查看每个属性与房屋中值的相关性:
相关系数从-1到1。当它接近1时，意味着有很强的正相关关系，例如，当收入中位数上升时，房屋价值中位数往往会上升。当系数接近-1时，意味着有很强的负相关性;你可以看到纬度和房屋价值中间值之间有一个很小的负相关性(即往北走，房价有轻微的下降趋势)。最后，系数接近0意味着不存在线性相关关系。
检查属性之间相关性的另一种方法是使用Pandas scatter_matrix ()函数，该函数将每个数值属性与其他每个数值属性进行绘图。由于现在有11个数字属性，您将得到112=121幅不适合页面的地块，所以您决定将重点放在一些看起来与住房中值最相关的有前途的属性上(见下图):
如果Pandas将每个变量相对于自身绘制，那么主对角线将充满直线，这将不是很有用。因此，Pandas显示每个属性的直方图(其他选项可用;请参阅Pandas文档以获取更多详细信息)。
查看相关散点图，似乎最有希望预测房屋价值中位数的属性是收入中位数，所以你放大他们的散点图(见下图):
housing.plot(kind=&amp;#34;scatter&amp;#34;, x=&amp;#34;median_income&amp;#34;, y=&amp;#34;median_house_value&amp;#34;, alpha=0.1, grid=True) plt.show() 这个情节揭示了一些事情。首先，相关性确实很强;你可以清楚地看到上升的趋势，而且点也不太分散。第二，你之前注意到的价格上限在500，000美元的水平线上明显可见。但这个情节也揭示了其他不那么明显的直线:一条水平线在45万美元左右，另一条大约35万美元左右，也许还有一条大约28万美元，还有几条低于这一点。您可能希望尝试删除相应的区域，以防止您的算法学习重现这些数据怪癖。
警告：
相关系数只测量线性相关性(“当x上升时，y通常上升/下降”)。它可能会完全忽略非线性关系(例如，“当x接近0时，y通常会上升”)。图2-16显示了各种数据集及其相关系数。请注意，尽管它们的轴线显然不是独立的，但底部行的所有图都具有等于0的相关系数:这些都是非线性关系的例子。另外，第二行显示了相关系数等于1或-1的示例;注意，这与斜率无关。例如，以英寸为单位的身高与以英尺或纳米为单位的身高的相关系数为1。</description>
    </item>
    
    <item>
      <title>端到端的机器学习项目（Machine Learning 研习之六）</title>
      <link>/article/183/</link>
      <pubDate>Sat, 14 Oct 2023 17:02:17 +0800</pubDate>
      
      <guid>/article/183/</guid>
      <description>&lt;p&gt;Scikit-Learn提供了一些函数，以各种方式将数据集拆分为多个子集。最简单的函数train_test_split()，它的功能与我们前面定义的shuffle_and_split_data ()函数非常相似，只是增加了几个特性。首先，有一个random_state参数，它允许您设置随机生成器种子。其次，您可以向它传递具有相同行数的多个数据集，它将按照相同的索引将它们拆分(这是非常有用的，例如，如果你有一个单独的DataFrame标签)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>机机器学习的测试和验证（Machine Learning 研习之五）</title>
      <link>/article/182/</link>
      <pubDate>Sun, 27 Aug 2023 16:32:17 +0800</pubDate>
      
      <guid>/article/182/</guid>
      <description>&lt;p&gt;在此保留验证过程之后，您可以在完整的训练集（包括验证集）上训练最佳模型，这将为您提供最终模型。在这种情况下，需要记住的最重要的规则是，验证集和测试集都必须尽可能具有生产中预期使用的数据的代表性，因此它们应该完全由有代表性的图片组成:您可以对它们进行洗牌，将一半放在验证集中，另一半放在测试集中(确保在这两个集合中都没有重复或接近重复的数据)。在网络图片上对模型进行培训之后，如果您观察到模型在验证集上的性能令人失望，您将不知道这是因为您的模型超出了培训集，还是仅仅是由于网络图片和移动应用程序图片之间的不匹配。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>机器学习的主要挑战和任务（Machine Learning 研习之四）</title>
      <link>/article/181/</link>
      <pubDate>Sun, 13 Aug 2023 15:12:38 +0800</pubDate>
      
      <guid>/article/181/</guid>
      <description>&lt;p&gt;对于一个蹒跚学步的孩子来说，要知道什么是苹果，您只需要指着一个苹果说“苹果”(可能会重复这个过程几次)。现在孩子能够识别各种颜色和形状的苹果。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>对于大量数据集的解决方案便是在线学习或是增量学习（Machine Learning 研习之三）</title>
      <link>/article/180/</link>
      <pubDate>Fri, 28 Jul 2023 21:12:38 +0800</pubDate>
      
      <guid>/article/180/</guid>
      <description>&lt;p&gt;随着时间的推移，模型也需做出相应的变化。但就采用新数据与旧数据一起训练，势必需要耗费更多的资源，为了解决这一状况，本文带您了解，关于新数据该如何训练？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>现实生活中机器学习的具体示例（Machine Learning 研习之二）</title>
      <link>/article/179/</link>
      <pubDate>Mon, 17 Jul 2023 21:22:38 +0800</pubDate>
      
      <guid>/article/179/</guid>
      <description>&lt;p&gt;在上一篇，我们初步了解什么是机器学习，以及它能给我们带来，相对于传统编程解决更为优先、易于维护的一套解决方案。那么，本文将继续为您举例，机器学习给我们生活上带来哪些便捷。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>让机器学习不再是过门不入，带您一起详解机器学习（机器学习 Machine Learning 研习之一）</title>
      <link>/article/178/</link>
      <pubDate>Sat, 15 Jul 2023 10:18:38 +0800</pubDate>
      
      <guid>/article/178/</guid>
      <description>&lt;p&gt;让机器学习不再是过门不入，跟着【秋码】一起研习机器学习（Machine Learning），探究什么是机器学习？以及为何我们要去使用机器学习呢？毕竟未来是属于人工智能（Ai）的，引领潮流的往往是新事物，这一次，您可不要再错过了！抓住它，就等于握住了穿梭未来的时光机。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>把握住golang中的template，方能驾驭得了Hugo主题的template</title>
      <link>/article/177/</link>
      <pubDate>Sat, 08 Jul 2023 15:18:38 +0800</pubDate>
      
      <guid>/article/177/</guid>
      <description>&lt;p&gt;不置可否，&lt;code&gt;Hugo&lt;/code&gt;的&lt;code&gt;template&lt;/code&gt;同样是使用&lt;code&gt;golang&lt;/code&gt;的标准库&lt;code&gt;html/template&lt;/code&gt;。为了能实现一个属于自己独特的&lt;code&gt;Hugo theme&lt;/code&gt;，或是修改他人的主题，都得对其&lt;code&gt;模板语法&lt;/code&gt;有所知晓，方能改的称心如意，亦或是制作出一套即简约，又不失典雅的&lt;code&gt;Hugo theme&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>云服务器到期，站点迁移，Nginx配置SSL以备后续只需！</title>
      <link>/article/176/</link>
      <pubDate>Tue, 20 Jun 2023 20:46:20 +0800</pubDate>
      
      <guid>/article/176/</guid>
      <description>&lt;p&gt;三年前（2020-06-20 上午11点左右），各大云厂商&lt;code&gt;6.18&lt;/code&gt;活动还在进行中。一番对比下来，最终还是选择了&lt;code&gt;腾讯云&lt;/code&gt;。然而三年的期限，犹如电光火石一般，眨眼间就过去了。可云服务器到期了，却没有了续费的打算，其中缘由说与谁人听呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（内联汇编 [inline assembly]-Solidity之旅十八）</title>
      <link>/article/175/</link>
      <pubDate>Wed, 28 Dec 2022 20:21:06 +0800</pubDate>
      
      <guid>/article/175/</guid>
      <description>&lt;p&gt;在 Solidity 中使用 &lt;code&gt;Assembly&lt;/code&gt; 的主要好处之一是节省 gas。 让我们尝试通过创建一个将 2 个值 x 和 y 相加并返回结果的函数来比较 Solidity 和 Assembly 之间的 gas 成本。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（库 [library]-Solidity之旅十七）</title>
      <link>/article/174/</link>
      <pubDate>Sat, 24 Dec 2022 21:21:05 +0800</pubDate>
      
      <guid>/article/174/</guid>
      <description>&lt;p&gt;最后，当库函数成为数据类型本身的一部分时，我们可以在其对象上调用该方法，如我们上面的契约所示，即&lt;code&gt;firstNumber.add(secondNumber);&lt;/code&gt; 。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（Constant 和 Immutable 状态变量-Solidity之旅十六）</title>
      <link>/article/173/</link>
      <pubDate>Fri, 23 Dec 2022 22:04:32 +0800</pubDate>
      
      <guid>/article/173/</guid>
      <description>&lt;p&gt;编译器生成的合约创建代码将在返回合约之前修改合约的运行时代码，方法是将对不可变量的所有引用替换为分配给它们的值。 如果要将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，则这一点很重要。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（修改器 [modifier]-Solidity之旅十五）</title>
      <link>/article/172/</link>
      <pubDate>Fri, 23 Dec 2022 09:47:58 +0800</pubDate>
      
      <guid>/article/172/</guid>
      <description>&lt;p&gt;&lt;code&gt;修改器（modifier）&lt;/code&gt;在 Solidity 中是一种特殊类型的函数，用于修改其它函数的行为。例如，开发人员可以使用修改器来检查在允许函数执行之前是否满足某个条件。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（错误处理以及异常-Solidity之旅十四）</title>
      <link>/article/171/</link>
      <pubDate>Wed, 21 Dec 2022 20:42:36 +0800</pubDate>
      
      <guid>/article/171/</guid>
      <description>&lt;p&gt;它有许多功能来解决在编译时或运行时可能发生的潜在问题。即使语法错误检查发生在编译时，运行时错误也很难捕捉，主要发生在合约执行过程中。一些运行时错误的例子包括除以0的类型错误，数组超出索引错误，等等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（函数及其可见性和状态可变性-Solidity之旅十三）</title>
      <link>/article/170/</link>
      <pubDate>Mon, 19 Dec 2022 20:30:23 +0800</pubDate>
      
      <guid>/article/170/</guid>
      <description>&lt;p&gt;对于 public 状态变量会自动生成一个，与状态变量同名的 &lt;code&gt;public&lt;/code&gt;修饰的函数。 以便其他的合约读取他们的值。 当在用一个合约里使用是，外部方式访问 (如: &lt;code&gt;this.x&lt;/code&gt;) 会调用该自动生成的同名函数，而内部方式访问 (如: &lt;code&gt;x&lt;/code&gt;) 会直接从存储中获取值。 Setter函数则不会被生成，所以其他合约&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（事件-Solidity之旅十二）</title>
      <link>/article/169/</link>
      <pubDate>Sun, 18 Dec 2022 20:59:44 +0800</pubDate>
      
      <guid>/article/169/</guid>
      <description>&lt;p&gt;由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。 尤其是，有可能使用一个匿名事件来”伪造”另一个事件的签名。由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。 尤其是，有可能使用一个匿名事件来”伪造”另一个事件的签名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（OOP-接口-Solidity之旅十一）</title>
      <link>/article/168/</link>
      <pubDate>Sun, 18 Dec 2022 15:44:31 +0800</pubDate>
      
      <guid>/article/168/</guid>
      <description>&lt;p&gt;我们知道在&lt;code&gt;Java&lt;/code&gt;里&lt;code&gt;接口&lt;/code&gt;是&lt;code&gt;特殊的抽象类&lt;/code&gt;，限制多于&lt;code&gt;抽象类&lt;/code&gt;，但随着&lt;code&gt;Java&lt;/code&gt;版本的更新，&lt;code&gt;Java&lt;/code&gt;中的&lt;code&gt;接口&lt;/code&gt;是越来越趋于&lt;code&gt;抽象类&lt;/code&gt;了（这样说，可能有点不妥，因为&lt;code&gt;接口&lt;/code&gt;本就是&lt;code&gt;特殊的抽象类&lt;/code&gt;，只是&lt;code&gt;接口&lt;/code&gt;中不能有方法具体实现，而&lt;code&gt;抽象类&lt;/code&gt;还是可以有的！然而随着&lt;code&gt;Java&lt;/code&gt;版本的&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（OOP-抽象合约-Solidity之旅十）</title>
      <link>/article/167/</link>
      <pubDate>Sat, 17 Dec 2022 14:59:55 +0800</pubDate>
      
      <guid>/article/167/</guid>
      <description>&lt;p&gt;即假使合约中至少有一个函数没有实现（没有方法体，只有方法签名的方法），那么便将该合约定义为&lt;code&gt;抽象合约（abstract contract）&lt;/code&gt;。当然咯，前文说到&lt;code&gt;继承&lt;/code&gt;提到的，&lt;code&gt;派生合约&lt;/code&gt;未能给其&lt;code&gt;基合约&lt;/code&gt;的构造函数传递指定参数，这时，该合约便只能声明为&lt;code&gt;抽象&lt;/code&gt;的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（OOP-合约继承-Solidity之旅九）</title>
      <link>/article/166/</link>
      <pubDate>Fri, 16 Dec 2022 20:15:16 +0800</pubDate>
      
      <guid>/article/166/</guid>
      <description>&lt;p&gt;创建合约时， 合约的 构造函数 (一个用关键字 &lt;code&gt;constructor&lt;/code&gt; 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持&lt;code&gt;重载&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（流程控制-Solidity之旅八）</title>
      <link>/article/165/</link>
      <pubDate>Wed, 14 Dec 2022 22:21:38 +0800</pubDate>
      
      <guid>/article/165/</guid>
      <description>&lt;p&gt;今天我们不讲三国，来讲讲 流程控制 关于什么是&lt;code&gt;流程控制&lt;/code&gt;，想来您是知道的吧！可若您确实不晓得，那您看了这篇文或许对&lt;code&gt;流程控制&lt;/code&gt;有了初步的了解。 Solidity 和其他语言一样，支持大部分&lt;code&gt;流程控制&lt;/code&gt;语句，除了&lt;code&gt;switch&lt;/code&gt;和被&lt;code&gt;程序员界&lt;/code&gt;谈虎色变而其他语言又保留的&lt;code&gt;goto&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（单位以及全局变量-Solidity之旅七）</title>
      <link>/article/164/</link>
      <pubDate>Wed, 14 Dec 2022 09:31:48 +0800</pubDate>
      
      <guid>/article/164/</guid>
      <description>&lt;p&gt;时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，而如果他们没收到钱，还可以用一个不同的哈希重新尝试。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）</title>
      <link>/article/163/</link>
      <pubDate>Mon, 12 Dec 2022 22:08:10 +0800</pubDate>
      
      <guid>/article/163/</guid>
      <description>&lt;p&gt;某些情况下，编译器不支持&lt;code&gt;隐式转换&lt;/code&gt;，而这时，作为开发人员的您就不得不使用&lt;code&gt;强硬手段&lt;/code&gt;了。&lt;code&gt;显式转换&lt;/code&gt;可能会发生些您无法预料的状况，所以您需要繁琐的测试，看最终是否能达到您的要求。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（变量作用域-Solidity之旅五）</title>
      <link>/article/162/</link>
      <pubDate>Sun, 11 Dec 2022 21:12:12 +0800</pubDate>
      
      <guid>/article/162/</guid>
      <description>&lt;p&gt;局部变量（Local Variable）的范围仅限于它们被定义的函数，但 状态变量（State Variable） 可以有三种范围。 public - public 修饰的 状态变量（State Variable） 可以在内部以及通过消息进行访问，对于一个公共状态变量，会自动生成一个getter函数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（类型-映射类型-Solidity之旅四）</title>
      <link>/article/161/</link>
      <pubDate>Sat, 10 Dec 2022 20:49:38 +0800</pubDate>
      
      <guid>/article/161/</guid>
      <description>&lt;p&gt;说到&lt;code&gt;映射（Mapping）&lt;/code&gt;，有过其它编程语言经验的您，对这是再熟悉不过了。Solidity 中的&lt;code&gt;映射（Mapping）&lt;/code&gt; 与&lt;code&gt;Java&lt;/code&gt;的&lt;code&gt;Map&lt;/code&gt;、&lt;code&gt;Go&lt;/code&gt;里的&lt;code&gt;Map&lt;/code&gt;以及&lt;code&gt;javascript&lt;/code&gt;的&lt;code&gt;JSON&lt;/code&gt;等众多编程语言中的&lt;code&gt;Map&lt;/code&gt;一样，是用来存储一组&lt;code&gt;键（Key）&lt;/code&gt; &lt;code&gt;值（Value）&lt;/code&gt;，可通过&lt;code&gt;键（Key）&lt;/code&gt;来获取对应&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（类型-引用类型-Solidity之旅三）</title>
      <link>/article/160/</link>
      <pubDate>Fri, 09 Dec 2022 20:56:45 +0800</pubDate>
      
      <guid>/article/160/</guid>
      <description>&lt;p&gt;数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在 存储storage 中，并且公开访问函数的参数需要是 ABI 类型。 状态变量标记 &lt;code&gt;public&lt;/code&gt; 的数组，Solidity创建一个 getter函数 。 小标数字索引就是 getter函数 的参数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>花了不到1块5，玩了下全网最火的ChatGPT</title>
      <link>/article/159/</link>
      <pubDate>Thu, 08 Dec 2022 20:59:39 +0800</pubDate>
      
      <guid>/article/159/</guid>
      <description>&lt;p&gt;这一周来，要说 AI 界最为热闹的莫过于 ChatGPT 了。刚推出一周的时间，注册用户竟然达到了 100 万。自 ChatGPT 推出后，不过短短几天，用户如蜂拥般地去注册，把玩这个能在一周左右吸粉 百来万的现下5网红。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（类型-值类型-Solidity之旅二）</title>
      <link>/article/158/</link>
      <pubDate>Tue, 06 Dec 2022 21:52:25 +0800</pubDate>
      
      <guid>/article/158/</guid>
      <description>&lt;p&gt;以下这些类型在 Solidity 中都属于 值类型： * 布尔类型（bool）：字面常量值 &lt;code&gt;true&lt;/code&gt;和 &lt;code&gt;false&lt;/code&gt; * 整型（int/uint）：分为有符号整型&lt;code&gt;int&lt;/code&gt;和无符号整形&lt;code&gt;uint&lt;/code&gt;，这一点倒是和 c++、golang很相像。不管是无符号还有符号整数，它们都是以 8 位递增到 256 位，而&lt;code&gt;int&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>玩以太坊链上项目的必备技能（初识智能合约语言-Solidity之旅一）</title>
      <link>/article/157/</link>
      <pubDate>Mon, 05 Dec 2022 22:34:42 +0800</pubDate>
      
      <guid>/article/157/</guid>
      <description>&lt;p&gt;Solidity是静态类型的，支持继承、库和复杂的用户定义类型以及其他功能。 使用Solidity，您可以为投票、众筹、盲目拍卖和多签名钱包等用途创建合约。 在部署合约时，你应该使用最新发布的 Solidity 版本。除了特殊情况外，只有最新版本才会收到安全修复。此外，突破性的变化以及新的&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在构建 Web3 前，需先知道什么是区块链，毕竟 Web3 是基于区块链</title>
      <link>/article/156/</link>
      <pubDate>Thu, 01 Dec 2022 20:30:51 +0800</pubDate>
      
      <guid>/article/156/</guid>
      <description>&lt;p&gt;通俗来说，&lt;code&gt;区块链&lt;/code&gt;本质上是一个去中心化的数据仓储，也就是每个人都保留着这个账本，可以认为它是一套加密的分布式超级账本。 比特币是基于区块链技术的第一个应用，也是目前最成功的一个应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Web3 来了，让我们展开双手拥抱它吧！</title>
      <link>/article/155/</link>
      <pubDate>Wed, 30 Nov 2022 20:28:25 +0800</pubDate>
      
      <guid>/article/155/</guid>
      <description>&lt;p&gt;Web3 以前所未有的方式赋予你数字资产的所有权。 例如，假设您正在玩一个 Web2 游戏。 如果您购买游戏内物品，它会直接与您的帐户绑定。 如果游戏创建者删除您的帐户，您将丢失这些物品。 或者如果您停止玩游戏，您将失去投资到游戏内物品的价值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 Moduels 管理（Let&#39;s Go 三十四）</title>
      <link>/article/154/</link>
      <pubDate>Fri, 11 Nov 2022 21:45:59 +0800</pubDate>
      
      <guid>/article/154/</guid>
      <description>&lt;p&gt;在 &lt;code&gt;Go 1.11&lt;/code&gt;以前使用包管理一直被开发者所诟病。既然&lt;code&gt;GOPATH&lt;/code&gt;这种包管理引起了一线开发者的一片骂声，所以，&lt;code&gt;Go&lt;/code&gt;官方体恤一线开发者对&lt;code&gt;GOPATH&lt;/code&gt;这种包管理的情绪，一直致力努力提供对一线开发者友好的包管理解决方法而奋斗。从最初的&lt;code&gt;GOPATH&lt;/code&gt;到&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的包（Let&#39;s Go 三十三）</title>
      <link>/article/153/</link>
      <pubDate>Mon, 07 Nov 2022 20:41:53 +0800</pubDate>
      
      <guid>/article/153/</guid>
      <description>&lt;p&gt;Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的错误处理（Let&#39;s Go 三十二）</title>
      <link>/article/152/</link>
      <pubDate>Thu, 03 Nov 2022 11:10:28 +0000</pubDate>
      
      <guid>/article/152/</guid>
      <description>&lt;p&gt;除了上面的 errors.New 用法之外，我们还可以实现 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的带有缓冲 Channel（Let&#39;s Go 三十一）</title>
      <link>/article/151/</link>
      <pubDate>Mon, 31 Oct 2022 11:27:56 +0000</pubDate>
      
      <guid>/article/151/</guid>
      <description>&lt;p&gt;无缓冲信道 Channel 是无法保存任何值的，该类型信道要求 发送 goroutine 和 接受 goroutine 两者同时准备好，这样才能完成发送与接受的操作。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的单向 Channel（Let&#39;s Go 三十）</title>
      <link>/article/150/</link>
      <pubDate>Sat, 29 Oct 2022 10:53:15 +0000</pubDate>
      
      <guid>/article/150/</guid>
      <description>&lt;p&gt;通过上篇文章，我们知道该怎么声明信道 Channel，以及发送和读取数据。然而本文要讲的是&lt;code&gt;单向Channel&lt;/code&gt;，可单向信道Channel到底是怎样的呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 Channel（Let&#39;s Go 二十九）</title>
      <link>/article/149/</link>
      <pubDate>Thu, 27 Oct 2022 12:43:09 +0000</pubDate>
      
      <guid>/article/149/</guid>
      <description>&lt;p&gt;Channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go 语言对于网络方面也有非常完善的支持。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的并发编程（Let&#39;s Go 二十八）</title>
      <link>/article/148/</link>
      <pubDate>Mon, 24 Oct 2022 11:13:34 +0000</pubDate>
      
      <guid>/article/148/</guid>
      <description>&lt;p&gt;并发与并行并不相同，并发主要由切换时间片来实现“同时”运行，并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的空接口（Let&#39;s Go 二十七）</title>
      <link>/article/147/</link>
      <pubDate>Sun, 23 Oct 2022 13:25:50 +0000</pubDate>
      
      <guid>/article/147/</guid>
      <description>&lt;p&gt;所谓空接口就是没有方法集，以至于任何类型都可实现它，换言之，也就是空接口可以保存任意类型的值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的类型断言（Let&#39;s Go 二十六）</title>
      <link>/article/146/</link>
      <pubDate>Sat, 22 Oct 2022 13:26:16 +0000</pubDate>
      
      <guid>/article/146/</guid>
      <description>&lt;p&gt;如果&lt;code&gt;Type&lt;/code&gt;是具体某个类型，类型断言会检查 &lt;code&gt;varl&lt;/code&gt;的动态类型是否等于具体类型 &lt;code&gt;Type&lt;/code&gt;。如果检查成功，类型断言返回的结果是 &lt;code&gt;varl&lt;/code&gt; 的动态值，其类型是 &lt;code&gt;Type&lt;/code&gt;。 - 如果 &lt;code&gt;Type&lt;/code&gt; 是接口类型，类型断言会检查 &lt;code&gt;varl&lt;/code&gt; 的动态类型是否满足&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的接口（Let&#39;s Go 二十五）</title>
      <link>/article/145/</link>
      <pubDate>Fri, 21 Oct 2022 12:20:28 +0000</pubDate>
      
      <guid>/article/145/</guid>
      <description>&lt;p&gt;要想实现&lt;code&gt;Go&lt;/code&gt;中的接口，类型实现接口方法集的方法，其类型实现的方法签名必须要与接口中的方法集中方法签名一样。 类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的方法（Let&#39;s Go 二十四）</title>
      <link>/article/144/</link>
      <pubDate>Wed, 19 Oct 2022 13:31:31 +0000</pubDate>
      
      <guid>/article/144/</guid>
      <description>&lt;p&gt;Go中的方法是一种特殊的函数，以实现类型与函数进行绑定&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>原创 Go 语言中的结构体（Let&#39;s Go 二十三）</title>
      <link>/article/143/</link>
      <pubDate>Fri, 14 Oct 2022 13:33:44 +0000</pubDate>
      
      <guid>/article/143/</guid>
      <description>&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;中的结构体与&lt;code&gt;c/c++&lt;/code&gt;语言中是差不多，然而对没有接触过&lt;code&gt;c/c++&lt;/code&gt;语言的话，对在看到结构体这一&lt;code&gt;复合类型&lt;/code&gt;是新鲜事物。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的延迟执行【defer】（Let&#39;s Go 二十二）</title>
      <link>/article/142/</link>
      <pubDate>Wed, 12 Oct 2022 12:07:27 +0000</pubDate>
      
      <guid>/article/142/</guid>
      <description>&lt;p&gt;函数作为另一个函数的形参，这就是Go当中的回调函数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的闭包和可变参数（Let&#39;s Go 二十一）</title>
      <link>/article/141/</link>
      <pubDate>Wed, 05 Oct 2022 13:10:40 +0000</pubDate>
      
      <guid>/article/141/</guid>
      <description>&lt;p&gt;在前面几篇文章，我们一直在使用&lt;code&gt;Println、Printf&lt;/code&gt;函数，你可能没有特别注意到，就是我们可以传入任意参数。而这种可以接受任意实参的函数，函数的形参极有可能是&lt;code&gt;可变参数&lt;/code&gt;，使用&lt;code&gt;...type&lt;/code&gt;可声明&lt;code&gt;可变参数&lt;/code&gt;，但必须是形参列表的最后&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的函数变量与匿名函数（Let&#39;s Go 二十）</title>
      <link>/article/140/</link>
      <pubDate>Tue, 04 Oct 2022 12:50:36 +0000</pubDate>
      
      <guid>/article/140/</guid>
      <description>&lt;p&gt;一上来乍一看，函数变量？这究竟是什么意思呢？你函数就函数，变量便是变量，这两者搞在一块，到底是几个意思呢？ 其实啊，在&lt;code&gt;Go&lt;/code&gt;当中，&lt;code&gt;函数&lt;/code&gt;也是一种类型，既然是类型，那就可以向其它类型一样，给变量定义类型啊！而这个类型是&lt;code&gt;函数&lt;/code&gt;，所以&lt;code&gt;函数类型&lt;/code&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的函数详解（Let&#39;s Go 十九）</title>
      <link>/article/139/</link>
      <pubDate>Mon, 03 Oct 2022 11:28:50 +0000</pubDate>
      
      <guid>/article/139/</guid>
      <description>&lt;p&gt;在前面几篇文章，接触到的最多的是&lt;code&gt;main&lt;/code&gt;函数。&lt;code&gt;Go&lt;/code&gt; 如同&lt;code&gt;c/c++&lt;/code&gt;语言一样，对于声明函数也有属于自己的一套规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 goto、break 以及 continue 语句（Let&#39;s Go 十八）</title>
      <link>/article/138/</link>
      <pubDate>Sat, 01 Oct 2022 11:29:09 +0000</pubDate>
      
      <guid>/article/138/</guid>
      <description>&lt;p&gt;在提到关键字&lt;code&gt;goto&lt;/code&gt;，想必很多人都心有余悸吧，毕竟&lt;code&gt;goto&lt;/code&gt;可是编程语言界破坏代码可读性的罪魁祸首啊！以至于像&lt;code&gt;c/c++&lt;/code&gt;或类 c 的编程语言，都将&lt;code&gt;goto&lt;/code&gt;作为保留关键字，不建议使用，但如果你非要使用，谁人可阻止呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 switch 结构（Let&#39;s Go 十七）</title>
      <link>/article/137/</link>
      <pubDate>Fri, 30 Sep 2022 12:54:56 +0000</pubDate>
      
      <guid>/article/137/</guid>
      <description>&lt;p&gt;相较于&lt;code&gt;c/c++&lt;/code&gt;等的&lt;code&gt;switch case&lt;/code&gt;，&lt;code&gt;Go&lt;/code&gt;对&lt;code&gt;switch&lt;/code&gt;做了很大改进，&lt;code&gt;case&lt;/code&gt;与&lt;code&gt;case&lt;/code&gt;之间是不需要写上&lt;code&gt;break&lt;/code&gt;，也能跳出当前&lt;code&gt;case&lt;/code&gt;语句，而且，&lt;code&gt;switch&lt;/code&gt;表达式可以是任何类型的噢！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 for 循环结构（Let&#39;s Go 十六）</title>
      <link>/article/136/</link>
      <pubDate>Thu, 29 Sep 2022 12:03:10 +0000</pubDate>
      
      <guid>/article/136/</guid>
      <description>&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;当中只有&lt;code&gt;for&lt;/code&gt;循环结构，可没有像&lt;code&gt;c/c++&lt;/code&gt;语言有&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do ... while&lt;/code&gt;的。&lt;code&gt;for&lt;/code&gt;循环结构与&lt;code&gt;if&lt;/code&gt;分支结构一样，可以省略&lt;code&gt;()&lt;/code&gt;，左大括号&lt;code&gt;{&lt;/code&gt;必须与&lt;code&gt;for&lt;/code&gt;在同一行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的 if 分支结构（Let&#39;s Go 十五）</title>
      <link>/article/135/</link>
      <pubDate>Wed, 28 Sep 2022 22:12:00 +0800</pubDate>
      
      <guid>/article/135/</guid>
      <description>&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;当中的&lt;code&gt;if&lt;/code&gt;分支与&lt;code&gt;c/c++&lt;/code&gt;大致相同，只是可以省略&lt;code&gt;条件表达式&lt;/code&gt;的小括号&lt;code&gt;()&lt;/code&gt;，真的是，```G哦·``就是要特立独行。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的列表（Let&#39;s Go 十四）</title>
      <link>/article/134/</link>
      <pubDate>Tue, 27 Sep 2022 14:05:01 +0000</pubDate>
      
      <guid>/article/134/</guid>
      <description>&lt;p&gt;列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的字典【map】（Let&#39;s Go 十三）</title>
      <link>/article/133/</link>
      <pubDate>Tue, 27 Sep 2022 12:40:09 +0000</pubDate>
      
      <guid>/article/133/</guid>
      <description>&lt;p&gt;其实，&lt;code&gt;map&lt;/code&gt;是一对&lt;code&gt;key（键）&lt;/code&gt;与&lt;code&gt;value（值）&lt;/code&gt;对应的无序集合，又称为&lt;code&gt;关联数组&lt;/code&gt;或&lt;code&gt;字典&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的数组（Let&#39;s Go 十二）</title>
      <link>/article/132/</link>
      <pubDate>Mon, 26 Sep 2022 12:32:58 +0000</pubDate>
      
      <guid>/article/132/</guid>
      <description>&lt;p&gt;其实啊，切片就好像一个完整的蛋糕，你用刀切了一小块，而这一块就是从那完整的蛋糕切了下来。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的数组（Let&#39;s Go 十一）</title>
      <link>/article/131/</link>
      <pubDate>Sun, 25 Sep 2022 12:51:06 +0000</pubDate>
      
      <guid>/article/131/</guid>
      <description>&lt;p&gt;与&lt;code&gt;c/c++&lt;/code&gt;语言一样，数组的每个元素可以通过&lt;code&gt;索引下标&lt;/code&gt;进行访问，&lt;code&gt;索引下标&lt;/code&gt;是从&lt;code&gt;0&lt;/code&gt;开始到数组长度减去1的位置。&lt;code&gt;内置函数 len()&lt;/code&gt;可以返回数组中元素的个数。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的类型定义与类型别名（Let&#39;s Go 十）</title>
      <link>/article/130/</link>
      <pubDate>Sun, 25 Sep 2022 11:18:22 +0000</pubDate>
      
      <guid>/article/130/</guid>
      <description>&lt;p&gt;类型别名顾名思义就是给类型起个别名。就像上学时候，同学间开玩笑，给人以某种特征起了个外号，又或是英语老师给你起个英文名字，不管是外号、小名还是英文名字，最终都是指向你。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的指针（Let&#39;s Go 九）</title>
      <link>/article/129/</link>
      <pubDate>Sun, 25 Sep 2022 07:34:56 +0000</pubDate>
      
      <guid>/article/129/</guid>
      <description>&lt;p&gt;&lt;code&gt;*&lt;/code&gt;操作符作为&lt;code&gt;右值&lt;/code&gt;时，意义是&lt;code&gt;取指针的值&lt;/code&gt;，作为&lt;code&gt;左值&lt;/code&gt;时，也就是放在&lt;code&gt;赋值操作符的左边&lt;/code&gt;时，表示 &lt;code&gt;a 指针指向的变量&lt;/code&gt;。其实归纳起来，&lt;code&gt;*&lt;/code&gt;操作符的根本意义就是操作&lt;code&gt;指针指向的变量&lt;/code&gt;。当操作在&lt;code&gt;右值&lt;/code&gt;时，就是&lt;code&gt;取指向变量的值&lt;/code&gt;，当操作&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的关键字与标识符（Let&#39;s Go 八）</title>
      <link>/article/128/</link>
      <pubDate>Sat, 24 Sep 2022 12:34:00 +0000</pubDate>
      
      <guid>/article/128/</guid>
      <description>&lt;p&gt;标识符是指&lt;code&gt;Go语言&lt;/code&gt;对各种变量、方法、函数等命名时使用的&lt;code&gt;字符序列&lt;/code&gt;，&lt;code&gt;标识符&lt;/code&gt;由若干个&lt;code&gt;字母&lt;/code&gt;、&lt;code&gt;下划线 _ &lt;/code&gt; 、和&lt;code&gt;数字&lt;/code&gt;组成，&lt;code&gt;且第一个字符必须是字母&lt;/code&gt;。通俗的讲就是凡可以自己定义的名称都可以叫做&lt;code&gt;标识符&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的常量定义（Let&#39;s Go 七）</title>
      <link>/article/127/</link>
      <pubDate>Sat, 24 Sep 2022 11:34:30 +0000</pubDate>
      
      <guid>/article/127/</guid>
      <description>&lt;p&gt;&lt;code&gt;Go&lt;/code&gt;中定义常量与&lt;code&gt;C语言&lt;/code&gt;一样，也是使用&lt;code&gt;const&lt;/code&gt;关键字来定义常量的。常量声明语法：&lt;code&gt;const name [typeName] = value&lt;/code&gt;，其中&lt;code&gt;typeName&lt;/code&gt;（类型）可省略！ 常量可以是字符、字符串、布尔值或数值。 常量不能用 &lt;code&gt;:=&lt;/code&gt; 语法声明。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的类型转换以及类型推导（Let&#39;s Go 六）</title>
      <link>/article/126/</link>
      <pubDate>Sat, 24 Sep 2022 07:50:28 +0000</pubDate>
      
      <guid>/article/126/</guid>
      <description>&lt;p&gt;在声明一个变量而不指定其类型时（即使用不带类型的 &lt;code&gt;:=&lt;/code&gt; 语法或 &lt;code&gt;var =&lt;/code&gt; 表达式语法），变量的类型由右值推导得出。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的字符串（Let&#39;s Go 五）</title>
      <link>/article/125/</link>
      <pubDate>Sat, 24 Sep 2022 06:15:40 +0000</pubDate>
      
      <guid>/article/125/</guid>
      <description>&lt;p&gt;字符串想必是所有编程语言最为基础的类型，当然，Go中也不另外，字符串可根据需要会占用&lt;code&gt;1&lt;/code&gt;到&lt;code&gt;4&lt;/code&gt;个字节内存，由于&lt;code&gt;Go&lt;/code&gt;采用的是&lt;code&gt;UTF-8&lt;/code&gt;字符集编码格式，所以&lt;code&gt;Go&lt;/code&gt;不需要像其他编程语言那样对使用UTF-8字符集的文本进行编码与解码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的多变量同时赋值、匿名变量以及变量作用域（Let&#39;s Go 四）</title>
      <link>/article/124/</link>
      <pubDate>Thu, 22 Sep 2022 13:54:28 +0000</pubDate>
      
      <guid>/article/124/</guid>
      <description>&lt;p&gt;在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Go 语言中的基本类型以及变量声明与初始化（Let&#39;s Go 三）</title>
      <link>/article/123/</link>
      <pubDate>Wed, 21 Sep 2022 13:39:14 +0000</pubDate>
      
      <guid>/article/123/</guid>
      <description>&lt;p&gt;刚才只是声明了变量，并没有给他赋值，虽然可以只是只声明变量，而后赋值也是可以的。但可以在声明变量是并初始化变量，也就是给变量赋初始值。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用集成开发环境来开发Go项目</title>
      <link>/article/122/</link>
      <pubDate>Tue, 20 Sep 2022 12:59:15 +0000</pubDate>
      
      <guid>/article/122/</guid>
      <description>&lt;p&gt;工欲善其事，必先利其器。好的集成开发环境（IDE）能让你事倍功半，好了，废话少扯，下来介绍几种能开发Go项目的IDE。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>window下安装 Go 语言开发包</title>
      <link>/article/121/</link>
      <pubDate>Mon, 19 Sep 2022 15:11:00 +0000</pubDate>
      
      <guid>/article/121/</guid>
      <description>&lt;p&gt;在window下安装最新Go语言开发包&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ag-grid 右键单元格动态改变单元格样式</title>
      <link>/article/120/</link>
      <pubDate>Tue, 14 Jun 2022 11:57:17 +0000</pubDate>
      
      <guid>/article/120/</guid>
      <description>&lt;p&gt;在window下安装最新Go语言开发包自定义单元格单击或右键时，给单元格添加不一样的样式而苦苦搜寻，可找了好久却好像都没有呢？巧了，笔者已经实现了这一看似很简单地功能！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>自定义vxe-table表头标题文字过多，显示两行多余省略号并给出tooltip</title>
      <link>/article/119/</link>
      <pubDate>Sat, 11 Jun 2022 02:57:48 +0000</pubDate>
      
      <guid>/article/119/</guid>
      <description>&lt;p&gt;自定义vxe-table表头标题文字过多，显示两行多余省略号并给出tooltip&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>vue vxe-table表格标题根据内容宽度自动换行</title>
      <link>/article/117/</link>
      <pubDate>Thu, 02 Jun 2022 15:58:34 +0000</pubDate>
      
      <guid>/article/117/</guid>
      <description>&lt;p&gt;表格标题内容过多时，换行显示且多余部分以省略号显示。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Chrome扩展程序开发入门（基于 V3）</title>
      <link>/article/113/</link>
      <pubDate>Tue, 08 Mar 2022 06:05:48 +0000</pubDate>
      
      <guid>/article/113/</guid>
      <description>&lt;p&gt;Chrome扩展指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + Javascript 语言开发[*]。比如著名的 Adblock plus。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04LTS 安装 redis-6.2.6（源码安装）</title>
      <link>/article/112/</link>
      <pubDate>Mon, 10 Jan 2022 10:26:44 +0000</pubDate>
      
      <guid>/article/112/</guid>
      <description>&lt;p&gt;Ubuntu 16.04LTS 安装 redis-6.2.6（源码安装）&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Navicat Premium 12连接Oracle时提示oracle library is not loaded的问题解决</title>
      <link>/article/111/</link>
      <pubDate>Sun, 22 Aug 2021 02:42:26 +0000</pubDate>
      
      <guid>/article/111/</guid>
      <description>&lt;p&gt;解决Navicat12连接Oracle报oracle library is not loaded的提示问题&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git版本控制教程之在Visual Studio Code中如何使用（四）</title>
      <link>/article/109/</link>
      <pubDate>Sat, 24 Jul 2021 07:27:10 +0000</pubDate>
      
      <guid>/article/109/</guid>
      <description>&lt;p&gt;在前面几篇讲解了git命令行的基本操作后，本篇将持续讲解git在VS code编辑器中是如何工作的？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git版本控制教程之分支（三）</title>
      <link>/article/108/</link>
      <pubDate>Sat, 17 Jul 2021 09:41:13 +0000</pubDate>
      
      <guid>/article/108/</guid>
      <description>&lt;p&gt;几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git版本控制教程之为项目打上标签（二）</title>
      <link>/article/107/</link>
      <pubDate>Sun, 11 Jul 2021 07:14:55 +0000</pubDate>
      
      <guid>/article/107/</guid>
      <description>&lt;p&gt;git为项目打上标签，例如，可以在项目稳定阶段或测试阶段，都可以打上一个版本号作为标签名。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Git版本控制入门教程（一）</title>
      <link>/article/106/</link>
      <pubDate>Sat, 10 Jul 2021 06:52:05 +0000</pubDate>
      
      <guid>/article/106/</guid>
      <description>&lt;p&gt;重新整理关于git版本控制的操作教程，相信你在看了这篇文章，你会更加清晰的认识git，和熟练的使用git&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP 处理数据为树状结构</title>
      <link>/article/105/</link>
      <pubDate>Sun, 04 Jul 2021 08:27:52 +0000</pubDate>
      
      <guid>/article/105/</guid>
      <description>&lt;p&gt;PHP处理没有父子级关系的数据为树状结构数据，对二维数组以某个键值相同的分组合并，最终形成树状结构数据&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>BootstrapTable 动态显示/隐藏某一行</title>
      <link>/article/103/</link>
      <pubDate>Sun, 23 May 2021 03:05:04 +0000</pubDate>
      
      <guid>/article/103/</guid>
      <description>&lt;p&gt;手写实现自动隐藏/显示BootstrapTable表格行&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>xhr模拟表单下载文件</title>
      <link>/article/97/</link>
      <pubDate>Sun, 25 Apr 2021 03:56:09 +0000</pubDate>
      
      <guid>/article/97/</guid>
      <description>&lt;p&gt;使用javascript原生XHR下载流文件，可进行计时下载，当然也是可以通过from表单进行下载文件的，但页面可能会有跨域问题，索性就在PHP做个桥接处理了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SpringBoot使用FreeMarker模板发送邮件</title>
      <link>/article/96/</link>
      <pubDate>Sat, 17 Apr 2021 13:38:07 +0000</pubDate>
      
      <guid>/article/96/</guid>
      <description>&lt;p&gt;Springboot2.x结合FreeMarker使用模板定制属于自己的邮件，瞬间是不是觉得很炫酷啊，那还不赶快去试试看啊&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>PHP使用curl上传文件到远程服务器接口</title>
      <link>/article/94/</link>
      <pubDate>Sun, 11 Apr 2021 06:27:44 +0000</pubDate>
      
      <guid>/article/94/</guid>
      <description>&lt;p&gt;PHP使用CURL上传文件到远程服务接口&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>docker 安装[7.2-fpm-alpine]与nginx-1.13.0-alpine</title>
      <link>/article/93/</link>
      <pubDate>Sun, 11 Apr 2021 03:33:51 +0000</pubDate>
      
      <guid>/article/93/</guid>
      <description>&lt;p&gt;docker 容器安装php-fpm和nginx&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu 16.04 LTS 安装redis</title>
      <link>/article/92/</link>
      <pubDate>Sun, 28 Mar 2021 08:02:23 +0000</pubDate>
      
      <guid>/article/92/</guid>
      <description>&lt;p&gt;redis缓存替换为最新版本，所以记录一下安装过程，【秋码记录】redis缓存也做了相应更换，故而微信小程序就没空写了&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微信小程序电商实战—首页篇（上）</title>
      <link>/article/91/</link>
      <pubDate>Sat, 20 Mar 2021 11:47:53 +0000</pubDate>
      
      <guid>/article/91/</guid>
      <description>&lt;p&gt;本文将接上一篇，实现首页上半部分，导航滚动与首页轮播图，首页部分分为两篇来讲解&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>微信小程序电商实战—环境搭建篇</title>
      <link>/article/90/</link>
      <pubDate>Sat, 06 Mar 2021 06:55:30 +0000</pubDate>
      
      <guid>/article/90/</guid>
      <description>&lt;p&gt;微信小程序电商实战之环境搭建篇，首先先去微信公众号—小程序下载微信开发者工具。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fastadmin后台管理之表格行内编辑requireJS加载x-editable.js</title>
      <link>/article/89/</link>
      <pubDate>Sun, 28 Feb 2021 14:12:52 +0000</pubDate>
      
      <guid>/article/89/</guid>
      <description>&lt;p&gt;由于Fastadmin官方只有安装表格可编辑的插件才有这个功能，但笔者是一个爱折腾的人，所以也就有了本文，requireJS加载BootstrapTable扩展功能，表格可编辑，基于x-editable.js扩展库&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Centos7 安装配置 PHP7  Nginx 并部署开源后台系统Fasadmin</title>
      <link>/article/88/</link>
      <pubDate>Sun, 21 Feb 2021 03:34:16 +0000</pubDate>
      
      <guid>/article/88/</guid>
      <description>&lt;p&gt;由于Fastadmin官网文档没有关于Centos7的部署文档，其实与Ubuntu安装部署差不了多少，故而笔者在Centos7部署了Fastadmin。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>git使用教程之创建本地库并关联远程库（笔记整理篇一）</title>
      <link>/article/85/</link>
      <pubDate>Sun, 06 Dec 2020 11:14:01 +0000</pubDate>
      
      <guid>/article/85/</guid>
      <description>&lt;p&gt;Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑 上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各 自的修改推送给对方，就可以互相看到对方的修改了。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Springboot对上传图片添加水印后存储到阿里云OSS对象存储中</title>
      <link>/article/79/</link>
      <pubDate>Sat, 05 Sep 2020 09:14:24 +0000</pubDate>
      
      <guid>/article/79/</guid>
      <description>&lt;p&gt;好些时候没发表文章了，由于最近有点忙，又更兼&lt;code&gt;qiucode&lt;/code&gt;站点页面大改，新版页面也较旧版整洁多了！那具体该是如何实现呢？（言外之意无非就是程序怎么实现的），其实无非就是将&lt;code&gt;MultipartFile&lt;/code&gt;对象进行二次处理（这里所说的处理就是在上传的原图的基础上添加水印），二次处理好了的图片远程存储到阿里云oss存储对象中。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>池塘中鱼的困惑</title>
      <link>/article/118/</link>
      <pubDate>Sun, 18 Aug 2019 20:43:15 +0000</pubDate>
      
      <guid>/article/118/</guid>
      <description>&lt;p&gt;盛夏，多云，晌午时分。一群隐蔽于桥底下乘凉地鱼正往池边四处游来游去，从东边游到西边，游速不是很快，大家在游的过程，都在望着从池塘边路过的人，似乎在期待人们施舍食物。为什么这么说呢？且听当事鱼讲述这池塘的生活经历。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java8四大核心内置函数式接口</title>
      <link>/article/1/</link>
      <pubDate>Sun, 23 Jun 2019 13:30:15 +0000</pubDate>
      
      <guid>/article/1/</guid>
      <description>&lt;p&gt;在前面简单介绍了一些Lambda表达式得好处与语法，我们知道使用Lambda表达式是需要使用函数式接口得，那么，岂不是在我们开发过程中需要定义许多函数式接口，其实不然，java8其实已经为我们定义好了4类内置函数式接口，这4类接口其实已经可以解决我们开发过程中绝大部分的问题，只有一小部分比较特殊得情况需要我们自己去定义函数式接口，本文就简单来学习一下java8内置得4大核心函数式接口。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 8 函数式接口编程</title>
      <link>/article/78/</link>
      <pubDate>Sat, 22 Jun 2019 03:18:26 +0000</pubDate>
      
      <guid>/article/78/</guid>
      <description>&lt;p&gt;Java8与2014年9月份发布的，经过多年市场体验，俨然已有很多开源框架和企业在使用Java8了。介于于此，也该回顾下Java8的新特性了，这样也便于后面看开源框架源码也不至于不知其新语法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title> Extjs 3.3 tree以下的版本在IE10无法点击的解决办法</title>
      <link>/article/114/</link>
      <pubDate>Wed, 24 Apr 2019 21:06:11 +0000</pubDate>
      
      <guid>/article/114/</guid>
      <description>&lt;p&gt;距上篇文章已过去好几天了，说好的一周发表1到3篇文章，难道都让狗吃了吗？现在才发布一篇而且还是转载的文章。好了，闲话少叙，切入正题，Extjs前端框架是比较早的前端mvc框架了，可能很多人都没接触过，而且现在也很少有项目用Extjs框架搭建了，原因是什么？那就不得而知了，有人说是Extjs比较重……&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ztree整合SpringMVC实现异步加载树</title>
      <link>/article/116/</link>
      <pubDate>Fri, 05 Apr 2019 19:17:36 +0000</pubDate>
      
      <guid>/article/116/</guid>
      <description>&lt;p&gt;正值清明时节，天气也将开始升温了，夏天即将到来，你做好准备了吗？好了，废话少扯，切入正题，本文笔者将要讲解的是JQuery的树插件Ztree。现在web项目基本上也都是使用Ztree作为树组件进行实现的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>在npm上发布基于Vue2.x开发的UI组件库（记录篇）</title>
      <link>/article/104/</link>
      <pubDate>Mon, 25 Feb 2019 01:24:32 +0000</pubDate>
      
      <guid>/article/104/</guid>
      <description>&lt;p&gt;解决Navicat12连接Oracle报oracle library is not loaded的提示问题基于Vue开发的UI组件库肯定是要公用的，虽然可以在每创建一个Vue项目时可以复制这些组件，如果组件比较大的情况下呢？是不是很不方便呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>开发一套基于Vue2.x的UI组件库（环境搭建篇《一》）</title>
      <link>/article/83/</link>
      <pubDate>Sat, 16 Feb 2019 23:37:45 +0000</pubDate>
      
      <guid>/article/83/</guid>
      <description>&lt;p&gt;基于Vue2.x开发的UI 组件库有很多，诸如 iView UI组件库、Element UI组件库 等等，既然有这么优秀的UI组件，我们干嘛非要自己开发一套组件呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>这条路，看似很远，望不见的路的“尽头</title>
      <link>/article/115/</link>
      <pubDate>Wed, 06 Feb 2019 19:44:25 +0000</pubDate>
      
      <guid>/article/115/</guid>
      <description>&lt;p&gt;今天天气很好，午后遂与家人去登山，天是那么的蓝，空气是那么的清新，虽然路是崎岖的，但笔者走的还是很开心的！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nexus 2.14.x本地仓库安装与maven配置</title>
      <link>/article/87/</link>
      <pubDate>Sun, 20 Jan 2019 11:47:05 +0000</pubDate>
      
      <guid>/article/87/</guid>
      <description>&lt;p&gt;Nexus私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MPVue开发微信小程序（一）</title>
      <link>/article/84/</link>
      <pubDate>Sun, 02 Dec 2018 11:17:26 +0000</pubDate>
      
      <guid>/article/84/</guid>
      <description>&lt;p&gt;跟着笔者使用mpvue快速开发微信小程序，徐循渐进地开发微信小程序，使用html构建你想要的界面布局&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>双十一抢购云服务器，总有一款适合您</title>
      <link>/article/82/</link>
      <pubDate>Mon, 29 Oct 2018 23:26:20 +0000</pubDate>
      
      <guid>/article/82/</guid>
      <description>&lt;p&gt;深夜发表文章，只为阿里云云服务器双十一搞活动，1核2G 云服务器 1年 84元。如果你错过了上次阿里云拼团的机会，那就在双十一这次拼团不要再错过了，这次拼团也是相对来说性价比也是比较优惠的！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ThinkPHP5.x入门（重拾知识篇）</title>
      <link>/article/110/</link>
      <pubDate>Sat, 27 Oct 2018 21:50:47 +0000</pubDate>
      
      <guid>/article/110/</guid>
      <description>&lt;p&gt;由于这段时间可能会不怎么有空，但基本上每周写一篇吧！看到重拾知识篇就应该知道了吧！笔者肯定对PHP也是了解的，没错，是的，笔者是懂得PHP，那你是不是也跟笔者一样啊？是否也熟知PHP这门号称“世界上最好用的语言”呢？ 是不是曾几何时，有过从事PHP方面的工作呢？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7安装Nginx反向代理服务器（云服务器篇）</title>
      <link>/article/102/</link>
      <pubDate>Sun, 21 Oct 2018 15:21:50 +0000</pubDate>
      
      <guid>/article/102/</guid>
      <description>&lt;p&gt;距上一篇在CentOS 7 安装mysql也已经过去好几天了，正值云服务器试用结束之际，要把原在试用机的配置重新再新服务器安装一遍，在此借这个机会（也正值周日）记录一下Nginx反向代理服务器的配置。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>cocos2d-x实现跑酷游戏之一（重拾知识篇）</title>
      <link>/article/101/</link>
      <pubDate>Thu, 11 Oct 2018 22:47:03 +0000</pubDate>
      
      <guid>/article/101/</guid>
      <description>&lt;p&gt;好久没去关注cocos2d-x游戏引擎了！时隔多久，我是记不太清楚了，本篇属于温习知识吧，毕竟笔者最初的梦想是开发一个像现在大家平时没事就爱消磨时间的游戏，然而，事与愿违，没能成为一个游戏开发者，竟成了一个Java开发者（请允许我也可以在你们这些Java大佬面前自称为Java开发者）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 安装mysql5.6 （云服务器篇）</title>
      <link>/article/100/</link>
      <pubDate>Sun, 07 Oct 2018 21:18:11 +0000</pubDate>
      
      <guid>/article/100/</guid>
      <description>&lt;p&gt;无论是互联网行业，还是其他任何行业，数据对于一个公司来讲是至关重要的，也是企业维系用户的得以持续发展的重要资源！\n对于前两篇文章已经讲解了在CentOS 7如何安装JDK8 和Tomcat7，那么作为JavaWeb开发，显然数据库是必不可少的，至少目前来说是这样的。那好，那就跟笔者循序渐进地开始下去吧！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 安装 Tomcat 7（云服务器篇）</title>
      <link>/article/98/</link>
      <pubDate>Sun, 07 Oct 2018 16:26:14 +0000</pubDate>
      
      <guid>/article/98/</guid>
      <description>&lt;p&gt;在前一篇介绍在CentOS 7如何安装 JDK，而这一篇可以说是开发Javaweb所需的web容器可选之一，如果你在浏览上一篇时已是得心应手了，相信你在CentOS 7安装Tomcat 已经不是什么事了！虽然有点傲慢，但还是可以窃喜的！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CentOS 7 安装JDK 8（云服务器篇）</title>
      <link>/article/99/</link>
      <pubDate>Sun, 07 Oct 2018 11:28:43 +0000</pubDate>
      
      <guid>/article/99/</guid>
      <description>&lt;p&gt;云服务器Centos 7 如何安装JDK？这一篇文章你不容错过！它将介绍你在云服务器CentOS 7 如何安装JDK 8，图文并茂，通俗易懂，新手也能搭配！更何况你呢？如果你正在为如何在云服务器 CentOS 7 中如何安装JDK？那这篇文章再合适不过了！相信我，当你阅读完这篇文章后，云服务器CentOS 7 安装 JDK已不是什么触不可及了，让人望而却步了！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>关于 本站点 的一些秘闻</title>
      <link>/about/</link>
      <pubDate>Sat, 06 Oct 2018 20:12:52 +0800</pubDate>
      
      <guid>/about/</guid>
      <description>关于博主
这该怎么介绍呢？按简介说是‘一个游离于山间之上的Java爱好者’，其实这样说也不为过， 的确是一个Java从业者。然这只是他爱好之一，他对中国历史很是推崇备至，尤其是先秦时期， 特别是春秋战国那段历史，那时候诸子百家，思想空前。而此后便从未有过像春秋战国这样的思想辩论了， 虽说春秋战国时期也有过勾心斗角，但这段历史却没有像后续各个王朝内的奸佞小人与忠臣间的攻于心计来的凶狠。 他还偏爱书法，优爱草书，但苦于无闲暇之余，故许久未曾研习书法，待他日得空，必当重习书法，书体不限！ 除了历史、书法，他还是个文字控，尤其是对古文、古诗词特喜好，每每读到绝佳好词、好诗，他都会将其抄录下来。 当然抛去以上种种爱好，他还想立志成为一个小说家呢，这都是后话了……
秋码记录
其实很早之前就有想弄一个属于自己的网站，但由于种种原因吧，最终也就没建成。时间追溯到2018年10月初， 国庆期间，放假闲暇之余偶然浏览了Layui官网，在其案例页面内浏览了 诸多使用Layui快速搭起了个人博客，在浏览之余，觉得使用Layui 搭建的个人博客界面看上去很是优美，故而自己便马上着手准备开干起来。说干就干，先买了个服务器。而后又注册了 qiucode.cn域名，随后一个基于Springboot2.x+Mybatis+Mysql5.7，前端使用Layui 的个人博客便部署到了服务器上。现在从某种意义上来说，暂且称为【秋码记录】第一版吧！这一版的博客源码也已于 2019年06月27日开源了，源于开源，回馈于开源！
Github地址： https://github.com/zhenqicai/qiucodeBlog
码云地址： https://gitee.com/zhenqi/qiucodeBlog
qiucode-ui
基于Vue2.x开发的一套UI组件库，主要是学习Vue2.x。
github地址： https://github.com/zhenqicai/qiucodeUI
qiucode-ui在线文档地址： https://zhenqicai.github.io/qiucodeUI-docs
同一地方
首部文学作品发表起点中文网，笔名：上官江南。初写或许可能并不是写的那么的好，但既然写了，就会把它写好，写完， 不管怎样都会坚持写下去的。更多的是以起点中文网作为锻炼文学功底的平台。
联系方式
公众号：你我杂志刊
QQ： 2834491983</description>
    </item>
    
    <item>
      <title>友情链接</title>
      <link>/flinks/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/flinks/</guid>
      <description>如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: 秋码记录 desc: 一个游离于山间之上的Java爱好者 avatar: https://qiucode.cn/static/front/images/qiu-logo.png link: https://qiucode.cn </description>
    </item>
    
  </channel>
</rss>
