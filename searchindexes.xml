<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>端到端的机器学习项目（Machine Learning 研习之六）</title><url>/article/183/</url><categories><category>Machine Learning</category><category>人工智能</category></categories><tags><tag>Machine Learning</tag><tag>机器学习</tag><tag>端到端</tag><tag>实战项目</tag></tags><content type="html"> Scikit-Learn提供了一些函数，以各种方式将数据集拆分为多个子集。最简单的函数train_test_split()，它的功能与我们前面定义的shuffle_and_split_data ()函数非常相似，只是增加了几个特性。首先，有一个random_state参数，它允许您设置随机生成器种子。其次，您可以向它传递具有相同行数的多个数据集，它将按照相同的索引将它们拆分(这是非常有用的，例如，如果你有一个单独的DataFrame标签)
使用真实数据
当你在研习机器学习时，最好是使用真实世界中的数据，而不是采用人工数据。巧的是，数以千计的数据集可供选择，涵盖了各种领域。
流行的开放数据存储库： OpenML.org
Kaggle.com
paperswithcode.com
UC Irvine Machine Learning Repository
Amazon’s AWS datasets
TensorFlow datasets
元门户数据库： DataPortals.org
OpenDataMonitor.eu
其他流行的开房数据集： Wikipedia’s list of machine learning datasets
Quora.com
The datasets subreddit
本文数据来自于 StatLib 仓库的加州房价数据（见下图），它是基于 1990 年加利福尼亚州人口普查的数据，而不是最近的数据，不必过于纠结，我们的重心在于研习机器学习，并非是在讨论房价的问题。
看图说话
机器学习的首要任务，是利用加州人口普查数据，建立一个该州房价的模型。你的模型应该从这些数据中学习，并能够在给定所有其他指标的情况下，预测任何地区的房屋中位数价格。
框架问题
建立一个模型可能并不是最终目标，公司期望使用该模式如何从中获益？故而，了解目标是至关重要的，因为它将决定该如何去构建问题、将选择哪些算法、将使用哪些性能度量来评估您的模型，以及您将花费多少精力来调整它。
你的模型的输出(一个地区的房价中位数的预测)将被馈送到另一个机器学习系统(见下图)，以及许多其他的这个下游系统将决定它是否值得在一个给定的领域投资。做好这一点至关重要，因为它直接影响收入。
目前的解决方案是什么样的(如果有的话)。目前的情况往往会给你一个性能的参考，以及如何解决问题 的见解。该地区的 …</content></entry><entry><title>机机器学习的测试和验证（Machine Learning 研习之五）</title><url>/article/182/</url><categories><category>Machine Learning</category><category>人工智能</category></categories><tags><tag>Machine Learning</tag><tag>机器学习</tag><tag>任务</tag><tag>挑战</tag></tags><content type="html"> 在此保留验证过程之后，您可以在完整的训练集（包括验证集）上训练最佳模型，这将为您提供最终模型。在这种情况下，需要记住的最重要的规则是，验证集和测试集都必须尽可能具有生产中预期使用的数据的代表性，因此它们应该完全由有代表性的图片组成:您可以对它们进行洗牌，将一半放在验证集中，另一半放在测试集中(确保在这两个集合中都没有重复或接近重复的数据)。在网络图片上对模型进行培训之后，如果您观察到模型在验证集上的性能令人失望，您将不知道这是因为您的模型超出了培训集，还是仅仅是由于网络图片和移动应用程序图片之间的不匹配。
测试和验证
了解模型对新案例的推广效果的唯一方法是在新案例上进行实际尝试。 一种方法是将模型投入生产并监控其性能。 这很有效，但如果你的模型非常糟糕，你的用户会抱怨——这不是最好的主意。
更好的选择是将数据分为两组：训练集和测试集。顾名思义，您使用训练集训练模型，并使用测试集测试模型。 新案例的错误率称为泛化错误（或样本外错误），通过在测试集上评估模型，您可以获得此错误的估计值。 该值告诉您模型在以前从未见过的实例上的表现如何。
如果训练误差较低（即您的模型在训练集上很少犯错误）但泛化误差较高，则意味着您的模型过度拟合训练数据
通常使用 80% 的数据进行训练，保留 20% 的数据进行测试。 然而，这取决于数据集的大小：如果它包含 1000 万个实例，那么保留 1% 意味着您的测试集将包含 100,000 个实例，可能足以很好地估计泛化误差。
超参数调整和模型选择
评估模型非常简单：只需使用测试集即可。 但是假设您在两种类型的模型（例如线性模型和多项式模型）之间犹豫不决：您如何在它们之间做出决定？ 一种选择是训练两者并比较它们使用测试集的泛化程度。
现在假设线性模型概括得更好，但您想要应用一些正则化以避免过度拟合。 问题是，如何选择正则化超参数的值？ 一种选择是使用该超参数的 100 个不同值来训练 100 个不同的模型。 假设您找到了生成具有最低泛化误差（例如，只有 5% 误差）的模型的最佳超参数值。 您将此模型投入生产，但不幸的是它的性能没有达到预期，并产生 15% 的错误。 刚刚发生了什么？
问题在于您在测试集上多次测量了泛化误差，并且您调整了模型和超参数以生成针对该特定集的最佳模型。 这意味着该模型不太可能在新数据上表现良好。
此问题的常见解决方案称为保留 …</content></entry><entry><title>机器学习的主要挑战和任务（Machine Learning 研习之四）</title><url>/article/181/</url><categories><category>Machine Learning</category><category>人工智能</category></categories><tags><tag>Machine Learning</tag><tag>机器学习</tag><tag>任务</tag><tag>挑战</tag></tags><content type="html"> 对于一个蹒跚学步的孩子来说，要知道什么是苹果，您只需要指着一个苹果说“苹果”(可能会重复这个过程几次)。现在孩子能够识别各种颜色和形状的苹果。
简而言之，由于您的主要任务是选择一个模型并在一些数据上对其进行训练，因此可能出错的两件事是“坏模型”和“坏数据”。 让我们从不良数据的示例开始。
训练数据数量不足
对于一个蹒跚学步的孩子来说，要知道什么是苹果，您只需要指着一个苹果说“苹果”(可能会重复这个过程几次)。现在孩子能够识别各种颜色和形状的苹果。
机器学习还没有完全成熟，大多数机器学习算法都需要大量的数据才能正常工作。即使是非常简单的问题，您通常也需要数千个示例，而对于复杂的问题，如图像或语音识别，您可能需要数百万个示例（除非您可以重用现有模型的部分内容）。
数据的不合理有效性
在2001年发表的一篇著名论文中，微软研究人员MicheleBanko和EricBrill展示了非常不同的机器学习算法，包括相当简单的算法，一旦获得足够的数据(如下图所示)，它们在自然语言消歧这一复杂问题上的表现几乎相同。
正如作者所说，“这些结果表明，我们可能需要重新考虑在算法开发上花费时间和金钱与在语料库开发上花费时间和金钱之间的权衡。”
Peter Norvig等人进一步推广了数据比复杂问题的算法更重要的观点年发表的一篇名为《数据的不合理有效性》的论文中指出，然而，应该注意的是，中小型数据集仍然很常见，而且获得额外的训练数据 并不总是容易或廉价的，所以不要放弃算法。
非代表性训练数据
为了很好地进行归纳，训练数据必须能够代表您想要归纳的新案例，这一点至关重要。无论你使用基于实例的学习还是基于模型的学习，都是如此。
例如，你早些时候用来培训线性模型的一组国家并不完全具有代表性;它不包含人均国内生产总值低于23500美元或高于62500美元的任何国家。下图显示了添加这些国家的数据是什么样子的。
如果根据这些数据训练一个线性模型，您将得到实线，而旧模型则由虚线表示。正如您所看到的，添加几个缺失的国家不仅会显著改变模型，而且它清楚地表明，这样一个简单的线性模型可能永远不会很好地工作。似乎非常富裕的国家并不比中等富裕的国家更幸福(事实上，他们似乎稍微不幸福!)，相反，一些贫穷的国家似乎比许多富裕的国家更幸福。
通过使用不具代表性的训练集，您训练的模型不太可能做出准确的预测，特别是对于非常贫穷和非 …</content></entry><entry><title>对于大量数据集的解决方案便是在线学习或是增量学习（Machine Learning 研习之三）</title><url>/article/180/</url><categories><category>Machine Learning</category><category>人工智能</category></categories><tags><tag>Machine Learning</tag><tag>批量学习</tag><tag>在线学习</tag><tag>机器学习</tag></tags><content type="html"> 随着时间的推移，模型也需做出相应的变化。但就采用新数据与旧数据一起训练，势必需要耗费更多的资源，为了解决这一状况，本文带您了解，关于新数据该如何训练？
批量与在线学习
用于对机器学习系统进行分类的另一个标准是系统可以从输入数据流中增量学习。
批量学习
在批量学习中，系统无法增量学习：必须使用所有可用数据进行训练。 这通常需要大量时间和计算资源，因此通常是离线完成的。 首先对系统进行训练，然后将其投入生产并运行，无需再学习； 它只是应用它所学到的东西。 这就是所谓的离线学习。
不幸的是，模型的性能往往会随着时间的推移而缓慢衰减，这仅仅是因为世界在不断发展，而模型却保持不变。 这种现象通常称为模型腐烂或数据漂移。 解决方案是定期使用最新数据重新训练模型。 您需要执行此操作的频率取决于用例：如果模型对猫和狗的图片进行分类，其性能将下降非常缓慢，但如果模型处理快速发展的系统，例如对金融市场进行预测， 那么它可能会很快衰减。
注意：
即使是一个被训练用来对猫狗图片进行分类的模型，也可能需要定期重新训练，这并不是因为猫狗会在一夜之间发生变异，而是因为摄像头不断变化，图像格式、清晰度、亮度和尺寸比例也会随之变化。此外，明年人们可能会喜欢不同的品种，或者他们可能会决定给他们的宠物戴上小帽子，谁知道呢?
如果您希望批量学习系统了解新数据（例如新型垃圾邮件），则需要在完整数据集（不仅是新数据，还包括旧数据）上从头开始训练新版本的系统 ），然后用新型号替换旧型号。 幸运的是，训练、评估和启动机器学习系统的整个过程可以相当容易地实现自动化，因此即使是批量学习系统也可以适应变化。 只需根据需要更新数据并从头开始训练新版本的系统。
此解决方案很简单，通常效果很好，但使用全套数据进行训练可能需要几个小时，因此您通常每 24 小时甚至每周训练一次新系统。 如果您的系统需要适应快速变化的数据（例如，预测股票价格），那么您需要更具反应性的解决方案。
此外，对全套数据进行训练需要大量的计算资源（CPU、内存空间、磁盘空间、磁盘 I/O、网络 I/O 等）。 如果你有大量数据，并且每天让系统自动化从头开始训练，最终会花费你很多钱。 如果数据量巨大，甚至可能无法使用批量学习算法。
最后，如果您的系统需要能够自主学习并且资源有限（例如智能手机应用程序或火星上的漫游车），则需要携带大量训练数据并占用大量资源，每 …</content></entry><entry><title>现实生活中机器学习的具体示例（Machine Learning 研习之二）</title><url>/article/179/</url><categories><category>Machine Learning</category><category>人工智能</category></categories><tags><tag>Machine Learning</tag><tag>训练数据</tag><tag>模型</tag><tag>机器学习</tag></tags><content type="html"> 在上一篇，我们初步了解什么是机器学习，以及它能给我们带来，相对于传统编程解决更为优先、易于维护的一套解决方案。那么，本文将继续为您举例，机器学习给我们生活上带来哪些便捷。
机器学习在现实中的示例
通过上一篇的讲解，我们多多少少对机器学习（Machine Learning）有了些许了解，同时也对机器学习（Machine Learning）一词不再那么抗拒了。
那么，机器学习到底在现实生活为我们解决哪些难题呢？亦或是传统方案目前无法实现的。
1、可以分析生产线上的产品图像，并对其进行分类。这属于图像分类范畴，通常是使用卷积神经网络（CNN），亦或是Transformer。
2、 可以用于对脑部检测是否存在肿瘤。这便是图像语义分割，图像中的每个像素都被分类 （因为我们想要确定肿瘤的确切位置和形状），通常是使用卷积神经网络（CNN），亦或是Transformer。
3、对新闻文章进行自动分类。这属于自然语言处理（NLP）范畴，更为具体地应该是文本分类。虽然可以使用循环神经网络（RNN）和卷积神经网络来解决，但显然Transformer处理的效果更好。
4、自动标记恶意评论。这也是文本分类范畴，处理的方案也是选用NLP工具。
5、自动总结长文档。这好比去阅读短篇小说，而后总结出讲了什么故事？或者是故事情节脉络。这是NLP的一个分支，称为文本摘要，同样也是使用NLP工具进行处理。
6、搭建聊天机器人或个人助理。这就涉及到诸多NLP组成部分，包括自然语言理解（NLU）和问答模块。
7、根据大量绩效指标来预测公司明年的盈利情况。这属于一个回归任务（即预测值），可以使用任何回归模型（regression model,）来解决，诸如线性回归（ linear regression）、多项式回归（polynomial regression）模型。如果您考虑过去绩效指标的序列，您则会使用RNN、CNN和Transformer。
8、应用程序对语音命令做出反应。这是语音识别，需要处理音频样本，这些样本都是长而复杂的序列，通常使用RNN、CNN和Transformer来处理。
9、检测信用卡欺诈。这属于异常检测。可以使用隔离森林（isolation forests）、高斯混合模型（Gaussian mixture models）和自动编码器（autoencoders）。
10、根据购买情况对客户 …</content></entry><entry><title>让机器学习不再是过门不入，带您一起详解机器学习（机器学习 Machine Learning 研习之一）</title><url>/article/178/</url><categories><category>Machine Learning</category><category>人工智能</category></categories><tags><tag>Machine Learning</tag><tag>训练数据</tag><tag>模型</tag><tag>数据标注</tag></tags><content type="html"> 让机器学习不再是过门不入，跟着【秋码】一起研习机器学习（Machine Learning），探究什么是机器学习？以及为何我们要去使用机器学习呢？毕竟未来是属于人工智能（Ai）的，引领潮流的往往是新事物，这一次，您可不要再错过了！抓住它，就等于握住了穿梭未来的时光机。
什么是机器学习（Machine Learning）？
机器学习是]赋予计算机学习能力的研究领域 无需明确编程。 ——阿瑟·塞缪尔，1959
计算机程序可以从关于某些任务的经验 E 中学习 T 和一些绩效衡量 P，如果其在 T 上的绩效按 P 衡量， 随着经验E的提高而提高。 ——汤姆·米切尔，1997
通俗的说，机器学习（Machine Learning）是计算机编程的科学，它们可以从数据中进行学习。
机器学习好比电子邮件中的垃圾邮件过滤器， 由用户标记出垃圾邮件示例和常规邮件的示例，继而让机器去学习标记垃圾邮件。
那些由用户标记的示例用于学习的称为训练（ training），而每个训练示例则成为训练实例（或称为训练样本），机器学习过程中并作出预测（predictions）的便成为模型（Model）。
神经网络（Neural networks）和随机森林（ random forests）也都是模型的例子。
在这种情况下，任务 T 是标记新电子邮件的垃圾邮件，经验 E 是训练 数据，并且需要定义性能度量P； 例如，您可以使用 正确分类电子邮件的比率。 这种特殊的绩效衡量标准被称为 准确率高，常用于分类任务。
但如果您只是下载所有维基百科文章的副本，您的计算机上还有更多内容数据，但它在任何任务上都不会突然变得更好。 这不是机器学习。
为什么使用机器学习？
我们抛弃机器学习，使用传统编程方式来处理垃圾邮件的过滤器。
1、首先，您得检查垃圾邮件是什么样子的。例如某商城活动推广、房产信息、股票推荐等等。 2、是的，您得为以上出现的种种情况编写一套检测算法。 3、您将测试您的程序并重复 1、2 步骤，直到它足够好为止。 最终您的程序很可能会变成一长串复杂的规则——难以维护。
相比之下，基于机器学习技术的垃圾邮件过滤器会自动学习通过检测异常频率，可以很好地预测垃圾邮件， 与垃圾邮件示例相比， 该程序更短，更容易维护，而且很可能更多准确的。
倘若垃圾邮件发送者发现所有含有商城活动推广链接的电子邮件都被阻止了，那该怎么办 …</content></entry><entry><title>把握住golang中的template，方能驾驭得了Hugo主题的template</title><url>/article/177/</url><categories><category>golang</category><category>模板</category></categories><tags><tag>Hugo</tag><tag>template</tag><tag>主题</tag><tag>theme</tag></tags><content type="html"><![CDATA[  不置可否，Hugo的template同样是使用golang的标准库html/template。为了能实现一个属于自己独特的Hugo theme，或是修改他人的主题，都得对其模板语法有所知晓，方能改的称心如意，亦或是制作出一套即简约，又不失典雅的Hugo theme。
创建golang项目很明显的事，我们首先得先创建个golang项目，才能去讲解golang中的html/template，关于这一点，毋庸置疑。毕竟现在玩的是golang，说的是golang标准库html/template。
好了，闲话少叙，切入正题。关于golang怎么创建项目，您应该是比较清楚的吧！否则的话，您是不会浏览这篇文章的，当然咯，也不能这样说的哦！或许他只是想了解下golang的模板语法，以便能够开发Hugo theme，这倒也是。
关于该如何配置golang的module相关属性，可以查看以往的文章，本文将不再赘述，而是着重讲解html/template语法。
您在您电脑任意空文件下，在cmd（也就是命令行）中键入如下命令即可创建项目。
go mod init template.qiucode.cn #其中 template.qiucode.cn 是您项目模块名称，您可以起个响亮的名字，以便符合您的气质！（纯属笑谈） 在当前目录下新建main.go文件，并键入如下代码：
package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { mux := http.NewServeMux() mux.HandleFunc(&amp;#34;/&amp;#34;, home) mux.HandleFunc(&amp;#34;/blog/view&amp;#34;, snippetView) mux.HandleFunc(&amp;#34;/blog/create&amp;#34;, snippetCreate) log.Print(&amp;#34;Starting server on :4000&amp;#34;) err := http.ListenAndServe(&amp;#34;:4000&amp;#34;, mux) log.Fatal(err) } 我们将原先请求处理方法堆积在main.go文件中，抽离到新文件中。继而需新建handlers.go文件，至于内容便是如下： …  ]]></content></entry><entry><title>云服务器到期，站点迁移，Nginx配置SSL以备后续只需！</title><url>/article/176/</url><categories><category>云服务器</category><category>Nginx</category></categories><tags><tag>Nginx</tag><tag>SSL</tag><tag>https</tag></tags><content type="html"> 三年前（2020-06-20 上午11点左右），各大云厂商6.18活动还在进行中。一番对比下来，最终还是选择了腾讯云。然而三年的期限，犹如电光火石一般，眨眼间就过去了。可云服务器到期了，却没有了续费的打算，其中缘由说与谁人听呢？
导言
在这三年中，其实远不止这三年，可追溯到2014年前后，个人站点便逐渐走向末路。但却总有新的个人博客网站，在这片互联网海洋漂浮着，或许是为了心中的梦想，亦或是记录着工作中所遇到的技术瓶颈。
总之，不管是何缘故，但总会发现一些站点，一夜之间却在那片曾经梦想的海洋中消失了，没有留下只言片语。有人则留言，云服务器到期了，也不打算续了，属于我的站点也将画上句号。
诚然，个人网站也好，论坛也罢。能够支撑其运营下去，不单单只是心中的互联网梦想，更多的怕是怎么能让网站实现盈利，以填补那高昂的云服务器费用！
然而，国内的个人网站被要求不允许投放广告，原因便是网站不具备盈利许可。可个人若要去搞什么经营许可的话，就得办理个体工商户，抑或是注册个公司。所以，以至于有那么多个人站点倒下了。
网站迁移
个人要想盈利，最好便是投放广告，可连广告也不允许了，那还费那个钱干什么！
当然咯，除了投放广告，知识付费也可以给网站带来营收的，但要建在你的网站是有经营许可的前提下。
毕竟，知识付费相对于投放广告来说，还是见效甚微。
在云服务器到期之际，qiucode.cn也将迎来了serverless时代。
使用开源框架 Hugo
构建，主题暂时选用 hugo-theme-next
请注意哦！这里我使用暂时这一词，这说明该主题并不是qiucode.cn最终的网站样式。
Nginx配置SSL
在配置SSL之前，得有SSL证书吧！我相信作为个人站点，很少有人会去购买高阶版的SSL，毕竟有免费的，况且那高昂的费用也不是个人所能承担的起，再说了也没必要。
甭管是哪家云厂商，都有免费的SSL可以申请。现将qiucode.cn部署在云服务器上，关于Nginx配置SSL记录，以备后续只需，哪怕再也不会用上了。
一般情况下，不应在主配置文件nginx.conf内编辑，而是在子文件夹conf.d下新建*.conf文件。
qiucodessl.conf文件内容如下：
upstream qiu{ server 127.0.0.1:8080; } server{ listen 80; server_name www.qiucode.cn qiucode.cn; #return 301 https://$server_name$request_uri; location / { proxy_pass http://qiu; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } rewrite ^/(.*)$ https://www.qiucode.cn:443/$1 permanent; autoindex on; } server { listen 443 ssl; #监听 443 端口 server_name www.qiucode.cn qiucode.cn; #ssl on; ssl_certificate /home/qiucodessl/www.qiucode.cn_bundle.crt; #证书文件路径 ssl_certificate_key /home/qiucodessl/www.qiucode.cn.key; #证书文件路径 ssl_session_timeout 10m; # session 超时时间 ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; #SSL 协议 #ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; ssl_prefer_server_ciphers on; location / { proxy_pass http://qiu; } }</content></entry><entry><title>玩以太坊链上项目的必备技能（内联汇编 [inline assembly]-Solidity之旅十八）</title><url>/article/175/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag></tags><content type="html"> 在 Solidity 中使用 Assembly 的主要好处之一是节省 gas。 让我们尝试通过创建一个将 2 个值 x 和 y 相加并返回结果的函数来比较 Solidity 和 Assembly 之间的 gas 成本。
概要
大抵是讲到汇编，身为编程开发者的我们脑瓜子早就嗡嗡作响了。看那晦涩难懂的低级汇编代码，敢断言，那一行不是我写的，其他行也不是我写的。
自从C语言问世，而后类C语言犹如雨后春笋般地搅动着IT界，而这些语言有别于汇编语言那样。它们就是更贴切自然语言的高级编程语言，可这些高级编程语言最终还是要编译成机器语言（汇编语言）。
EVM（Ethereum Virtual Machine）是一种栈（Stack）结构，我们知道栈是一种先进后出（LIFO）的数据结构。
那为什么要用汇编来编写呢？
借您所问，既然 Solidity 可以编写出优秀的智能合约，那为什么还要使用低级地汇编语言呢？
在回答这个问题之前，我们来看看每个新的编程语言诞生都是为了解决当前编程语言无法解决，或者说使用当前编程语言解决起来比较麻烦，那么，新的编程语言就在这样的环境下应运而生，当然咯，并不是所有新编程语言都是为了解决当前编程语言不能解决的问题，才被开发出来，而是……（此处不便说出缘由，毕竟它也不是本文的重点）。
细粒度控制
Assembly允许您执行一些仅仅靠 Solidity 无法实现的逻辑，比如，指向特定的内存插槽（Memory Slot）。
当我们在编写库（library）时，细粒度控制特别有用，因为它们会被重复使用。
节省 gas
在 Solidity 中使用 Assembly 的主要好处之一是节省 gas。 让我们尝试通过创建一个将 2 个值 x 和 y 相加并返回结果的函数来比较 Solidity 和 Assembly 之间的 gas 成本。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract AssemblyExample { function addAssembly(uint x, uint y) public pure returns (uint) { assembly { let result := add(x, y) mstore(0x0, result) return(0x0, …</content></entry><entry><title>玩以太坊链上项目的必备技能（库 [library]-Solidity之旅十七）</title><url>/article/174/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>library</tag></tags><content type="html"> 最后，当库函数成为数据类型本身的一部分时，我们可以在其对象上调用该方法，如我们上面的契约所示，即firstNumber.add(secondNumber); 。
库（library）
作为开发者的您，想必对项目中重复使用的工具函数，抽取到一个公共中，以便可以在您项目中的其它位置可调用。
而 Solidity 与您所熟知的没有什么不同，它也是用来实现可重复调用，且还能省gas fee。
闲话少叙，切入正题。让我们来看看 Solidity library 吧！
虽然 Solidity 中的library看起来和合约（contract）有些类似，但它并不是一个合约，它包含了可能多个消费者合约共有的功能，这有助于避免冗余。
来看看 Solidity 对library的约束：
1、无状态 -
Solidity中的库是一个无状态实体。它本质上意味着，与合约不同，您不能在一个库中定义状态变量。更简单地说，库函数不允许改变或修改合约的状态。
2、仅供查看的函数
调用库函数不会消耗gas，因为它不会修改合约的状态。换句话说，一个库只能实现pure函数或view函数。
3、内部函数
一个库不能从外部范围调用。其他合约显然可以调用它们，但它们不能从部署的外部访问。
4、不能继承
因为库是一个独立的实体，它不能继承任何其他的库或合约。一个库不能被任何其他实体/库/合同继承。
5、没有回退或支付功能
一个库不能实现回退或支付功能。
（将来有可能会解除这些限制）
如何创建 library（库）
在了解了关于库的一些概念后，让我们来创建一个library。
想要在 Solidity 创建库，需使用library关键字。
//SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; library MyLibrary { function add(uint a, uint b) public pure returns(uint) { return a + b; } } using … for … 使用库
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; import &amp;amp;#34;./library_example.sol&amp;amp;#34;; //导入库 contract …</content></entry><entry><title>玩以太坊链上项目的必备技能（Constant 和 Immutable 状态变量-Solidity之旅十六）</title><url>/article/173/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>Constant</tag><tag>Immutable</tag></tags><content type="html"><![CDATA[  编译器生成的合约创建代码将在返回合约之前修改合约的运行时代码，方法是将对不可变量的所有引用替换为分配给它们的值。 如果要将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，则这一点很重要。
constant（常量）说到常量这一概念，拥有现代编程经历的您，对这一词再熟悉不过了。
常量，常量，顾名思义便是变量值始终不变，这在很多面向对象程序语言中都有。
相对 Solidity 来说，它也是支持常量的。
假若将状态变量（State Vriable）声明为constant（常量），而它的值是在编译时有确定的表达式来给它赋值。
我们知道常量值是在编译时确定的，所以区块数据（例如 block.timestamp, address(this).balance 或者 block.number）或执行数据（ msg.value 或 gasleft() ）或对外部合约的调用来给它们赋值都是不允许的。
允许可能对内存分配产生副作用（side-effect）的表达式，但那些可能对其他内存对象产生副作用的表达式则不允许。
内建（built-in）函数 keccak256 ， sha256 ， ripemd160 ， ecrecover ， addmod 和 mulmod 是允许的（即使他们确实会调用外部合约， keccak256 除外）。
允许内存分配器的副作用的原因是它可以构造复杂的对象，例如： 查找表（lookup-table）。 此功能尚不完全可用。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract ConstantExample { address public constant MY_ADDRESS = 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc; uint public constant MY_UINT = 123; } immutable（不可变量）将状态变量声明为immutable（不可变量）较constant声明的状态变量限制少。
可以在合约的构造函数中或声明时为不可变的变量分配任意值。 不可变量只能赋值一次，并且在赋值之后才可以读取。
编译器生成的合约创建代码将在返回合约之前修改合约的运行时代码，方法是将对不可变量的所有引用替换为分配给它们的值。 如果要将编译器生成的运行时代码与实际存储在区块链中的代码进行比较，则这一点很重要。
不可变量可以在声明时赋值，不过只有在合约的构造函数执行时才被视为视为初始化。 这意味着，你不能用一个依赖于不可变量的值在行内初始化另一个不可变量。 不过，你可以在合约的构造函数中这样做。
这是为了防止对状态变量初始化和构造函数顺序的不同解释，特别是继承时，出现问题。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract ImmutableExample { address public immutable MY_ADDRESS; uint public immutable MY_UINT; constructor(uint _myUint) { MY_ADDRESS = msg.sender; MY_UINT = _myUint; } } // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract ConstantImmutableExample { string constant TEXT = &#34;abc&#34;; bytes32 constant MY_HASH = keccak256(&#34;abc&#34;); uint immutable decimals; uint immutable maxBalance; address immutable owner = msg.sender; constructor(uint decimals_, address ref) { decimals = decimals_; maxBalance = ref.balance; } function isBalanceTooHigh(address _other) public view returns (bool) { return _other.balance &gt; maxBalance; } }   ]]></content></entry><entry><title>玩以太坊链上项目的必备技能（修改器 [modifier]-Solidity之旅十五）</title><url>/article/172/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>modifier</tag><tag>修饰器</tag></tags><content type="html"><![CDATA[  修改器（modifier）在 Solidity 中是一种特殊类型的函数，用于修改其它函数的行为。例如，开发人员可以使用修改器来检查在允许函数执行之前是否满足某个条件。
修改器（modifier）在讲修改器（modifier）之前，我们使用前面几篇文章所学到的知识来实现一个简单的代币类合约。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract InheritanceModifierExample { //账户 =&amp;gt; 金额 映射 mapping(address =&amp;gt; uint) public tokenBalance; //拥有者 address owner; uint tokenPrice = 1 ether; constructor() { owner = msg.sender; tokenBalance[owner] = 100; } function createNewToken() public { //使用 require 检查是不是合约拥有着 require(msg.sender == owner, &amp;#34;You are not allowed&amp;#34;); tokenBalance[owner]++; } function burnToken() public { require(msg.sender == owner, &amp;#34;You are not allowed&amp;#34;); tokenBalance[owner]--; } function purchaseToken() public payable { //检查账户中的代币是否足够 require((tokenBalance[owner] * tokenPrice) / msg.value &amp;gt; 0, &amp;#34;not enough tokens&amp;#34;); tokenBalance[owner] -= msg.value / tokenPrice; tokenBalance[msg.sender] += msg.value / tokenPrice; } function sendToken(address _to, uint _amount) public { …  ]]></content></entry><entry><title>玩以太坊链上项目的必备技能（错误处理以及异常-Solidity之旅十四）</title><url>/article/171/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>异常</tag><tag>错误处理</tag></tags><content type="html"> 它有许多功能来解决在编译时或运行时可能发生的潜在问题。即使语法错误检查发生在编译时，运行时错误也很难捕捉，主要发生在合约执行过程中。一些运行时错误的例子包括除以0的类型错误，数组超出索引错误，等等。
错误处理
作为开发者的我们知道，我们所编写出来的程序难免会出现 bug ，而要做的是捕获异常，给用户抛出一个友好地错误提示。
而在 Solidity 中，根据状态恢复异常来处理错误，该异常将撤销在当前调用中对状态所做的所有修改，与此同时，还向调用者标记错误。
它有许多功能来解决在编译时或运行时可能发生的潜在问题。即使语法错误检查发生在编译时，运行时错误也很难捕捉，主要发生在合约执行过程中。一些运行时错误的例子包括除以0的类型错误，数组超出索引错误，等等。
实际上，Solidity的错误处理确保了原子性这一属性。当一个智能合约调用因错误而终止时，所有的状态变化（即对变量、余额等的改变）都会被恢复，一直到合约调用链。
Solidity 有三种处理错误的方式：require 、assert 和 *revert*。
require
require(condition); require(condition, &amp;amp;#34;description&amp;amp;#34;); require 语句声明了运行该函数的先决条件，即它声明了在执行代码之前应该满足的约束条件。它接受一个参数并在评估后返回一个布尔值，它也有一个自定义的字符串信息选项。如果是false，就会产生异常并终止执行。未使用的gas被返回给调用者，状态被逆转为原始状态。以下是require类型的异常被触发的一些情况。
1、当require(条件表达式)被调用时，其条件表达式结果为false。 2、当一个被消息调用的函数没有正确结束时。 3、当使用 new 关键字创建一个合约，而这个过程没有正常结束。 4、当一个无代码的合约被定位到一个外部函数时。 5、当使用公共getter方法将以太坊发送到合约时。 6、当.transfer()方法失败时。 6.1、当一个断言被调用时，其结果是假的。 6.2、当一个函数的零初始化变量被调用时。 6.3、当一个大值或负值被转换为一个枚举值时。 6.4、当一个值被零除或模数化的时候。 6.5、当在一个索引中访问一个数组，这个数组太大或者是负数。 // SPDX-License-Identifier: …</content></entry><entry><title>玩以太坊链上项目的必备技能（函数及其可见性和状态可变性-Solidity之旅十三）</title><url>/article/170/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>函数</tag><tag>可见性</tag><tag>可变性</tag></tags><content type="html"> 对于 public 状态变量会自动生成一个，与状态变量同名的 public修饰的函数。 以便其他的合约读取他们的值。 当在用一个合约里使用是，外部方式访问 (如: this.x) 会调用该自动生成的同名函数，而内部方式访问 (如: x) 会直接从存储中获取值。 Setter函数则不会被生成，所以其他合约
状态变量可见性
在这之前的文章里，给出的例子中，声明的状态变量都修饰为public，因为我们将状态变量声明为public后，Solidity 编译器自动会为我们生成一个与状态变量同名的、且函数可见性为public的函数！
在 Solidity 中，除了可以将状态变量修饰为public，还可以修饰为另外两种：internal、private。
public
对于 public 状态变量会自动生成一个，与状态变量同名的 public修饰的函数。 以便其他的合约读取他们的值。 当在用一个合约里使用是，外部方式访问 (如: this.x) 会调用该自动生成的同名函数，而内部方式访问 (如: x) 会直接从存储中获取值。 Setter函数则不会被生成，所以其他合约不能直接修改其值。
internal
内部可见性状态变量只能在它们所定义的合约和派生合同中访问， 它们不能被外部访问。 这是状态变量的默认可见性。
private
私有状态变量就像内部变量一样，但它们在派生合约中是不可见的。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract stateVarsVisible { uint public num; function showNum() public returns(uint){ num += 1; return num; } } contract outsideCall { function myCall() public returns(uint){ //实例化合约 stateVarsVisible sv = new stateVarsVisible(); //调用 getter 函数 return sv.num(); } } // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract …</content></entry><entry><title>玩以太坊链上项目的必备技能（事件-Solidity之旅十二）</title><url>/article/169/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>Event</tag><tag>事件</tag></tags><content type="html"><![CDATA[  由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。 尤其是，有可能使用一个匿名事件来”伪造”另一个事件的签名。由于交易日志只存储事件数据而不存储类型。你必须知道事件的类型，包括哪个参数被索引，以及该事件是否是匿名的，以便正确解释数据。 尤其是，有可能使用一个匿名事件来”伪造”另一个事件的签名。
事件（Events）Solidity 中的事件（Events）与任何一种编程语言中事件（Events）一样。
一个事件（Events）是一个合约可继承的成员，它在触发（emit）时存储在交易日志中传递的参数。
在EVM的日志设施下，事件(Events)被用来通知调用应用程序关于合约的当前状态。事件(Events)通知应用程序关于对合约和应用程序所做的改变，可以用来执行依赖逻辑。
如果外部实体需要该日志实际上存在于区块链中的证明，可以请求日志的Merkle证明. 但需要留意的是，由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。
对日志的证明是可能的，如果一个外部实体提供了一个带有这种证明的合约，它可以检查日志是否真实存在于区块链中。
最多三个参数可以接收 indexed 属性（它是一个特殊的名为:ref:”主题” &amp;lt;abi_events&amp;gt; 的数据结构， 而不作为日志的数据部分）。 主题仅有 32 字节， 因此如果 引用类型]标记为索引项，则它们的 keccak-256 哈希值会被作为 主题topic 保存。
所有非索引 indexed 参数是 ABI-encoded 都将存储在日志的数据部分中。
主题topic 让我们可以可以搜索事件，比如在为某些事件过滤一些区块，还可以按发起事件的合同地址来过滤事件。
事件声明事件（Events）在合约中被定义为全局的，并在其函数中被调用。事件（Events）是通过使用events关键字来声明的，后面是一个标识符和参数列表，并以分号结尾。参数值用于记录信息或执行条件逻辑。它的信息和值被保存为块内事务的一部分。不需要提供变量，只有数据类型就足够了。一个事件（Events）可以通过使用其名称和传递所需的参数从任何函数中调用。
event &amp;lt;eventName&amp;gt;(parameters) ; // …  ]]></content></entry><entry><title>玩以太坊链上项目的必备技能（OOP-接口-Solidity之旅十一）</title><url>/article/168/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>接口</tag><tag>interface</tag></tags><content type="html"> 我们知道在Java里接口是特殊的抽象类，限制多于抽象类，但随着Java版本的更新，Java中的接口是越来越趋于抽象类了（这样说，可能有点不妥，因为接口本就是特殊的抽象类，只是接口中不能有方法具体实现，而抽象类还是可以有的！然而随着Java版本的
接口（interface）
我们知道在Java里接口是特殊的抽象类，限制多于抽象类，但随着Java版本的更新，Java中的接口是越来越趋于抽象类了（这样说，可能有点不妥，因为接口本就是特殊的抽象类，只是接口中不能有方法具体实现，而抽象类还是可以有的！然而随着Java版本的推移，Java 接口中可以有方法实现了 ）。
虽然在 Solidity 中的接口跟抽象合约很类似，但接口却不能像抽象合约那样，可以有方法体函数实现。
接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换不应该丢失任何信息。
Solidity 中的接口是不能有函数实现的，且还有以下节点约束：
1、不能继承除了接口外的其他合约 2、接口中的所有函数签名都必须是external。 3、无法声明构造函数。 4、不能定义状态变量。 5、继承接口的合约必须实现接口中声明的函数功能。 就目前来看，接口有这些限制，但在不久的将来，有可能解除某些限制（本次使用的是Solidity ^0.8.0）。
使用关键字interface来声明一个接口。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; interface MyToken { enum TokenType { Fungible, NonFungible } struct Coin { string obverse; string reverse; } function transfer(address recipient, uint amount) external; } // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; interface MyToken { enum TokenType { Fungible, NonFungible } struct Coin { string obverse; string reverse; } // …</content></entry><entry><title>玩以太坊链上项目的必备技能（OOP-抽象合约-Solidity之旅十）</title><url>/article/167/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>抽象合约</tag><tag>abstract</tag></tags><content type="html"><![CDATA[  即假使合约中至少有一个函数没有实现（没有方法体，只有方法签名的方法），那么便将该合约定义为抽象合约（abstract contract）。当然咯，前文说到继承提到的，派生合约未能给其基合约的构造函数传递指定参数，这时，该合约便只能声明为抽象的。
抽象合约（abstract contract）前文在讲合约继承的基类构造函数的参数时，有提到抽象合约，也就是说，如果派生合约未能给其继承的基合约指定构造函数参数时，那么，该派生合约必须声明为抽象合约（abstract contract）。
我们知道Java中抽象类的定义，其一抽象类不能实例化，其二是抽象类中可以拥有 抽象方法(是一种没有方法体的、只有方法签名的方法。)
而在 Solidity 中的抽象合约与Java的抽象类有异曲同工之妙。即假使合约中至少有一个函数没有实现（没有方法体，只有方法签名的方法），那么便将该合约定义为抽象合约（abstract contract）。当然咯，前文说到继承提到的，派生合约未能给其基合约的构造函数传递指定参数，这时，该合约便只能声明为抽象的。
在 Solidity 0.8.x版本以上，抽象合约的抽象函数需加上virtual修饰，而对于的派生合约中的函数实现也得加上override修饰，否则编译过不了。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; //base contract abstract contract Animal { function eat() virtual public ; } contract Bird is Animal { function eat() override public { } } 假使派生合约未能给定所有基类的制定参数（基类构造函数的参数），那该合约也必须声明为抽象的。
解决上图所出现的问题，有两种方式，要么派生合约 contract Snake 给定所有基类构造函数的制定参数；要么将派生合约 Snake声明为抽象（abstract）的。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; //base contract contract Animal { string public name; constructor(string memory _name){ name = _name; } } //爬行动物是动物 contract Reptile { string public Rname; constructor(string memory _name){ Rname = _name; } } abstract contract Snake is Reptile,Animal { //这是一只眼镜蛇 多个基类使用空格隔开 constructor() Animal(&#34;cobra&#34;){} } // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; //base contract contract Animal { string public name; constructor(string memory _name){ name = _name; } } //爬行动物是动物 contract Reptile { string public Rname; constructor(string memory _name){ Rname = _name; } } contract Snake is Reptile,Animal { //这是一只眼镜蛇 多个基类使用空格隔开 constructor() Reptile(&#34;diba&#34;) Animal(&#34;cobra&#34;){} } // SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; //base contract contract Animal { string public name; constructor(string memory _name){ name = _name; } } //爬行动物是动物 contract Reptile { string public Rname; constructor(string memory _name){ Rname = _name; } } contract Snake is Reptile,Animal { //这是一只眼镜蛇 多个基类使用空格隔开 constructor() Reptile(&#34;diba&#34;) Animal(&#34;cobra&#34;){} } 若派生合约继承自抽象合约，而并没有去实现抽象合约中的抽象函数，那么，该合约依然需要标记为抽象（abstract）的。
抽象合约将合约的定义与其实现脱钩，从而提供了更好的可扩展性和自文档性，并消除了代码重复。
  ]]></content></entry><entry><title>玩以太坊链上项目的必备技能（OOP-合约继承-Solidity之旅九）</title><url>/article/166/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>合约继承</tag><tag>extends</tag></tags><content type="html"> 创建合约时， 合约的 构造函数 (一个用关键字 constructor 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。
继承
我们今天不讲别的，就只讲合约继承相关的内容。（您是不是感觉这话挺眼熟的，没错，您确实看过，前一篇开头便是今天我们不讲三国，来讲讲 流程控制，您会觉得我上头了还是怎么！）
闲话少叙，咱们尽快的切入正题。
有过面向对象编程思想（OOP）都知道，继承是比较重要的一环，也正是继承让代码复用，维护也变得简单了起来（当然咯，这只是相对而言，维护工作依旧还是那样！）。
我们知道c++支持多继承，而 Solidity 也是支持多继承的，毕竟是受了它的影响嘛！从事Java的朋友这时可能最想说的是，什么啊，Java 设计者当初就是为了避免多继承所带来的问题，而决定摒弃多继承的。
虽然说多继承会破坏面向对象思想（OOP），但诸如表面上只支持单继承的 PHP，在 PHP 5.4 却引入了triat新特性，弥补了在 PHP 中单继承的不足。
在 Solidity 声明继承关系还是很容易的，使用关键字is，例如：contract Bird is Animal {}。
创建合约时， 合约的 构造函数 (一个用关键字 constructor 声明的函数)会执行一次。 构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。
构造函数执行完毕后，合约的最终代码将部署到区块链上。此代码包括所有公共和外部函数以及所有可以通过函数调用访问的函数。 部署的代码没有 包括构造函数代码或构造函数调用的内部函数。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; //base contract contract Animal { //前面我们讲过 只要将 状态变量声明为 public， //solidity自动会为我们生成一个与状态变量名相同的public 函数 string public name = &amp;amp;#34; base Animal&amp;amp;#34;; } //contract Bird 继承了 contract Animal contract Bird is Animal { //构造器 初始化相关数据 constructor() { name = &amp;amp;#34;bage …</content></entry><entry><title>玩以太坊链上项目的必备技能（流程控制-Solidity之旅八）</title><url>/article/165/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>流程控制</tag></tags><content type="html"><![CDATA[  今天我们不讲三国，来讲讲 流程控制 关于什么是流程控制，想来您是知道的吧！可若您确实不晓得，那您看了这篇文或许对流程控制有了初步的了解。 Solidity 和其他语言一样，支持大部分流程控制语句，除了switch和被程序员界谈虎色变而其他语言又保留的goto。
今天我们不讲三国，来讲讲 流程控制关于什么是流程控制，想来您是知道的吧！可若您确实不晓得，那您看了这篇文或许对流程控制有了初步的了解。
Solidity 和其他语言一样，支持大部分流程控制语句，除了switch和被程序员界谈虎色变而其他语言又保留的goto。
1、if-else// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract C { function ifElseExam(uint8 age) external pure returns(uint8){ if(age &gt; 18){ return 1; }else { return 0; } } } 2、for// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract C { function forLoopExam() external pure returns(uint){ uint sum; //用于记录总和 for(uint i = 0; i &lt;= 10; i ++){ sum += i; } return sum; } } 3、while// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract C { function whileExam() external pure returns(uint){ //解构赋值 与golang多个赋值相似 (uint sum, uint i) = (0,0); while(i &lt;= 10){ sum += i; i ++; } return sum; } } 4、do-while// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract C { function doWhileExam() external pure returns(uint){ //解构赋值 与golang多个赋值相似 (uint sum, uint i) = (0,0); do { sum += i; i ++; } while(i &lt;= 10); return sum; } } 当然咯，Solidity 也是支持continue以及break操作符的。
5、三元运算符 ? :另外，Solidity 还支持三元运算符，其也是Solidity 唯一一个三元运算符，表达式 ? 若表达式为真则返回这个值 : 表达式为假便返回这个值。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract C { /* * @title 比较两个值，若前一个大于后一个 则返回 1，小于便返回 -1，等于则返回 0 * @param int a 第一个数 * @param int b 第二个数 * @return int 1(a &gt; b), 0(a = b),-1(a &lt; b) */ function exam(int a,int b) external pure returns(int){ return (a &gt; b ? int(1) : a &lt; b ? int(-1) : int(0)); } }   ]]></content></entry><entry><title>玩以太坊链上项目的必备技能（单位以及全局变量-Solidity之旅七）</title><url>/article/164/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>全局变量</tag><tag>global variable</tag></tags><content type="html"> 时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，而如果他们没收到钱，还可以用一个不同的哈希重新尝试。
以太币单位（Ether）
甭管是虚拟货币还是现实中的“稳定币”，他们都有各自的货币单位。当然咯，作为以太坊区块链上交易的虚拟货币以太坊也是有属于自己的那一套货币单位的。
而目前以太币（Ether）主要分为这三个：wei、gwei以及ether。或许您之前还见过 finney 和 szabo，但这两个早在solidity 0.7.0就被删除了，而gwei却是solidity 0.6.11新添加的！
使用起来很容易，便是在数字后边跟上这些以太币单位，当然，数字与以太币单位之间需要空格隔开的，这一点想必您应该是清楚的吧！
若没加以太币单位，那么它缺省为wei。
assert(1 wei == 1); assert(1 gwei == 1e9); assert(1 ether == 1e18); 关于assert的用法，我们后续会讲到，可以理解为断言，用于判断表达式是否为true，反之则抛出错误！
时间单位
说到时间单位，您肯定会想到生活中的时（hour）、分（minute）、秒（second）以及天（day）、周（week）。
Solidity 时间单位有：seconds、minutes、hours、days和weeks，seconds是时间的缺省单位。
早期版本（solidity 0.5.0 之前但不包括）还有一个years用来表示年的时间，由于闰年的缘故，便废除了。
1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days uint today = 今天的时间戳; uint tomorrow = today + 1 days; 特殊变量（全局变量）
它们是 Solidity 在全局命名空间 预设的一些变量和函数，用于获取区块链信息和一些通用的工具函数。
区块和交易属性
blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希 —— 仅可用于最新的 256 个区块且不包括当前区块，否则返回 0 …</content></entry><entry><title>玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）</title><url>/article/163/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>基本类型</tag></tags><content type="html"> 某些情况下，编译器不支持隐式转换，而这时，作为开发人员的您就不得不使用强硬手段了。显式转换可能会发生些您无法预料的状况，所以您需要繁琐的测试，看最终是否能达到您的要求。
基本类型之间的转换
熟悉过其他编程语言的您，对基本类型之间的转换并不陌生吧！当然，这基本类型进行转换可分为隐式转换和显示转换。
隐式转换
Solidity 支持隐式转换，通过编译器自动进行转换，而不要开发人员的干涉，这便是隐式转换。
诸如赋值、函数传递实参以及运算操作，通常，是可以进行类型之间的隐式转换，且并不会丢失任何数据。
例如：uint8可以转换成uint16,uint16可以转换成uint32，uint128可以转换成uint256，但uint8却不能转换成uint256.（因为uint256不能覆盖某些值，比如：-1）
假使两个不同类型的值进行操作运算时，编译器则会隐式地将一个类型转换成另一个类型（赋值也是如此），这意味着操作始终是操作数其中一个的类型去执行。
uint8 a = 3; uint16 b = 4; uint32 c = a + b; 无符号整型可以转换成跟它大小相等或更大的字节类型，但反之不能。 任何可以转换成 uint160 的类型都可以转换成 address 类型。
显式转换
某些情况下，编译器不支持隐式转换，而这时，作为开发人员的您就不得不使用强硬手段了。显式转换可能会发生些您无法预料的状况，所以您需要繁琐的测试，看最终是否能达到您的要求。
int8 y = -3; uint x = uint(y); //0xfffff..fd （64 个 16 进制字符） 因为这是 -3 的 256 位补码形式。 如果一个类型显式转换成更小的类型，相应的高位将被舍弃
uint32 a = 0x12345678; uint16 b = uint16(a); // 此时 b 的值是 0x5678 类型推断
类型推导好像是很多编程语言都支持的语法糖吧！无非让您减少代码的编写。
就像Java 8语言设计者好不容易整了个Lambda 表达式，可您却始终没在您的Java代码中去使用它。
苹果（Apple）公司好容易把苹果手机（iphone）设计的越来愈薄，可是到了国内呢，即给手机贴上了膜又让手机套上了那专为手机量身定做的外套，最终这样一来，手机厚了（当然咯，我们还是喜欢厚一点的手机，毕竟拿在手 …</content></entry><entry><title>玩以太坊链上项目的必备技能（变量作用域-Solidity之旅五）</title><url>/article/162/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>变量作用域</tag></tags><content type="html"> 局部变量（Local Variable）的范围仅限于它们被定义的函数，但 状态变量（State Variable） 可以有三种范围。 public - public 修饰的 状态变量（State Variable） 可以在内部以及通过消息进行访问，对于一个公共状态变量，会自动生成一个getter函数。
在前文我们讲过 Solidity 是一种静态类型的语言，这就意味着在声明变量前需先指定类型。
而 Solidity 对变量划分了以下三种作用域范围：
状态变量（State Variable）： 该变量的值被永久地存放在合约存储中，合约内所有函数可访问，其Gas（燃料）消耗高。
局部变量（Local Variable）： 函数体声明的变量，其值在该函数执行前都存在的变量。
全局变量（Global Variable）： 存在于全局命名空间的特殊变量，提供有关区块链和交易属性的信息。
状态变量（State Variable）
其值被永久地存放在一个合约存储中。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract SolidityTest { uint storedData; // 状态变量（State variable） //这是构造器函数 constructor() public { storedData = 10; // 使用 状态变量 } } 局部变量（Local Variable）：
声明变量在函数体的变量，其值在函数执行前一直存在。
// SPDX-License-Identifier: GPL-3.0 pragma solidity ^0.8.0; contract SolidityTest { uint storedData; // 状态变量 //构造器函数 constructor() public { storedData = 10; } //声明一个函数 function getResult() public view returns(uint){ uint a = 1; // 局部变量（local variable） uint b = 2; uint result = a + b; return result; //返回 局部变量 } } 我们做些小改动，让函数返回 状 …</content></entry><entry><title>玩以太坊链上项目的必备技能（类型-映射类型-Solidity之旅四）</title><url>/article/161/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>映射</tag></tags><content type="html"><![CDATA[  说到映射（Mapping），有过其它编程语言经验的您，对这是再熟悉不过了。Solidity 中的映射（Mapping） 与Java的Map、Go里的Map以及javascript的JSON等众多编程语言中的Map一样，是用来存储一组键（Key） 值（Value），可通过键（Key）来获取对应
映射（Mapping）说到映射（Mapping），有过其它编程语言经验的您，对这是再熟悉不过了。Solidity 中的映射（Mapping） 与Java的Map、Go里的Map以及javascript的JSON等众多编程语言中的Map一样，是用来存储一组键（Key） 值（Value），可通过键（Key）来获取对应的值。
Solidity 声明映射（Mapping）格式为：
mapping(KeyType =&amp;gt; ValueType) //KeyType 键（key）类型 ValueType 值（Value）类型 mapping(uint =&amp;gt; address) public addr; 映射中对键、值类型限制1、mapping(KeyType =&amp;gt; ValueType)，其中KeyType可以是除了变长数组、合约、枚举以及结构体的所有类型。然而ValueType对类型没有任何限制，甚至可以包括映射类型`。 2、映射的存储位置只能是存储（storage），因此便只允许作为状态变量、函数内的存储（storage）引用以及作为库函数的参数。但不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系 (key - value pair)。 3、可将映射类型的状态变量声明为public，我们知道，在 Solidity 中，凡是将状态变量声明为public，Solidity 便会自动生成一个getter函数，可通过mapping中的键（key）获取对应的值（value）。 // SPDX-License-Identifier: MIT pragma solidity ^0.4.0; contract MappingExample { mapping(address =&amp;gt; uint) public balances; function update(uint newBalance) public { balances[msg.sender] = …  ]]></content></entry><entry><title>玩以太坊链上项目的必备技能（类型-引用类型-Solidity之旅三）</title><url>/article/160/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>引用类型</tag></tags><content type="html"> 数组元素可以是任何类型，包括映射或结构体。对类型的限制是映射只能存储在 存储storage 中，并且公开访问函数的参数需要是 ABI 类型。 状态变量标记 public 的数组，Solidity创建一个 getter函数 。 小标数字索引就是 getter函数 的参数。
在前文我们讲述了值类型，也就说再修改值类型的时候，每次都有一个独立的副本，如：string 类型的状态变量，其值是无法修改，而是拷贝出一份该状态的变量，将新值存起来。对于处理稍微复杂地值类型时，拷贝将变得愈发大了，也正是介于此，才考虑到将数据存放在内存（memory）或是存放在存储（storage）。
在 Solidity 中，数组（array）和 结构体（struct）属于引用类型。
更改数据位置或类型转换将始终产生自动进行一份拷贝，而在同一数据位置内（对于 存储（storage） 来说）的复制仅在某些情况下进行拷贝。
数据位置和赋值行为
所有的引用类型，如数组（array0和结构体（struct）类型，都有别同于其他类型，那便是引用类型有额外地属性——数据位置。
数据位置，顾名思义就是数据存放的位置在哪里？是在内存（memory）中还是在存储（storage）中。
当然咯，大多时候数据都有默认的存放位置。也可显式地修改其数据存放的位置，只需在类型后添加memory或storage。
而函数参数/形参（包括函数的返回参数）数据位置默认在memory，局部变量数据位置则默认在storage，但状态变量数据位置被强制在storage。
还有一个调用数据（calldata）存储方式，用于存放外部函数（external）的参数/形参，其效果跟memory差不离。
指定数据存放的位置是非常的重要，因为它们将会影响其赋值行为。
在 存储storage 和 内存memory 之间两两赋值（或者从 调用数据calldata 赋值 ），都会创建一份独立的拷贝。 从 内存memory 到 内存memory 的赋值只创建引用， 这意味着更改内存变量，其他引用相同数据的所有其他内存变量的值也会跟着改变。 从 存储storage 到本地存储变量的赋值也只分配一个引用。 其他的向 存储storage 的赋值，总是进行拷贝。 这种情况的示例如对状态变量或 存储storage 的结构体类型的局部变量成员的赋值，即使局部变量本身是 …</content></entry><entry><title>花了不到1块5，玩了下全网最火的ChatGPT</title><url>/article/159/</url><categories><category>人工智能（AI）</category></categories><tags><tag>ChatGPT</tag><tag>人工智能</tag><tag>NLP</tag></tags><content type="html"> 这一周来，要说 AI 界最为热闹的莫过于 ChatGPT 了。刚推出一周的时间，注册用户竟然达到了 100 万。自 ChatGPT 推出后，不过短短几天，用户如蜂拥般地去注册，把玩这个能在一周左右吸粉 百来万的现下5网红。
前提准备
由于种种原因，访问 openAI 需要使用科学上网。
具备科学上网的工具，注意：香港 ip 是 100% 无效的，当然最好是 美国 ip。 有一个能接受验证码的国外手机号码，这一点，并不是所有都有的，我就没有，那该怎么办呢？关于这一点，可接着往下看注册虚拟号码，您也就慢慢清楚标题中的1块5是花在这里了。 注册虚拟号码
首先打开 https://sms-activate.org/
进行注册虚拟号码。
我们先注册个账号，需通过填写的邮箱进行验证账号。
这时，我们在该页面左侧选择服务下的输入框，输入op，即会出现自动补全下拉框，毫无疑问，我们选择第一个OpenAI。
在我们选择了OpenAI后，也就是点选了OpenAI，下面出现所有国家的，当然，我们还是选择第一个，原因嘛，那就是它便宜啊，只需10.5P（10.5卢布）。
而在我们点击了那个 购物车 图标时，出现错误提醒，那便是，你的 余额是 0，需要充值，才能购买。
点击 左上角 人头图标，再列出的下拉框，再次点击充值。
在点击 充值 选项时，这时，页面列出很多 支付方式，往下滚动直找到 支付宝。
这里是使用 美元 做为单位，我们充0.2美元足够了，而 0.2 美元在当下当时兑换成人民币是 1.47 元，1块5还不到。
支付宝 扫码支付。
如果在注册OpenAI 账号时，出现了以下提示，那么说明科学上网是局部，需 全局 科学上网。
注册OpenAI一部分是通过 邮箱 进行验证，另一部分则是通过 手机号码 接受验证 再次验证。
填写接收的邮箱验证，进入下一步 手机号码 验证。
我们拷贝刚刚购买的虚拟手机号码。
注意：我们将虚拟号码平台上购买的号码拷贝填入OpenAI，用于接收短信验证码，而这里需要注意将国家区号去掉，因为我们在OpenAI平台选择国家时，带有国家区号，然而，我们在虚拟平台上购买的虚拟号码包括国家区号。
回到虚拟号码平台，若是没看到验证码，可以刷新下页面就出来了。
拷贝接收的验证码黏贴到OpenAI，注册完成，出现下面页面那就成功了。
我们重写打开个页签， …</content></entry><entry><title>玩以太坊链上项目的必备技能（类型-值类型-Solidity之旅二）</title><url>/article/158/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>值类型</tag></tags><content type="html"> 以下这些类型在 Solidity 中都属于 值类型： * 布尔类型（bool）：字面常量值 true和 false * 整型（int/uint）：分为有符号整型int和无符号整形uint，这一点倒是和 c++、golang很相像。不管是无符号还有符号整数，它们都是以 8 位递增到 256 位，而int
Solidity 在编译事需指定变量（状态变量和局部变量）。
虽然 Solidity 受到了 c++、python以及 javascript 的影响，但 undefined和null是不存在的，当然咯，每个新声明的变量总是有默认值的，显然这默认值是跟其声明的类型相关的。
而 Solidity 将类型统归纳为值类型、引用类型、映射类型。本文将先从值类型 讲起。
值类型 ，顾名思义便是按值进行赋值变量或传递给函数，它们总是会将值拷贝（相对于指针传递，也可以说是引用传递）。
以下这些类型在 Solidity 中都属于 值类型：
布尔类型（bool）：字面常量值 true和 false 整型（int/uint）：分为有符号整型int和无符号整形uint，这一点倒是和 c++、golang很相像。不管是无符号还有符号整数，它们都是以 8 位递增到 256 位，而int和uint分别是int256和uint256的别名 定长浮点型：（fixed/ufixed）：目前 Solidity 还没完成地支持它，也就是可以在文件中声明这种类型，但却不能赋值给这种类型，同样也不能赋值给其他变量的。ufixedMxN 和 fixedMxN 中，M 表示该类型占用的位数，N 表示可用的小数位数。M 是从 8 位 到 256位 ，N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。 地址类型（address）：这是 Solidity 特有的类型，存储 20 字节的值（以太坊地址大小）。不过，还有表示可支付的地址类型address payable，它与address类型相同，不过它有成员函数 transfer 和 send ，以便它可以方便进行以太币转账以及查询。 合约类型（constract）：也就是每定义一个constract，便是一个合约类型。 定长字节数 …</content></entry><entry><title>玩以太坊链上项目的必备技能（初识智能合约语言-Solidity之旅一）</title><url>/article/157/</url><categories><category>区块链</category><category>智能合约</category><category>Solidity</category></categories><tags><tag>以太坊</tag><tag>区块链</tag><tag>智能合约</tag><tag>在线编辑器</tag><tag>remix</tag></tags><content type="html"> Solidity是静态类型的，支持继承、库和复杂的用户定义类型以及其他功能。 使用Solidity，您可以为投票、众筹、盲目拍卖和多签名钱包等用途创建合约。 在部署合约时，你应该使用最新发布的 Solidity 版本。除了特殊情况外，只有最新版本才会收到安全修复。此外，突破性的变化以及新的
前面一篇关于智能合约翻译文讲到了，是一种计算机程序，既然是程序，那就可以使用程序语言去编写智能合约了。
而若想玩区块链上的项目，大部分区块链项目都是开源的，能看得懂智能合约代码，或找出其中的漏洞，那么，学习Solidity这门高级的智能合约语言是有必要的，当然，这都得在公链 以太坊上，毕竟国内的联盟链有些是不兼容Solidity。
Solidity 是一种面向对象的高级语言，用于实现智能合约。智能合约是管理以太坊状态下的账户行为的程序。
Solidity 是运行在以太坊（Ethereum）虚拟机（EVM）上，其语法受到了c++、python、javascript影响。
Solidity是静态类型的，支持继承、库和复杂的用户定义类型以及其他功能。
使用Solidity，您可以为投票、众筹、盲目拍卖和多签名钱包等用途创建合约。
在部署合约时，你应该使用最新发布的 Solidity 版本。除了特殊情况外，只有最新版本才会收到安全修复。此外，突破性的变化以及新的功能会定期引入。我们目前使用0.y.z版本号来表示这种快速变化的速度。
Solidity 具有以下两个显著特征（纯属笑谈，别太在意）：
1、面向对象：学会之后能挣钱去找对象 2、在币圈混：不会 Solidity ，在圈内显得是那么 low，“瞧，那家伙不会 Solidity，还想混币圈！” 在线编辑器 remix
工欲善其事，必先利其器。 这句话是很有道理的，不管做什么事或在学习新事物，都要准备好工具，学习新事物也是一样的。
打开浏览器，在地址栏输入
remix.ethereum.org
打开后的默认界面，包含 Solidity 示例。首次打开可能没那么快，这毕竟国外的站点。
我们在当前工作空间新建一个 solidity 文件，注意，是以sol作为文件的后缀名。
// SPDX-License-Identifier: MIT pragma solidity ^0.8.7; contract MyToken{ string …</content></entry><entry><title>在构建 Web3 前，需先知道什么是区块链，毕竟 Web3 是基于区块链</title><url>/article/156/</url><categories><category>Web3</category><category>区块链</category></categories><tags><tag>区块链</tag><tag>Web3</tag></tags><content type="html"> 通俗来说，区块链本质上是一个去中心化的数据仓储，也就是每个人都保留着这个账本，可以认为它是一套加密的分布式超级账本。 比特币是基于区块链技术的第一个应用，也是目前最成功的一个应用。
什么是区块链
要说什么是区块链，那么这里就不得不提比特币了，它是一种点对点（Peer to Peer，P2P）形式的去中心化加密货币，点对点的传输意味着是一个去中心化的支付系统。比特币的概念最初是由中本聪在2008年10月31日提出，于2009年1月3日，中本聪用个人电脑挖出了世界上第一批块比特币（也称创世区块），由此正式宣告了比特币的诞生。
由于2008年的金融危机爆发的原因，比特币之父中本聪才想要构建一套不受中心化机构控制的电子货币，他构思底层时决定抛弃中心化数据存储，设计出强去中心化的底层机制。而这种机制是所有人都可以参与进来，相互平等，没有任何的中心化团队或者机构干预，且数据一旦记录，是没有办法去篡改的。
随着时间不断地向前移动，人们逐渐发现比特币底层的这套机制优势越来越明显了，换句话说，即便是创始人不在了，它照样运行下去，既然这套机制有这么多优势，何不把它从比特币底层提取出来呢？
那么，区块链是不是由中本聪创造的呢？其实不是的，他只是在前人的基础进行发扬光大，可以说是站在巨人的肩膀上，那是不愁吃穿啊！（当然咯，天赋是很重要的哦，要不然我也不会在这里发文了）。
前提概要说的差不多了，到这里您想必总算知道区块链是怎么来的吧！若您还是一头雾水，或是说，您本还有点头绪，可看了上面那些文字更懵了。没事的，既然上面的文字没能让您看明白，那就忽略上段文字，直接来了解到底什么、是区块链？
通俗来说，区块链本质上是一个去中心化的数据仓储，也就是每个人都保留着这个账本，可以认为它是一套加密的分布式超级账本。
比特币是基于区块链技术的第一个应用，也是目前最成功的一个应用。
而区块链最为显著地特点便是去中心化了。
举几个生活中常见的中心化例子，想必您也就明白l了。
我们平时存钱或是单位/公司发放工资时，所有的交易都在银行，因为老百姓信任它，若不然把存入自己家中的保险柜中。
不管是工作还是生活，如今的人们恐怕很难脱离微信了吧！当然咯，QQ还是年轻一代的社交工具，如YYDS这种中文拼音缩写不正是这些年轻一代交流的方式嘛，也有人对这种中文拼音缩写很不屑，其中也包括年轻一代的他们，“中文都没说好，还什 …</content></entry><entry><title>Web3 来了，让我们展开双手拥抱它吧！</title><url>/article/155/</url><categories><category>Web3</category><category>区块链</category></categories><tags><tag>区块链</tag><tag>Web3</tag></tags><content type="html"> Web3 以前所未有的方式赋予你数字资产的所有权。 例如，假设您正在玩一个 Web2 游戏。 如果您购买游戏内物品，它会直接与您的帐户绑定。 如果游戏创建者删除您的帐户，您将丢失这些物品。 或者如果您停止玩游戏，您将失去投资到游戏内物品的价值。
Web3的由来
在介绍Web3概念，有必要阐述下当下的网络世界。而如今的互联网正处于Web2阶段，其已经帮助数以亿计的人融入这个互联网大家庭，可在网络上构建可靠、稳定的基础设施。然而也正是Web2中心化网络成就了极少数互联网巨头，他们几乎垄断了互联网，由于数据都保存在中心网络内，以至于那些手头拥有数据的中心化巨头，可以为所欲为，完全没有考虑到用户的感受！
也正是因为Web2中心化网络，只有极少数互联网巨头拥有了大部分人的数据，让用户感到自己的数据不应该存在中心化网络上，所以，去中心化Web3应运而生，使得用户对数据有拥有权，这一点很重要，它是区别于Web2中心化网络的关键要素，也就是说，Web3不仅可以对数据读写，还能拥有数据。比如：起点中文网新更改的合同，合同大致是，以后要是在阅文集团旗下攥写小说，其著作权竟不属于小说作者，而是属于阅文集团，哇擦，这是什么合同啊？当然咯，此合同一经发布，起点众多大神（起点网对小说作者级别称呼）纷纷断更（网络戏称：”五五断更节“，因为那天正是 5月5号），没过几天，起点某大神在网络上发起众筹，另起炉灶搭建了一个新的小说站点（息壤中文网）。若是小说平台是处于Web3去中心化网络，起点中文网还能不能那样为所欲为呢？
Web 1：只读（1990~2004）
当然咯，我没见过Web 1所带来的互联网是怎么样的？想必，正在屏幕前浏览这篇文章的你，也是没见过Web 1，倘若你见过，那就当我没说过。Web 1阶段，说白了，就是用户只能浏览页面，不能在界面输入自己对该篇文章的理解。可以理解为企业/公司拥有其静态网站，用户只能看，不能与之进行交互。
Web 2：能读写（2004~至今）
由于Web 1只读不写的缺陷，Web 2弥补了Web 1不能写的不足。也正是这个Web 2阶段，互联网不再是只读，还可以向用户提供平台让其创作内容。Web 2也让越来越多的人蜂拥互联网，这其中不乏产生出了独角兽，当然咯，成功的人是少数的，也正是这些极少数的独角兽互联网巨头逐渐开始掌控海量的流量以及其内容产生的价值。比 …</content></entry><entry><title>Go 语言中的 Moduels 管理（Let's Go 三十四）</title><url>/article/154/</url><categories><category>golang</category></categories><tags><tag>golang</tag><tag>Moduels</tag></tags><content type="html"><![CDATA[  在 Go 1.11以前使用包管理一直被开发者所诟病。既然GOPATH这种包管理引起了一线开发者的一片骂声，所以，Go官方体恤一线开发者对GOPATH这种包管理的情绪，一直致力努力提供对一线开发者友好的包管理解决方法而奋斗。从最初的GOPATH到
在 Go 1.11以前使用包管理一直被开发者所诟病。既然GOPATH这种包管理引起了一线开发者的一片骂声，所以，Go官方体恤一线开发者对GOPATH这种包管理的情绪，一直致力努力提供对一线开发者友好的包管理解决方法而奋斗。从最初的GOPATH到GO VENDOR，再到现在最新的GO MODULES，这期间，Go 官方不免走了很多弯路，但展现在我们跟的GO MODULES已是很像样的模块管理了。
在命令行窗口输入 go env命令，可以看到，多了个GO111MODULE变量，111是代表Go 1.11版本提出来的。
它有三个可选值：off、on、auto，默认值是auto。
GO111MODULE=off禁用模块支持，编译时会从GOPATH和vendor文件夹中查找包。 GO111MODULE=on启用模块支持，编译时会忽略GOPATH和vendor文件夹，只根据 go.mod下载依赖。 GO111MODULE=auto，当项目在$GOPATH/src外且项目根目录有go.mod文件时，自动开启模块支持。 ``GO111MODULE在Go 1.13`版本之后默认是开打的。
go mod 依赖管理go mod不再依靠$GOPATH，以至于它可以不必在$GOPATH目录创建 Go 项目。
依次在该目录创建文件夹和main.go文件。
使用以下命令自动生成go.mod文件。
go mod init github.com/zhenqi/module-main 编辑main.go文件，输入以下内容。
package main import ( log &#34;github.com/sirupsen/logrus&#34; ) func main(){ log.WithFields(log.Fields{ &#34;animal&#34;: &#34;walrus&#34; }).Info(&#34;A walrus appears&#34;) } 由于使用了第三方依赖库，需要先下载依赖库。
go get github.com/sirupsen/logrus 执行该语句会报错。
这是由于自Go 1.13以后的版本，GOPROXY默认值为proxy.golang.org，很不巧，这个地址在国内却无法访问啊！那该怎么办呢？好在国内大厂商提供了镜像，那便是 七牛云 推出的 goproxy.cn，好让国内开发者更好的使用GO MODULES。
go env -w GOPROXY=https://goproxy.cn,direct 再次运行go get github.com/sirupsen/logrus命令，可以看到，正在下载第三方依赖。
打开go.mod文件，明显追加了几行内容。
  ]]></content></entry><entry><title>Go 语言中的包（Let's Go 三十三）</title><url>/article/153/</url><categories><category>golang</category></categories><tags><tag>golang</tag><tag>package</tag><tag>包</tag></tags><content type="html"><![CDATA[  Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。
Go语言的包借助了目录树的组织形式，一般包的名称就是其源文件所在目录的名称，虽然Go语言没有强制要求包名必须和其所在的目录名同名，但还是建议包名和所在目录同名，这样结构更清晰。
包可以定义在很深的目录中，包名的定义是不包括目录路径的，但是包在引用时一般使用全路径引用。比如在GOPATH/src/a/b/下定义一个包 c。在包 c 的源码中只需声明为package c，而不是声明为package a/b/c，但是在导入 c 包时，需要带上路径，例如import &quot;a/b/c&quot;。
包的习惯用法：
包名一般是小写的，使用一个简短且有意义的名称。 包名一般要和所在的目录同名，也可以不同，包名中不能包含-等特殊符号。 包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName目录下。 包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。 一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。 导入包使用 import 关键字可以导入自定义包或第三方包。
import &#34;包路径&#34; //包路径是相对于 GOPATH 而包的导入又可以有两种写法。
单行倒入import &#34;包A的路径&#34; import &#34;包B的路径&#34; 多行导入import ( &#34;包A的路径&#34; &#34;包B的路径&#34; ) 包的引用格式1)、标准引用格式import &#34;fmt&#34; 这样便可以使用fmt.来引用fmt包中的方法。
package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Welcome to https://qiucode.cn&#34;) } 2）、别名引用格式在导入包时，可以给导入的这个包起个别名。
import f &#34;fmt&#34; 3）、省略引用格式使用.省略了包名.来访问包内方法。
import . &#34;fmt&#34; 4)、匿名引用格式在前面介绍过可以使用_来忽略变量，若用在导入包的时候，只是执行了该包的init()。
import ( &#34;fmt&#34; _ &#34;time&#34; )   ]]></content></entry><entry><title>Go 语言中的错误处理（Let's Go 三十二）</title><url>/article/152/</url><categories><category>golang</category></categories><tags><tag>异常处理</tag><tag>错误处理</tag><tag>error</tag></tags><content type="html"><![CDATA[  除了上面的 errors.New 用法之外，我们还可以实现 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。
在 Go 语言中可没有像 Java、PHP、C# 等这些编程，使用 try、catch 来处理程序在运行时产生异常。
Go 内置了一个 error 接口。
type errror interface { Error() string } package main import ( &#34;errors&#34; &#34;fmt&#34; &#34;math&#34; ) func Sqrt(f float64) (float64, error) { if f &lt; 0 { //使用 New() 函数返回一个新的 error return -1, errors.New(&#34;math: square root of negative number&#34;) } return math.Sqrt(f), nil } func main() { result, err := Sqrt(-7) if err != nil { fmt.Println(err) } else { fmt.Println(result) } } 自定义错误类型除了上面的 errors.New 用法之外，我们还可以实现 error 接口自定义一个 Error() 方法，来返回自定义的错误信息。
package main import ( &#34;fmt&#34; &#34;math&#34; ) type myError struct { Num float64 message string } func (e myError) Error() string { return fmt.Sprintf(&#34;出现错误：%.0f 为负数&#34;, e.Num) } func Sqrt(f float64) (float64, error) { if f &lt; 0 { return -1, myError{Num: f} } return math.Sqrt(f), nil } func main() { result, err := Sqrt(-13) if err != nil { fmt.Println(err) } else { fmt.Println(result) } }   ]]></content></entry><entry><title>Go 语言中的带有缓冲 Channel（Let's Go 三十一）</title><url>/article/151/</url><categories><category>golang</category></categories><tags><tag>缓冲信道</tag><tag>channel</tag></tags><content type="html"><![CDATA[  无缓冲信道 Channel 是无法保存任何值的，该类型信道要求 发送 goroutine 和 接受 goroutine 两者同时准备好，这样才能完成发送与接受的操作。
1、无缓冲 Channel前几篇文章我们使用 make 创建出来的信道 Channel，并没有传入第二个参数，也就是说，没有传入第二个参数创建的信道 Channel，便是无缓冲信道咯。
无缓冲信道 Channel 是无法保存任何值的，该类型信道要求 发送 goroutine 和 接受 goroutine 两者同时准备好，这样才能完成发送与接受的操作。
假使 两者 goroutine 未能同时准备好，信道便会先执行 发送 和 接受 的操作， goroutine 会阻塞等待。这种对信道进行发送和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。
阻塞指的是由于某种原因数据没有到达，当前协程（线程）持续处于等待状态，直到条件满足才解除阻塞。
同步指的是在两个或多个协程（线程）之间，保持数据内容一致性的机制。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;math/rand&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) // wg 用来等待程序结束 var wg sync.WaitGroup func init() { rand.Seed(time.Now().UnixNano()) } func main() { // 创建一个无缓冲的通道 court := make(chan int) // 计数加 2，表示要等待两个goroutine wg.Add(2) // 启动两个选手 go player(&amp;#34;Nadal&amp;#34;, court) go player(&amp;#34;Djokovic&amp;#34;, court) // 发球 court &amp;lt;- 1 // 等待游戏结束 wg.Wait() } // player 模拟一个选手在打网球 func player(name string, court chan int) { // 在函数退出时调用Done 来通知main 函数工作已经完成 defer wg.Done() for { // 等待球被击打过来 ball, ok := &amp;lt;-court if !ok …  ]]></content></entry><entry><title>Go 语言中的单向 Channel（Let's Go 三十）</title><url>/article/150/</url><categories><category>golang</category></categories><tags><tag>单向信道</tag><tag>channel</tag></tags><content type="html"><![CDATA[  通过上篇文章，我们知道该怎么声明信道 Channel，以及发送和读取数据。然而本文要讲的是单向Channel，可单向信道Channel到底是怎样的呢？
通过上篇文章，我们知道该怎么声明信道 Channel，以及发送和读取数据。然而本文要讲的是单向Channel，可单向信道Channel到底是怎样的呢？
所谓的单向Channel信道，也就是声明出来的信道Channel，此刻的Channel信道便是只能发送或读取数据。
要声明单向信道Channel，可以使用chan&lt;-来声明一个只能发送数据的信道，其信道变量的类型则为chan&lt;-.
而&lt;-chan声明出来的信道便是只能接受数据，类型则是&lt;-chan。
var onlyReadChan chan&lt;- readChanType // 声明一个只能写入数据的信道 var onlyWriteChan &lt;-chan writeChanType // 声明一个只能读取数据的信道 package main import ( &#34;fmt&#34; ) //定义一个带有 只能发送数据的信道 的参数 函数 func onlySend(ch chan&lt;- string) { ch &lt;- &#34;秋码记录&#34; ch &lt;- &#34;https://qiucode.cn&#34; } //定义一个带有 只能接受数据的信道 的参数 函数 func onlyRead(ch &lt;-chan string) { for { fmt.Println(&lt;-ch) } } func main() { var ch = make(chan string) go onlySend(ch) go onlyRead(ch) }   ]]></content></entry><entry><title>Go 语言中的 Channel（Let's Go 二十九）</title><url>/article/149/</url><categories><category>golang</category></categories><tags><tag>channel</tag><tag>信道</tag></tags><content type="html"><![CDATA[  Channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go 语言对于网络方面也有非常完善的支持。
接上篇，要想在 goroutine 间进行通信，则需通过 Channel 信道传递消息。
Channel 是进程内的通信方式，因此通过 channel 传递对象的过程和调用函数时的参数传递行为比较一致，比如也可以传递指针等。如果需要跨进程通信，我们建议用分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议。Go 语言对于网络方面也有非常完善的支持。
Channel 是类型相关的，也就是说，一个 Channel 只能传递一种类型的值，这个类型需要在声明 Channel 时指定。如果对 Unix 管道有所了解的话，就不难理解 Channel，可以将其认为是一种类型安全的管道。
var chanVar chan chanType // 声明 信道 chanVar 信道变量 chanType 信道类型 chanVar = make(chan chanType) //声明后的 信道 须通过 make() 函数进行创建 信道发送数据使用&amp;lt;-操作符进行发送数据。
chanVar &amp;lt;- value //chanVar 信道变量 value 发送的数据 注意：发送的数据类型要与 信道变量 的类型一致。
信道接收数据信道接受数据同样使用&amp;lt;-操作符。
而接收数据又有四种方式。
1、阻塞模式接收数据
data := &amp;lt;-chanVar 执行该语句时将会阻塞，直到接收到数据并赋值给 data 变量。
2、非阻塞式接收数据 data, ok := &amp;lt;-chanVar data：表示接收到的数据。未接收到数据时，data 为信道类型的零值。
ok：表示是否接收到数据。
非阻塞的信道接收方法可能造成高的 CPU 占用，因此使用非常少。如果需要实现接收超时检测，可以配合 select 和计时器 channel 进行，后续将会讲到。
3、接收任意数据，忽略接收的数据 &amp;lt;-chanVar 阻塞接收数据后，忽略从信道返回的数据。
执行该语句时将会发生阻塞，直到接收到 …  ]]></content></entry><entry><title>Go 语言中的并发编程（Let's Go 二十八）</title><url>/article/148/</url><categories><category>golang</category></categories><tags><tag>并发编程</tag><tag>多线程</tag><tag>多核</tag></tags><content type="html"><![CDATA[  并发与并行并不相同，并发主要由切换时间片来实现“同时”运行，并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。
先了解并发相关的几个名词概念。
进程：系统进行资源分配和调度的基本单位，使系统结构的基础，它是一个实体。
线程：是程序中一个单一的顺序执行流程，是进程内相对独立的、可调度的执行单位。
协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。
并发：多线程程序在单核心的 cpu 上运行。
并行：多线程程序在多核心的 cpu 上运行。
并发与并行并不相同，并发主要由切换时间片来实现“同时”运行，并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。
goroutine 简介goroutine 是一种非常轻量级的实现，可在单个进程里执行成千上万的并发任务，它是Go语言并发设计的核心。
说到底 goroutine 其实就是线程，但是它比线程更小，十几个 goroutine 可能体现在底层就是五六个线程，而且Go语言内部也实现了 goroutine 之间的内存共享。
使用 go 关键字就可以创建 goroutine，将 go 声明放到一个需调用的函数之前，在相同地址空间调用运行这个函数，这样该函数执行时便会作为一个独立的并发线程，这种线程在Go语言中则被称为 goroutine。
package main import ( &#34;fmt&#34; ) func show() { fmt.Println(&#34;https://qiucode.cn&#34;) } func main() { //go 关键字放在方法调用前新建一个 goroutine go show() fmt.Println(&#34;秋码记录&#34;) go show() } 因为 goroutine 在多核 cpu 环境下是并行的，如果代码块在多个 goroutine 中执行，那么我们就实现了代码的并行。
如果需要了解程序的执行情况，怎么拿到并行的结果呢？需要配合使用后续将会讲到的信道channel。
  ]]></content></entry><entry><title>Go 语言中的空接口（Let's Go 二十七）</title><url>/article/147/</url><categories><category>golang</category></categories><tags><tag>空接口</tag><tag>接口转换</tag></tags><content type="html"><![CDATA[  所谓空接口就是没有方法集，以至于任何类型都可实现它，换言之，也就是空接口可以保存任意类型的值。
所谓空接口就是没有方法集，以至于任何类型都可实现它，换言之，也就是空接口可以保存任意类型的值。
package main import ( &#34;fmt&#34; ) func main() { var any interface{} any = 4 fmt.Printf(&#34;any 值为 %d ,类型为 %T \n&#34;, any, any) any = &#34;https://qiucode.cn&#34; fmt.Printf(&#34;any 值为 %d ,类型为 %T \n&#34;, any, any) } 接口与类型之间转换package main import ( &#34;fmt&#34; ) type Flyer interface { Fly() } type Walker interface { Walk() } type Bird struct{} func (b *Bird) Fly() { fmt.Println(&#34;fling....&#34;) } func (b *Bird) Walk() { fmt.Println(&#34;Walking ....&#34;) } type Peple struct{} func (p *Peple) Walk() { fmt.Println(&#34; peple walk ...&#34;) } func main() { animals := map[string]interface{}{ &#34;bird&#34;: new(Bird), &#34;peple&#34;: new(Peple), } // 遍历映射 for name, obj := range animals { f, isFlyer := obj.(Flyer) w, isWalker := obj.(Walker) fmt.Printf(&#34;name: %s isFlyer: %v isWalker: %v\n&#34;, name, isFlyer, isWalker) if isFlyer { f.Fly() } if isWalker { w.Walk() } } }   ]]></content></entry><entry><title>Go 语言中的类型断言（Let's Go 二十六）</title><url>/article/146/</url><categories><category>golang</category></categories><tags><tag>类型断言</tag><tag>空接口</tag></tags><content type="html"><![CDATA[  如果Type是具体某个类型，类型断言会检查 varl的动态类型是否等于具体类型 Type。如果检查成功，类型断言返回的结果是 varl 的动态值，其类型是 Type。 - 如果 Type 是接口类型，类型断言会检查 varl 的动态类型是否满足
Go中使用interface {}空接口来表示可以是任意类型，以至于这样，需要检测该变量类型，那便要类型断言。
val,ok := varl.(Type) val 必须是一个借口类型的变量，否则编译报错。
Type 是一个具体的类型。
该断言表达式返回一个val和一个布尔类型ok，根据ok判断varl是否属于Type类型。
如果Type是具体某个类型，类型断言会检查 varl的动态类型是否等于具体类型 Type。如果检查成功，类型断言返回的结果是 varl 的动态值，其类型是 Type。 如果 Type 是接口类型，类型断言会检查 varl 的动态类型是否满足 Type。如果检查成功，varl 的动态值不会被提取，返回值是一个类型为 Type 的接口值。 无论 Type 是什么类型，如果 varl 是 nil 接口值，类型断言都会失败。 package main import ( &#34;fmt&#34; ) func main() { //定义一个任意类型的变量 var site interface{} site = &#34;https://qiucode.cn&#34; web, ok := site.(string) fmt.Println(web, ok) } 类型断言可配合switch进行使用。
package main import ( &#34;fmt&#34; ) func getType(t interface{}) { switch t.(type) { case string: fmt.Println(&#34;该类型为 string &#34;) case int: fmt.Println(&#34;该类型是 int &#34;) case float64: fmt.Println(&#34;该类型为 float64 &#34;) default: fmt.Println(&#34;暂没有匹配的类型&#34;) } } func main() { //定义一个任意类型的变量 var site interface{} site = &#34;https://qiucode.cn&#34; getType(site) }   ]]></content></entry><entry><title>Go 语言中的接口（Let's Go 二十五）</title><url>/article/145/</url><categories><category>golang</category></categories><tags><tag>接口</tag><tag>方法集</tag></tags><content type="html"><![CDATA[  要想实现Go中的接口，类型实现接口方法集的方法，其类型实现的方法签名必须要与接口中的方法集中方法签名一样。 类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。
1、接口声明当然咯，Go中的接口是不能定义成员属性，只能有方法集（只有方法声明，没有方法实现体）。
type interfaceName interface { funcName(para paraType [,para2 paraType]) (returnType [,returnType]) ... } package main import ( &#34;fmt&#34; ) type article struct { artId int title string content string } type article interface { ShowArt() []article detilArt(artId int) article } func main() { } 2、实现接口要想实现Go中的接口，类型实现接口方法集的方法，其类型实现的方法签名必须要与接口中的方法集中方法签名一样。
类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。
实现某个接口的类型（除了实现接口方法外）可以有其他的方法。
一个类型可以实现多个接口。
接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。
package main import ( &#34;fmt&#34; ) //定义一个 数学几何 接口 type shape interface { //用于计算 面积 calArea() float64 } type square struct { width float64 } //通过 接受者 绑定 实现接口中的方法集 func (sq *square) calArea() float64 { return sq.width * sq.width } func main() { //实例化 square 结构类型 sq := new(square) sq.width = 5 //声明 shape 接口 var sh shape sh = sq area := sh.calArea() fmt.Printf(&#34;边长为 %d 的面积是：%.2f \n&#34;, sq.width, area) }   ]]></content></entry><entry><title>Go 语言中的方法（Let's Go 二十四）</title><url>/article/144/</url><categories><category>golang</category></categories><tags><tag>方法</tag><tag>接受者</tag></tags><content type="html"><![CDATA[  Go中的方法是一种特殊的函数，以实现类型与函数进行绑定
1、方法定义Go 中的方法是一种特殊的函数，通过接受者将函数绑定在一起，这样便可以模拟面向对象那样。
func (a constru) funName(para paraType,[para2 paraType]) (returnType,[returnType2]) { } 要将函数与某个类型绑定在一起，只需在函数名称前加需要绑定的类型。
package main import ( &#34;fmt&#34; ) type site struct { name string age int } func (s *site) show() string { s.name = &#34;https://qiucode.cn&#34; return s.name } func main() { web := site{} str := web.show() fmt.Println(stra) } 2、基本类型绑定函数package main import ( &#34;fmt&#34; ) type intArray []int //定义一个新类型 func (arr *intArray) sum() (sum int) { for _, num := range *arr { sum += num } return } func main() { num := intArray{3, 4, 5} total := num.sum() fmt.Println(total) }   ]]></content></entry><entry><title>原创 Go 语言中的结构体（Let's Go 二十三）</title><url>/article/143/</url><categories><category>golang</category></categories><tags><tag>结构体</tag><tag>struct</tag></tags><content type="html"><![CDATA[  Go中的结构体与c/c++语言中是差不多，然而对没有接触过c/c++语言的话，对在看到结构体这一复合类型是新鲜事物。
1、定义结构体type structName struct { varName,varName2,varName3 Type } // 使用 type struct 关键字定义结构体， 2、结构体实例化既然结构体是一个复合类型，那就可以像基本类型等其他类型一样。
package main import ( &#34;fmt&#34; ) type color struct { white, black, red rune } var c color func main() { c.white = &#39;白&#39; c.black = &#39;黑&#39; c.red = &#39;红&#39; fmt.Println(c) } 3、创建指针类型的结构体var varName = new(Type) //Type可以是整型、字符串、结构体等其他类型，而 varName则是 *Type 指针类型 package main import ( &#34;fmt&#34; ) type site struct { name string age int } var web = new(site) func main() { web.name = &#34;https://qiucode.cn&#34; web.age = 4 fmt.Println(web) (*web).name = &#34;https://qiucode.cn&#34; (*web).age = 4 fmt.Println(web) } 4、获取结构体地址在Go中使用&amp;获取结构体地址。
var varName = &amp;Construct{}   ]]></content></entry><entry><title>Go 语言中的延迟执行【defer】（Let's Go 二十二）</title><url>/article/142/</url><categories><category>golang</category></categories><tags><tag>回调函数</tag><tag>延迟执行</tag></tags><content type="html"><![CDATA[  函数作为另一个函数的形参，这就是Go当中的回调函数。
1、延迟执行package main import ( &#34;fmt&#34; ) func main() { //最后执行a defer fmt.Println(&#34;https://qiucode.cn&#34;) fmt.Println(&#34;秋码记录&#34;) defer fmt.Println(&#34;qiucode.cn&#34;) } 2、将函数作为其他函数的参数函数可以作为其它函数的参数进行传递，然后在其它函数内调用执行，一般称之为回调。
package main import ( &#34;fmt&#34; ) func main() { callFun(3, add) } func add(num1, num2 int) { fmt.Println(&#34;两个数相加：&#34;, num1+num2) } func callFun(num int, callBack func(int, int)) { callBack(num, 5) }   ]]></content></entry><entry><title>Go 语言中的闭包和可变参数（Let's Go 二十一）</title><url>/article/141/</url><categories><category>golang</category></categories><tags><tag>可变参数</tag><tag>闭包</tag><tag>语法题</tag></tags><content type="html"><![CDATA[  在前面几篇文章，我们一直在使用Println、Printf函数，你可能没有特别注意到，就是我们可以传入任意参数。而这种可以接受任意实参的函数，函数的形参极有可能是可变参数，使用...type可声明可变参数，但必须是形参列表的最后
1、可变参数在前面几篇文章，我们一直在使用Println、Printf函数，你可能没有特别注意到，就是我们可以传入任意参数。而这种可以接受任意实参的函数，函数的形参极有可能是可变参数，使用...type可声明可变参数，但必须是形参列表的最后一个。
package main import ( &#34;fmt&#34; ) func site(strs ...string) { for _, val := range strs { fmt.Println(val) } } func main() { site(&#34;秋码记录&#34;, &#34;https://qiucode.cn&#34;, &#34;仗剑行于江湖，执笔记江湖事。&#34;) } 说到底，可变参数...type·内部就是切片 []type,若将上述可变形参改用```切片````，其最终效果是一样的，这只是一种语法糖。
func site(strs []string) { for _, val := range strs { fmt.Println(val) } } 细心的你可能早就发觉了，难道不是吗？以上...type是可以传入任意数量的参数，但是很明显，传入的参数收到了约束。
如果想传入任意类型的可变参数，那又该怎么解决呢？
其实，可以指定类型为后续会讲到的空接口 interfave {}，即可传入任意类型。
package main import ( &#34;fmt&#34; ) func pramType(args ...interface{}) { for _, val := range args { switch val.(type) { case int: fmt.Println(val, &#34; 哟呵，传入的是 整型 啊！&#34;) case string: fmt.Println(val, &#34; 这可是 字符串 哟！&#34;) default: fmt.Println(val, &#34; 暂且归为其他吧！&#34;) } } } func main() { pramType(&#34;https://qiucode.cn&#34;, 4, 3.14) } 2、闭包package main import ( &#34;fmt&#34; ) func getVal() func() int { var value int //定义一个 整型 局部变量 value //返回一个闭包 return func() int { value++ return value } } func main() { val := getVal() fmt.Println(val()) }   ]]></content></entry><entry><title>Go 语言中的函数变量与匿名函数（Let's Go 二十）</title><url>/article/140/</url><categories><category>golang</category></categories><tags><tag>匿名函数</tag><tag>函数变量</tag><tag>回调函数</tag></tags><content type="html"><![CDATA[  一上来乍一看，函数变量？这究竟是什么意思呢？你函数就函数，变量便是变量，这两者搞在一块，到底是几个意思呢？ 其实啊，在Go当中，函数也是一种类型，既然是类型，那就可以向其它类型一样，给变量定义类型啊！而这个类型是函数，所以函数类型
1、函数变量一上来乍一看，函数变量？这究竟是什么意思呢？你函数就函数，变量便是变量，这两者搞在一块，到底是几个意思呢？
其实啊，在Go当中，函数也是一种类型，既然是类型，那就可以向其它类型一样，给变量定义类型啊！而这个类型是函数，所以函数类型定义出来的变量可不就是函数变量吗！
package main import ( &#34;fmt&#34; ) func site() { fmt.Println(&#34;秋码记录：https://qiucode.cn&#34;) } func main() { //声明一个函数变量 qiucode var qiucode func() //将自定义 site 函数赋值给 函数变量 qiucode qiucode = site //调用 qiucode() 就相当于调用了 site() qiucode() } 2、匿名函数说到匿名函数，想必有过Java、PHP以及Python等面向对象编程语言的经验，对匿名函数并不陌生吧！而在Go也是有匿名函数的哦，在前面我们谈到了匿名变量(_)。
package main import ( &#34;fmt&#34; ) func main() { //声明一个匿名函数并自调用 func(name string) { fmt.Println(&#34;秋码记录：&#34;, name) }(&#34;https://qiucode.cn&#34;) //声明一个匿名函数 并赋值给一个变量 note := func(desc string) { fmt.Println(desc) } //通过进行匿名函数的调用 note(&#34;仗剑行于江湖，执笔记江湖事&#34;) } package main import ( &#34;fmt&#34; ) func webSite(list []string, callBack func(string)) { for _, val := range list { callBack(val) } } func main() { webSite([]string{&#34;秋码记录&#34;, &#34;https://qiucode.cn&#34;, &#34;仗剑行于江湖，执笔记江湖事&#34;}, func(str string) { fmt.Println(st 其实，匿名函数还可以对某些操作进行封装。
package main import ( &#34;flag&#34; &#34;fmt&#34; ) //从命令行输入值 --qiucode=输入的值 var qiucodeParam = flag.String(&#34;qiucode&#34;, &#34;&#34;, &#34;qiucode to perform&#34;) func main() { //解析完成，将指针变量 qiucodeParam 指向命令行输入的值 flag.Parse() //定义一个 map 键是 string 类型 值是 func var qiucode = map[string]func(){ &#34;qiuma&#34;: func() { fmt.Println(&#34;秋码记录&#34;) }, &#34;qiucode&#34;: func() { fmt.Println(&#34;https://qiucode.cn&#34;) }, &#34;world&#34;: func() { fmt.Println(&#34;有人的地方，就是江湖！&#34;) }, } //指针变量指向命令行传入的值 在 map 查找命令行输入的字符串 是否存在在该 map 中 //如果存在 就回调该 键 所对应的值 也就是 函数 if fun, flag := qiucode[*qiucodeParam]; flag { fun() } else { fmt.Println(&#34;qiucode not found&#34;) } }   ]]></content></entry><entry><title>Go 语言中的函数详解（Let's Go 十九）</title><url>/article/139/</url><categories><category>golang</category></categories><tags><tag>函数</tag><tag>多值返回</tag></tags><content type="html"><![CDATA[  在前面几篇文章，接触到的最多的是main函数。Go 如同c/c++语言一样，对于声明函数也有属于自己的一套规则。
在前面几篇文章，接触到的最多的是main函数。Go 如同c/c++语言一样，对于声明函数也有属于自己的一套规则。
func functionName(param paramType,[param1 param1Type,...])(returnVal valType,[rerutnVal1 return1Type,...]) { } 在Go当中定义函数使用关键字func，后跟方法名（functionName），参数列表（param paramType）以及函数返回值，且函数返回可以返回多个值。
package main import ( &#34;fmt&#34; ) func fib(n int) int { if n == 0 { return 0 } if n == 1 { return 1 } return fib(n-1) + fib(n-2) } func main() { num := fib(10) fmt.Printf(&#34;10的斐波那契值： %d \n&#34;, num) } 若一组形参或返回值有相同的类型，其实是不需要为每个参数都带上类型的，只需在这组相同类型的形参或返回值最后一个形参或返回值带上类型即可，这段话看起来似乎有点绕，其实意思就是下面这般。
func myFunc(a,b,c int) (d,e,f int){ ... } func myFunc(a int,b int,c int) (d int,e int,f int){ ... } func myFunc(a,b,c int) (int,int,int){ ... } 以上三种写法是等同的，返回值如果定义了返回参数，在函数体最后一行需要加上return。
package main import ( &#34;fmt&#34; ) func cacul(num1, num2 int) (sum, diff int) { sum = num1 + num2 diff = num1 - num2 return } func cacul2(num1 int, num2 int) (sum int, diff int) { sum = num1 + num2 diff = num1 - num2 return } func cacul3(num1, num2 int) (int, int) { sum := num1 + num2 diff := num1 - num2 return sum, diff } func main() { sum, diff := cacul(15, 10) fmt.Printf(&#34;调用第一个函数，sum = %d，diff= %d\n&#34;, sum, diff) sum2, diff2 := cacul2(25, 30) fmt.Printf(&#34;调用第二个函数，sum2 = %d，diff2 = %d\n&#34;, sum2, diff2) sum3, diff3 := cacul3(35, 40) fmt.Printf(&#34;调用第三个函数，sum3 = %d，diff3 = %d\n&#34;, sum3, diff3) }   ]]></content></entry><entry><title>Go 语言中的 goto、break 以及 continue 语句（Let's Go 十八）</title><url>/article/138/</url><categories><category>golang</category></categories><tags><tag>goto</tag><tag>break</tag><tag>continue</tag></tags><content type="html"><![CDATA[  在提到关键字goto，想必很多人都心有余悸吧，毕竟goto可是编程语言界破坏代码可读性的罪魁祸首啊！以至于像c/c++或类 c 的编程语言，都将goto作为保留关键字，不建议使用，但如果你非要使用，谁人可阻止呢？
1、退出多层循环（使用 goto）在提到关键字goto，想必很多人都心有余悸吧，毕竟goto可是编程语言界破坏代码可读性的罪魁祸首啊！以至于像c/c++或类 c 的编程语言，都将goto作为保留关键字，不建议使用，但如果你非要使用，谁人可阻止呢？
然而在go编程世界里，你大可放心的去用，不必担心代码的可读性之类的。
package main import ( &#34;fmt&#34; ) func main() { var num int = 0 //作为记录值 for i := 0; i &lt; 10; i++ { for j := 0; j &lt; 10; j++ { a if j == 2 { num = j goto outLoop } } } //避免执行 outLoop 标签内 代码a return outLoop: fmt.Printf(&#34;跳转到了循环外边，这是 num 的值是：%d\n&#34;, num) } 2、使用 break 跳出循环Go当中break可以结束for、switch以及后续将会提到的select语句，break也和goto一样，可以跟上标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的for、switch 和 select 的代码块上。
package main import ( &#34;fmt&#34; ) func main() { outLoop: for i := 0; i &lt; 10; i++ { for j := 0; j &lt; 10; j++ { if j == 3 { fmt.Println(i, j) break outLoop } } } } 3、继续下一次循环（continue）package main import ( &#34;fmt&#34; ) func main() { outLoop: for i := 0; i &lt; 10; i++ { for j := 0; j &lt; 10; j++ { if j == 3 { fmt.Println(i, j) continue outLoop } } } } 代码说明：第 16 行将结束当前循环，开启下一次的外层循环，而不是第 12 行的循环。
  ]]></content></entry><entry><title>Go 语言中的 switch 结构（Let's Go 十七）</title><url>/article/137/</url><categories><category>golang</category></categories><tags><tag>switch</tag><tag>跨越switch</tag></tags><content type="html"><![CDATA[  相较于c/c++等的switch case，Go对switch做了很大改进，case与case之间是不需要写上break，也能跳出当前case语句，而且，switch表达式可以是任何类型的噢！
相较于c/c++等的switch case，Go对switch做了很大改进，case与case之间是不需要写上break，也能跳出当前case语句，而且，switch表达式可以是任何类型的噢！
switch condition { case one: //do something xase two: //TODO default: //do something } package main import ( &#34;fmt&#34; ) func main() { var name = &#34;qiucode&#34; switch name { case &#34;qiucode&#34;: fmt.Println(&#34;欢迎浏览 https://qiucode.cn&#34;) case &#34;qiuma&#34;: fmt.Println(&#34;秋码记录&#34;) default: fmt.Println(&#34;qiucode.cn 秋码记录&#34;) } } package main import ( &#34;fmt&#34; ) func main() { var num int = 17 switch { case num &gt; 10 &amp;&amp; num &lt; 20: fmt.Println(&#34;这个数值确实大于十小于二十！&#34;) } } 当switch不提供任何被判断值时，其实际上默认为判断是否是true，而后在每个case分支中进行判断不同的表达式，直至任何一个结果为true时，该分支的代码才会被执行。
若想跨越case，兼容c语言的话，可以使用fallthrough这个关键字。
package main import ( &#34;fmt&#34; ) func main() { var name = &#34;qiucode&#34; switch name { case &#34;qiucode&#34;: fmt.Println(&#34;欢迎浏览 https://qiucode.cn&#34;) fallthrough case &#34;qiuma&#34;: fmt.Println(&#34;秋码记录&#34;) default: fmt.Println(&#34;qiucode.cn 秋码记录&#34;) } }   ]]></content></entry><entry><title>Go 语言中的 for 循环结构（Let's Go 十六）</title><url>/article/136/</url><categories><category>golang</category></categories><tags><tag>循环结构</tag><tag>while</tag></tags><content type="html"><![CDATA[  Go当中只有for循环结构，可没有像c/c++语言有while、do ... while的。for循环结构与if分支结构一样，可以省略()，左大括号{必须与for在同一行。
Go当中只有for循环结构，可没有像c/c++语言有while、do ... while的。for循环结构与if分支结构一样，可以省略()，左大括号{必须与for在同一行。
package main import ( &#34;fmt&#34; ) func main() { num := 0 for i := 0; i &lt; 10; i++ { num += i } fmt.Println(&#34;num 最终和为：&#34;, num) } 若想实现与while、do ... while一样的效果，便去掉条件表达式，直接写个for { ....}或者for ； ； { ...}。
package main import ( &#34;fmt&#34; ) func main() { sum := 0 for { sum++ if sum &gt; 30 { break } } fmt.Println(&#34;num 最终和为：&#34;, sum) } 其实，在Go还提供了一个关键字range来遍历数组、切片、字符串、map以及后续的通道（channel）。
package main import ( &#34;fmt&#34; ) func main() { slice := []string{&#34;秋码记录&#34;, &#34;https://qiucode.cn&#34;, &#34;仗剑行于江湖，执笔记江湖事！&#34;} // 迭代每个元素，并显示值和地址 for index, value := range slice { fmt.Printf(&#34;索引：%d 值是：%s\n&#34;, index, value) } }   ]]></content></entry><entry><title>Go 语言中的 if 分支结构（Let's Go 十五）</title><url>/article/135/</url><categories><category>golang</category></categories><tags><tag>golang</tag><tag>区块链</tag><tag>package</tag><tag>包</tag></tags><content type="html"><![CDATA[  Go当中的if分支与c/c++大致相同，只是可以省略条件表达式的小括号()，真的是，```G哦·``就是要特立独行。
if condition { //注意 左 { 不能换行 必须与 if 表达式在同一行 否则编译报错 // TODO } else { //注意： else 也不能换行 必须与 if 的 右 } 在同一行 否则编译也会报错 //TODO } package main import ( &#34;fmt&#34; &#34;time&#34; ) func main() { hour := time.Now().Hour() if hour &gt; 18 { fmt.Println(&#34;月亮都挂在天上好久了，难不成你还在回家的路上！&#34;) } else { fmt.Println(&#34;太阳才刚下山呢！&#34;) } } 当然咯，Go还提供一种简短的写法
package main import ( &#34;fmt&#34; &#34;time&#34; ) func main() { if hour := time.Now().Hour(); hour &gt; 18 &amp;&amp; hour &lt;= 21 { fmt.Println(&#34;月亮都挂在天上好久了，难不成你还在回家的路上！&#34;) } else if hour &gt; 21 { fmt.Println(&#34;生活不易，都在负重前行！&#34;) } else { fmt.Println(&#34;太阳才刚下山呢！&#34;) } }   ]]></content></entry><entry><title>Go 语言中的列表（Let's Go 十四）</title><url>/article/134/</url><categories><category>golang</category></categories><tags><tag>列表</tag><tag>双向链表</tag><tag>List</tag></tags><content type="html"><![CDATA[  列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。
1、声明列表列表是一种非连续的存储容器，由多个节点组成，节点通过一些变量记录彼此之间的关系，列表有多种实现方法，如单链表、双链表等。
var name = list.New() //或 var name = list.List package main import ( &#34;container/list&#34; &#34;fmt&#34; ) func main() { var siteList = list.New() siteList.PushBack(&#34;https://qiucode.cn&#34;) for i := siteList.Front(); i != nil; i = i.Next() { fmt.Println(i.Value) } } 2、列表删除元素列表插入函数的返回值会提供一个 *list.Element 结构，这个结构记录着列表元素的值以及与其他节点之间的关系等信息，从列表中删除元素时，需要用到这个结构进行快速删除。
package main import ( &#34;container/list&#34; &#34;fmt&#34; ) func main() { var siteList = list.New() siteList.PushBack(&#34;https://qiucode.cn&#34;) // 头部添加 siteList.PushFront(&#34;秋码记录&#34;) // 尾部添加后保存元素句柄 element := siteList.PushBack(&#34;仗剑行于江湖&#34;) // 在fist之后添加h siteList.InsertAfter(&#34;执笔记江湖事&#34;, element) // 在fist之前添加 siteList.InsertBefore(&#34;游离于山间&#34;, element) // 使用 siteList.Remove(element) for i := siteList.Front(); i != nil; i = i.Next() { fmt.Println(i.Value) } }   ]]></content></entry><entry><title>Go 语言中的字典【map】（Let's Go 十三）</title><url>/article/133/</url><categories><category>golang</category></categories><tags><tag>字典</tag><tag>dict</tag></tags><content type="html"><![CDATA[  其实，map是一对key（键）与value（值）对应的无序集合，又称为关联数组或字典。
1、声明 map首先，要知道什么是map？
其实，map是一对key（键）与value（值）对应的无序集合，又称为关联数组或字典。
var name map[keyType]valueType //name: map的变量名 //keyType： map中键（key）的类型 //valueType: map中的值（value)的类型 package main import &#34;fmt&#34; func main() { var sitemMap map[string]string sitemMap = map[string]string{&#34;site&#34;: &#34;https://qiucode.cn&#34;, &#34;siteName&#34;: &#34;秋码记录&#34;} fmt.Printf(&#34;sitemMap 键名 \&#34;site\&#34; 值是: %s\n&#34;, sitemMap[&#34;site&#34;]) } 2、使用 make() 函数构造make(map[keyType]valueType, cap) //第一个参数就是构造的map，键（key）值（value）对的类型 //第二个参数是构造出多大的map，也就是容量 package main import &#34;fmt&#34; func main() { sitemMap := make(map[string]string, 2) sitemMap = map[string]string{&#34;site&#34;: &#34;https://qiucode.cn&#34;, &#34;siteName&#34;: &#34;秋码记录&#34;} fmt.Printf(&#34;sitemMap 键名 \&#34;site\&#34; 值是: %s\n&#34;, sitemMap[&#34;site&#34;]) } 3、使用 delete() 函数删除键值对使用delete()函数根据某个键(Key)删除对应的键值对，其函数声明如下：
delete(map,key) //第一个参数是要哪个map进行操作的对象 //第二个参数是操作这个map的哪一个键（key） package main import &#34;fmt&#34; func main() { sitemMap := make(map[string]string) // 准备map数据 sitemMap[&#34;site&#34;] = &#34;https://qiucode.cn&#34; sitemMap[&#34;siteName&#34;] = &#34;秋码记录&#34; sitemMap[&#34;desc&#34;] = &#34;仗剑行于江湖，执笔记江湖事。&#34; delete(sitemMap, &#34;siteName&#34;) for k, v := range sitemMap { fmt.Println(k, v) } } 4、清空所有元素很可惜，Go并没有关于清空元素、清空所有元素的函数。然而确实需要清空map当中所有元素怎么办呢？唯一的办法就是重新用make()函数生成新的map。
  ]]></content></entry><entry><title>Go 语言中的数组（Let's Go 十二）</title><url>/article/132/</url><categories><category>golang</category></categories><tags><tag>切片</tag><tag>slice</tag></tags><content type="html"><![CDATA[  其实啊，切片就好像一个完整的蛋糕，你用刀切了一小块，而这一块就是从那完整的蛋糕切了下来。
1、生成切片首先，需要了解的是，到底什么是切片呢？
其实啊，切片就好像一个完整的蛋糕，你用刀切了一小块，而这一块就是从那完整的蛋糕切了下来。
切片是对数组的某一个连续片段的引用，当然咯，这个片段也可以是整个数组。
slice [start : end] //slice: 目标切片对象 //start： 目标切片对象的开始索引 //end： 目标切片对象的结束索引 需要注意的是，切片内不包括结束索引所指向的项。
package main import &#34;fmt&#34; func main() { siteConf := [...]string{&#34;秋码记录&#34;, &#34;https://qiucode.cn&#34;, &#34;秋码淘好货&#34;} fmt.Println(siteConf, siteConf[1:2]) } 1.1、指定范围生成切片package main import &#34;fmt&#34; func main() { var arr [30]int for i := 0; i &lt; 30; i++ { arr[i] = i + 1 } // 区间 fmt.Println(arr[10:15]) // 中间到尾部的所有元素 fmt.Println(arr[20:]) // 开头到中间指定位置的所有元素 fmt.Println(arr[:2]) } 1.2、原切片当开始索引和结束索引都被忽略时，生成的切片与没有生成的对象一致。
package main import &#34;fmt&#34; func main() { a := []int{1, 2, 3} fmt.Println(a, a[:]) } 1.3、空切片若将开始索引与结束索引都设为0的话，那么将会生成空切片。
package main import &#34;fmt&#34; func main() { a := []int{1, 2, 3} fmt.Println(a, a[0:0]) } 2、声明切片除了可以从数组或切片中生成切片外，还可以声明一个新的切片，其声明与数组声明方式很相似。
var name []Type //name：切片的变量名称 //Type: 切片的元素类型 代码说明如下：
第 8 行，声明一个字符串切片，切片中拥有多个字符串。 第 10 行，声明一个整型切片，切片中拥有多个整型数值。 第 12 行，将 numListEmpty 声明为一个整型切片，本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。 第 14 行，切片均没有任何元素，3 个切片输出元素内容均为空。 第 16 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。 第 18 行和第 19 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。 第 20 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。 切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 append() 函数向切片中添加元素。
3、make() 函数构造切片make([]Type, size, cap) 其中Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。
package main import &#34;fmt&#34; func main() { a := make([]int, 3) b := make([]int, 3, 15) fmt.Println(a, b) fmt.Println(len(a), len(b)) }   ]]></content></entry><entry><title>Go 语言中的数组（Let's Go 十一）</title><url>/article/131/</url><categories><category>golang</category></categories><tags><tag>array</tag><tag>数组</tag><tag>多维数组</tag></tags><content type="html"><![CDATA[  与c/c++语言一样，数组的每个元素可以通过索引下标进行访问，索引下标是从0开始到数组长度减去1的位置。内置函数 len()可以返回数组中元素的个数。
1、数组的声明var arrName [num]Type //arrName：数组变量名 num：数组元素个数 Type：数组类型 与c/c++语言一样，数组的每个元素可以通过索引下标进行访问，索引下标是从0开始到数组长度减去1的位置。内置函数 len()可以返回数组中元素的个数。
package main import &amp;#34;fmt&amp;#34; func main() { var arr [3]int // 定义三个整数的数组 fmt.Println(arr[0]) // 打印第一个元素 fmt.Println(arr[len(arr)-1]) // 打印最后一个元素 // 打印索引和元素 for index, value := range arr { fmt.Printf(&amp;#34;%d %d\n&amp;#34;, index, value) } // 仅打印元素 for _, value := range arr { fmt.Printf(&amp;#34;%d\n&amp;#34;, value) } } 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组。
package main import &amp;#34;fmt&amp;#34; func main() { var siteConf [3]string = [3]string{&amp;#34;秋码记录&amp;#34;, &amp;#34;https://qiucode.cn&amp;#34;, &amp;#34;一个游离于山间之上的&amp;#34;} var weChat [3]string = [3]string{&amp;#34;你我杂志刊&amp;#34;, &amp;#34;秋码淘好货&amp;#34;} fmt.Println(siteConf[1], weChat[2]) } 由于weChat数组没有设置第三个元素，所以就是用了该类型的默认值进行初始化，由于string类型的默认值为&amp;quot;&amp;quot;。
其实，数组的长度可以根据初始化值的个数进行推算出来的，在上面siteConf数组在定义数组长度时可用...来代替。
package main …  ]]></content></entry><entry><title>Go 语言中的类型定义与类型别名（Let's Go 十）</title><url>/article/130/</url><categories><category>golang</category></categories><tags><tag>类型别名</tag><tag>type alias</tag></tags><content type="html"><![CDATA[  类型别名顾名思义就是给类型起个别名。就像上学时候，同学间开玩笑，给人以某种特征起了个外号，又或是英语老师给你起个英文名字，不管是外号、小名还是英文名字，最终都是指向你。
1、类型别名类型别名是Go 1.9版本出现的新功能，为的是代码升级、迁移中存在的类型兼容问题。Go不像c/c++语言那般，代码重构可以使用宏。Go当中是没有宏的概念。
type TypeAlias = Type 类型别名规定：TypeAlias 只是 Type 的别名，本质上 TypeAlias 与 Type 是同一个类型。
2、类型定义其实，类型定义与类型别名很相似，两者只差一个等号，怎一个等号了得。
type TypeDef Type 注意：类型定义是没有等号的，来看一个实例，或许你会有所了解。
package main import &#34;fmt&#34; // 将NewString定义为string类型 type NewString string // 将string取一个别名叫StringAlias type StringAlias = string func main() { // 将webSite声明为NewString类型 var webSite NewString = &#34;https://qiucode.cn&#34; // 查看 webSite 的类型名 fmt.Printf(&#34;webSite 类型: %T\n&#34;, webSite) // 将 siteName 声明为 StringAlias 类型 var siteName StringAlias = &#34;秋码记录&#34; // 查看 siteName 的类型 fmt.Printf(&#34;siteName 类型: %T\n&#34;, siteName) } 代码说明如下：
第 6 行，将 NewString 定义为 string 类型，这是常见的定义类型的方法，通过 type 关键字的定义，NewString 会形成一种新的类型，NewString 本身依然具备 string 类型的特性。 第 9 行，将 StringAlias 设置为 string· 的一个别名，使用 StringAlias 与 string 等效。 第 13 行，将变量webSite 声明为 NewString 类型。 第 15 行，使用 %T格式化参数，打印变量 webSite 本身的类型。 第 17 行，将变量siteName 声明为 StringAlias 类型。 第 19 行，打印变量siteName的类型。 运行结果显示变量 webSite 的类型是 main.NewString，表示 main 包下定义的 NewString 类型，变量 siteName 类型是 string，StringAlias 类型只会在代码中存在，编译完成时，不会有 StringAlias 类型。
  ]]></content></entry><entry><title>Go 语言中的指针（Let's Go 九）</title><url>/article/129/</url><categories><category>golang</category></categories><tags><tag>指针</tag><tag>内存地址</tag><tag>pointer</tag></tags><content type="html"><![CDATA[  *操作符作为右值时，意义是取指针的值，作为左值时，也就是放在赋值操作符的左边时，表示 a 指针指向的变量。其实归纳起来，*操作符的根本意义就是操作指针指向的变量。当操作在右值时，就是取指向变量的值，当操作
说到指针，想必很多人会谈虎色变吧，在c/c++语言中那晦涩难懂的指针，曾几何时，让人望而却步！
虽说，指针操作效率是相当的快，可一旦把握不好，就会造成可怕的错误。
与c/c++语言不同的是，在Go中是不允许进行指针运算的。
1、声明指针类型 *T 是指向 T 类型值的指针。其默认值为 nil。
var name *type var p *int 其实，每个变量在运行时，在内存都有属于自己的内存地址，而这个地址就是代表着变量在内存的位置。
与c/c++语言一样，要想获取变量在内存的地址，只需在变量前面加个&amp;amp;即可。
func main() { v := &amp;#34;https://qiucode.cn&amp;#34; ptr := &amp;amp;v } 其中，&amp;amp;v表示取变量v的内存地址，而变量 v 的内存地址又赋值给变量ptr，此时变量ptr类型为*string,称作string的指针类型，*代表指针。
package main import &amp;#34;fmt&amp;#34; func main() { var age int = 4 v := &amp;#34;https://qiucode.cn&amp;#34; ptr := &amp;amp;v fmt.Printf(&amp;#34;%p %p&amp;#34;, &amp;amp;age, ptr) } 指针的值是带有0x十六进制前缀的一组数据。 2、获取指针指向的值当我们使用&amp;amp;操作符对普通变量取地址，在得到变量的指针后，接着使用*操作符对普通变量进行取值，也就是指针取值。
package main import &amp;#34;fmt&amp;#34; func main() { // 准备一个字符串类型 var webSite = &amp;#34;https://qiucode.cn&amp;#34; // 对字符串取地址, ptr类型为*string ptr := &amp;amp;webSite // 打印ptr的类型 fmt.Printf(&amp;#34;ptr 的类型: %T\n&amp;#34;, ptr) // 打印ptr的指针地址 fmt.Printf(&amp;#34;ptr 指针 …  ]]></content></entry><entry><title>Go 语言中的关键字与标识符（Let's Go 八）</title><url>/article/128/</url><categories><category>golang</category></categories><tags><tag>标识符</tag><tag>预定义标识符</tag><tag>关键字</tag></tags><content type="html"> 标识符是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线 _ 、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。
1、关键字
Go作为一门编程语言，也同样的保留了些关键字，其实前面几篇文章也或多或少的出现些Go中的关键字，如定义变量的var、声明常量的const、包名的package、导入其他包的import以及声明函数的func等这些都是Go保留的关键字。
Go语言中的关键字一共有 25 个：
break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 和其它语言一样，关键字不能够作标识符使用。
2、标识符
标识符是指Go语言对各种变量、方法、函数等命名时使用的字符序列，标识符由若干个字母、下划线 _ 、和数字组成，且第一个字符必须是字母。通俗的讲就是凡可以自己定义的名称都可以叫做标识符。
下划线 _是一个特殊的标识符，称为空白标识符，它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用_作为变量对其它变量进行赋值或运算。
在使用标识符之前必须进行声明，声明一个标识符就是将这个标识符与常量、类型、变量、函数或者代码包绑定在一起。在同一个代码块内标识符的名称不能重复。
标识符的命名需要遵守以下规则：
由 26 个英文字母、0~9、_组成； 不能以数字开头，例如 var 1num int 是错误的； Go语言中严格区分大小写； 标识符不能包含空格； 不能以系统保留关键字作为标识符，比如 break，if 等等。 命名标识符时还需要注意以下几点：
标识符的命名要尽量采取简短且有意义； 不能和标准库中的包名重复； 为变量、函数、常量命名时采用驼峰命名法，例如 stuName、getVal； 当然Go语言中的变量、函数、常量名称的首字母也可以大写，如果首字母大写，则表示它可以被其它的包访问（类似于Java 中的 public）；如果首字母小写，则表示它只能在本包中使用 (类似于 Java 中 private）。
在Go语言中还存在着一些特殊的标识符，叫做预定义标识符，预定义标识符一共有 36 个，主要包含Go语言中的基础数据类型和内置函数，这些预定义标识符也不可以当做标识符来使用。
append bool byte cap close complex complex64 complex128 uint16 copy false float32 float64 imag int int8 int16 uint32 int32 int64 iota len make new nil panic uint64 print println real recover string true uint uint8 uintptr</content></entry><entry><title>Go 语言中的常量定义（Let's Go 七）</title><url>/article/127/</url><categories><category>golang</category></categories><tags><tag>枚举类型</tag><tag>常量</tag></tags><content type="html"><![CDATA[  Go中定义常量与C语言一样，也是使用const关键字来定义常量的。常量声明语法：const name [typeName] = value，其中typeName（类型）可省略！ 常量可以是字符、字符串、布尔值或数值。 常量不能用 := 语法声明。
1、常量定义Go中定义常量与C语言一样，也是使用const关键字来定义常量的。常量声明语法：const name [typeName] = value，其中typeName（类型）可省略！
常量可以是字符、字符串、布尔值或数值。 常量不能用 := 语法声明。
const site string = &#34;https://qiucode.cn&#34; const siteName string = &#34;秋码记录&#34; 和变量一样，也是可以批量进行声明的。
const ( site = &#34;https://qiucode.cn&#34; siteName = &#34;秋码记录&#34; ) 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式，对应的常量类型也是一样的。
const ( a = 1 b c = 2 d ) 2、iota常量生成器假如将一周的每一天定义一个常量，从周日0开始，而这种状况在其他编程语言中，被称为枚举类型（enum）。
package main import &#34;fmt&#34; const ( Sunday int = iota Monday Tuesday Wednesday Thursday Friday Saturday ) func main() { fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday) }   ]]></content></entry><entry><title>Go 语言中的类型转换以及类型推导（Let's Go 六）</title><url>/article/126/</url><categories><category>golang</category></categories><tags><tag>类型推导</tag><tag>类型转换</tag></tags><content type="html"><![CDATA[  在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。
1、类型转换需要注意的是在Go当中没有隐式转换，只有显式转换。
表达式 T(v) 将值 v 转换为类型 T。
package main import ( &#34;fmt&#34; &#34;math&#34; ) func main() { var x, y int = 3, 4 var f float64 = math.Sqrt(float64(x*x + y*y)) var z uint = uint(f) fmt.Println(x, y, z) } 而如果是字符串要和数值进行转换。有两种方式，一种是使用rune（int32）来转换，另一种则是使用strconv包来转换，Itoa方法是将整型转换为字符串类型，而Atoi则相反，它是将字符串数值转换为整型。
// hello project main.go package main import ( &#34;fmt&#34; &#34;strconv&#34; ) func main() { var site string = &#34;https://qiucode.cn 已经悄然上线了&#34; var age int = 4 fmt.Printf(&#34;%s%d年！ &#34;, site, age) fmt.Println() fmt.Println(site + strconv.Itoa(age) + &#34;年！&#34;) str := site + strconv.Itoa(age) + &#34;年！&#34; fmt.Println(str) } 2、类型推导其实，类型推导前面几篇以及本文实例都有涉及到，只是你没有注意到而已。
在声明一个变量而不指定其类型时（即使用不带类型的 := 语法或 var = 表达式语法），变量的类型由右值推导得出。
当右值声明了类型时，新变量的类型与其相同：
var i int j := i // j 也是一个 int 不过当右边包含未指明类型的数值常量时，新变量的类型就可能是 int, float64 或 complex128 了，这取决于常量的精度：
i := 42 // int f := 3.142 // float64 g := 0.867 + 0.5i // complex128   ]]></content></entry><entry><title>Go 语言中的字符串（Let's Go 五）</title><url>/article/125/</url><categories><category>golang</category></categories><tags><tag>字符串</tag><tag>转义符</tag></tags><content type="html"><![CDATA[  字符串想必是所有编程语言最为基础的类型，当然，Go中也不另外，字符串可根据需要会占用1到4个字节内存，由于Go采用的是UTF-8字符集编码格式，所以Go不需要像其他编程语言那样对使用UTF-8字符集的文本进行编码与解码。
字符串想必是所有编程语言最为基础的类型，当然，Go中也不另外，字符串可根据需要会占用1到4个字节内存，由于Go采用的是UTF-8字符集编码格式，所以Go不需要像其他编程语言那样对使用UTF-8字符集的文本进行编码与解码。
1、定义字符串使用双引号&quot;&quot;来定义字符串，而且字符串内可以使用转义字符来格式化字符串，常用转义字符有以下这些：
\n：换行符 \r：回车符 \t：tab 键 \u 或 \U：Unicode 字符 \：反斜杠自身 // hello project main.go package main import ( &#34;fmt&#34; ) func main() { var str = &#34;一个神奇的网站：https://qiucode.cn\n&#34; fmt.Printf(str) } 其实，字符串是字节的定长数组，所以可以使用数组索引（也可以称为下标）来操作字符串。
获取字符串的第一个字节： str[0] 获取字符串最后一个字节： str[len(str) - 1] 需要注意的是，这种转换方案只对纯 ASCII 码的字符串有效。
获取字符串中某个字节的地址属于非法行为，例如 &amp;str[i]。
2、字符串拼接两个或两个字符串拼接使用+进行拼接。由于因为编译器会在行尾自动补全分号，所以拼接字符串用的加号+必须放在第一行末尾。
// hello project main.go package main import ( &#34;fmt&#34; ) func main() { var str = &#34;我推荐&#34; var str2 = &#34;一个神奇的网站：https://qiucode.cn\n&#34; str3 := str + str2 str4 := &#34;一个您值得拥有的网站:&#34; + &#34;https://qiucode.cn\n&#34; str5 := &#34;这究竟是一个怎样的网站呢？&#34; str5 += &#34;您不妨去浏览一番就知道了 \n&#34; fmt.Printf(str3, str4, str5) } 3、定义多行字符串由于字符串字面量不能跨行，想要定义多行字符串，就得使用`` `反引号了。
// hello project main.go package main import ( &#34;fmt&#34; ) func main() { var str = `我推荐 一个神奇的网站：https://qiucode.cn， 您值得拥有的网站！ 这究竟是一个怎样的网站呢？ 您不妨去浏览一番就知道了 \n` fmt.Printf(str) }   ]]></content></entry><entry><title>Go 语言中的多变量同时赋值、匿名变量以及变量作用域（Let's Go 四）</title><url>/article/124/</url><categories><category>golang</category></categories><tags><tag>匿名变量</tag></tags><content type="html"><![CDATA[  在函数体外声明的变量称之为全局变量，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，当然，不包含这个全局变量的源文件需要使用“import”关键字引入全局变量所在的源文件之后才能使用这个全局变量。
1、多变量同时赋值首先，我们来一个在编程中最为常见的算法，那就是变量交换值操作。
// hello project main.go package main import ( &amp;#34;fmt&amp;#34; ) var num int = 100 var num2 int = 200 var temp int func main() { temp = num num = num2 num2 = temp fmt.Println(num, num2) } 如果不想使用中间变量，也能达到变量值的交换，那无疑是减少了对内存的开销，并且这种方法执行起来效率还很高呢！
// hello project main.go package main import ( &amp;#34;fmt&amp;#34; ) var num int = 300 var num2 int = 400 func main() { num = num ^ num2 num2 = num2 ^ num num = num ^ num2 fmt.Println(num, num2) } 而Go中实现变量值交换是相当的简单。这就是Go当中的多重复制,多重赋值时，变量的左值和右值按从左到右的顺序赋值。
// hello project main.go package main import ( &amp;#34;fmt&amp;#34; ) var num int = 500 var num2 int = 600 func main() { num, num2 = num2, num fmt.Println(num, num2) } 2、匿名变量匿名类、匿名函数知道在很多编程语言中有，可这匿名变量是头一次听说吧！匿名，顾名思义就是没有名字的意思。
那么，在Go中该如何表示匿名变量呢？其实，很简单，使用_代表这是匿名变量，_本身是一个特殊的标识符，被称为空白标识符。
它可以像其他标识符那样用于变量的声明或赋值（任何类型都可以赋值给它），但任何赋给这个标识符的值都将被抛弃，因此这些值不能在后续的代码中使用，也不可以使用这个标识符作为变量 …  ]]></content></entry><entry><title>Go 语言中的基本类型以及变量声明与初始化（Let's Go 三）</title><url>/article/123/</url><categories><category>golang</category></categories><tags><tag>基本类型</tag></tags><content type="html"><![CDATA[  刚才只是声明了变量，并没有给他赋值，虽然可以只是只声明变量，而后赋值也是可以的。但可以在声明变量是并初始化变量，也就是给变量赋初始值。
1、基本类型作为一门编程语言，Go也和其他同是编程语言一样，Go也有属于自己的一套基本类型，好了，闲话少扯，那就来看看Go中有哪些基本类型呢。
Go 语言的基本类型有：
bool string int、int8、int16、int32、int64 uint、uint8、uint16、uint32、uint64、uintptr byte // uint8 的别名 rune // int32 的别名 代表一个 Unicode 码 float32、float64 complex64、complex128 1、整型而从有无符号可分为两类。
有符号按长度划分： int、int8、int16、int32、int64
无符号按长度划分：uint、uint8、uint16、uint32、uint64
Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
uintptr 以存储指针的 uint32 或 uint64 整数。
2、浮点型Go 有两种浮点类型，分别为float32和float64，没有什么float以及double哦！
3、布尔型这与其他编程语言一样，有true（真）和flase两个值。
4、复数复数的默认类型是complex128(64位实数 + 64位虚数) 还有一种是complex64(32位实数 + 32位虚数)。
2、变量声明以及初始化var name type 说明：var是声明变量的关键词，name是要定义的变量名称，type是变量的类型。
其实，Go语言是规避定义指针时类型模糊的缘故。
int* a,b; //这时，b并不是指针类型，而只是整型 int *c,*d; //而只有这样，从和d才都是指针变量呢 而在Go中是这样定义指针的
var a,b *int 若你觉得每行声明变量比较繁琐，可以使用批量声明变量的。
使用关键字 var 和圆括号，可以将一组变量定义放在一起。
刚才只是声明了变量，并没有给他赋值，虽然可以只是只声明变量，而后赋值也是可以的。但可以在声明变量是并初始化变量，也就是给变量赋初始值。
var a int = 6 var b,c String = &#34;hello&#34;,&#34;qiucode.cn&#34; var ( name string = &#34;qiucode.cn&#34; age int = 4 ) 其实还有一种简短格式，
变量名 := 初始值 使用这种简短需要注意几点：
1、定义变量，同时显示初始化。 2、不能提供数据类型以及var关键词 3、只能在函数内部使用。 很显然，在函数外部声明，编译报错
  ]]></content></entry><entry><title>使用集成开发环境来开发Go项目</title><url>/article/122/</url><categories><category>golang</category></categories><tags><tag>goland</tag><tag>VS code</tag><tag>liteide</tag></tags><content type="html"> 工欲善其事，必先利其器。好的集成开发环境（IDE）能让你事倍功半，好了，废话少扯，下来介绍几种能开发Go项目的IDE。
1、介绍几种 IDE 可以开发 Go
工欲善其事，必先利其器。好的集成开发环境（IDE）能让你事倍功半，好了，废话少扯，下来介绍几种能开发Go项目的IDE。
1、Goland
Goland 是由 JetBrains 公司开发的一个新的商业 IDE，旨在为 Go 开发者提供的一个符合人体工程学的新的商业 IDE。Goland 整合了 IntelliJ 平台（一个用于 java 语言开发的集成环境，也可用于其他开发语言），提供了针对Go语言的编码辅助和工具集成。
2、LiteIDE
LiteIDE是一款专门针对 Go 开发的集成开发环境，在编辑、编译和运行 Go 程序和项目方面都有非常好的支持。同时还包括了对源代码的抽象语法树视图和一些内置工具（此开发环境由国人 vfc 大叔开发）。
LiteIDE 是一款非常好用的轻量级 Go 集成开发环境（基于 QT、Kate 和 SciTE），包含了跨平台开发及其它必要的特性，对代码编写、自动补全和运行调试都有极佳的支持。它采用了 Go 项目的概念来对项目文件进行浏览和管理，它还支持在各个 Go 开发环境之间随意切换以及交叉编译的功能。
3、 Sublime Text
一个革命性的跨平台（Linux、Mac OS X、Windows）文本编辑器，它支持编写非常多的编程语言代码。对于 Go 而言，它有一个插件叫做 GoSublime 来支持代码补全和代码模版。
4、GoClipse
是一款 Eclipse IDE 的插件，拥有非常多的特性以及通过 GoCode 来实现代码补全功能。其依附于著名的 Eclipse 这个大型开发环境，虽然需要安装 JVM 运行环境，但却可以很容易地享有 Eclipse 本身所具有的诸多功能。这是一个非常好的编辑器，完善的代码补全、抽象语法树视图、项目管理和程序调试功能。
5、 Visual Studio Code（简称VS Code）
是一款由微软公司开发的，能运行在 Mac OS X、Windows 和 Linux 上的跨平台开源代码编辑器。
VS Code 使用 JSON 格式的配置文件进行所有功能和特性的配置，同时它还可以通过扩展程序为编辑器实现编程语言高亮、参数提示、编译、调 …</content></entry><entry><title>window下安装 Go 语言开发包</title><url>/article/121/</url><categories><category>golang</category></categories><tags><tag>golang SDK安装</tag></tags><content type="html"><![CDATA[  在window下安装最新Go语言开发包
1、下载 Go 开发包其实可以从以下几个地方下载Go语言开发包。
1、https://github.com/golang/go/tags 2、https://go.dev/dl/ 历史版本在得往下拉
3、https://golang.google.cn/dl/
其实与第二个是一样的
2、安装Go语言开发包双击下载下来的msi···文件，可以说一路next```下去。
如果在上一步点击了Next，则跳过
点击``OK```后，又回到上一步界面
点击Install进行安装
安装中……
安装成功，点击Finish或者直接点击右上角红叉关闭它。
3、在cmd命令窗口验证在此之前，或许有人会说，你环境变量还没配置啊！cmd命令行窗口怎么会有这个命令呢？反正新版本不需要配置环境变量了。
使用以下命令查看当前安装的Go语言开发包版本。可有人又要说了，这还用命令行查看，下载以及安装的时候，不是知道版本了吗？的确，是知道你当前安装的Go版本。
go version 查看Go环境
go env 4、编写一个 Hello Wolrd !
新建一个空文件，以go作为后罪名。例如hello.go
package main import &#34;fmt&#34; func main() { fmt.Println(&#34;Hello, World!&#34;) } 在cmd输入以下命令
go run hello.go   ]]></content></entry><entry><title>ag-grid 右键单元格动态改变单元格样式</title><url>/article/120/</url><categories><category>前端</category><category>Vue</category></categories><tags><tag>ag-grid</tag><tag>单元格单击</tag><tag>大量数据处理</tag></tags><content type="html"><![CDATA[  在window下安装最新Go语言开发包自定义单元格单击或右键时，给单元格添加不一样的样式而苦苦搜寻，可找了好久却好像都没有呢？巧了，笔者已经实现了这一看似很简单地功能！
先来看下最终实现效果： 你在看这篇文章的时候，那就说明你项目中已经引入了ag-grid表格库，本文是基于 vue 实现的。
&lt;ag-grid-vue :style=&#34;{height: tableHeight,width: &#39;100%&#39;}&#34; class=&#34;flex-grow-1 flex-shrink-1 ag-theme-alpine&#34; :gridOptions=&#34;gridOptions&#34; :columnDefs=&#34;columnDefs&#34; :rowData=&#34;rowData&#34; :sideBar=&#34;sideBar&#34; :animateRows=&#34;true&#34; :autoGroupColumnDef=&#34;autoGroupColumnDef&#34; :defaultColDef=&#34;{ sortable: true, resizable: true, filter: true, minWidth: 100, }&#34; :groupHeaders=&#34;true&#34; :suppressRowClickSelection=&#34;true&#34; rowSelection=&#34;multiple&#34; :allowContextMenuWithControlKey=&#34;true&#34; :getContextMenuItems=&#34;getContextMenuItems&#34; @grid-ready=&#34;onReady&#34; @cell-clicked=&#34;onCellClicked&#34; @cell-context-menu=&#34;onCellContextMenu&#34; @cell-focused=&#34;onCellFocused&#34; &gt; &lt;/ag-grid-vue&gt; 首先定义两个全局变量，注意放在 export default语句外边
let selectRow = null,selectColumn = null export default { data(){ return { gridOptions: null, gridapi: null, columnDefs: null, rowData: null, showGrid: false, sideBar: false, rowCount: null, autoGroupColumnDef: null, } }, methods: { //数据是模拟 不必太在意于 createRowData() { const rowData = []; for (let i = 0; i &lt; 200; i++) { rowData.push({ name: &#39;张三&#39;+i, skills: { android: Math.random() &lt; 0.4, html5: Math.random() &lt; 0.4, mac: Math.random() &lt; 0.4, windows: Math.random() &lt; 0.4, css: Math.random() &lt; 0.4 }, dob: &#39;张三&#39;+i, address: &#39;张三&#39;+i, years: &#39;2020&#39;, proficiency: Math.round(Math.random() * 100), country: &#39;张三&#39;+i, continent: &#39;张三&#39;+i, language: &#39;zh&#39;, mobile: 134884552+&#39;i&#39;, landline: &#39;张三&#39;+i }); } this.rowData = rowData; }, createColumnDefs() { this.columnDefs = [ { headerName: &#39;#&#39;, minWidth: 60, width: 60, checkboxSelection: true, sortable: false, suppressMenu: true, pinned: true }, { headerName: &#39;Employee&#39;, children: [ { headerName: &#34;Name&#34;, field: &#34;name&#34;, editable: true, width: 150, pinned: true, }, { headerName: &#34;Country&#34;, field: &#34;country&#34;, width: 150, }, { headerName: &#34;DOB&#34;, field: &#34;dob&#34;, width: 120, pinned: true, filter: &#39;agDateColumnFilter&#39;, columnGroupShow: &#39;open&#39; } ] }, { headerName: &#39;IT Skills&#39;, children: [ { headerName: &#34;Skills&#34;, width: 125, sortable: false, }, { headerName: &#34;Proficiency&#34;, field: &#34;proficiency&#34;, width: 120, }, ] }, { headerName: &#39;Contact&#39;, children: [ { headerName: &#34;Mobile&#34;, field: &#34;mobile&#34;, width: 150, filter: &#39;text&#39; }, { headerName: &#34;Land-line&#34;, field: &#34;landline&#34;, width: 150, filter: &#39;text&#39; }, {headerName: &#34;Address&#34;, field: &#34;address&#34;, width: 500, filter: &#39;text&#39;} ] } ]; }, onReady(params) { console.log(&#39;onReady&#39;); this.gridapi = params.api; this.calculateRowCount(); this.gridapi.sizeColumnsToFit(); }, //单元格点击事件 onCellClicked(event) { //selectRow = event.data //selectColumn = event.colDef }, /** * 右键弹出菜单 */ onCellContextMenu(event) { let headerDom = document.querySelectorAll(&#39;.ag-cell&#39;) for (const n of headerDom) { n.style.backgroundColor = &#39;#fff&#39; n.style.color = &#39;#000&#39; } var column = event.colDef.field; if (event.data === selectRow &amp;&amp; event.colDef === selectColumn) { //return &#39;col-orange&#39; event.colDef.cellStyle = { &#39;background-color&#39;: &#39;#f60&#39;, &#39;color&#39;: &#39;#fff&#39; }; } this.gridapi.refreshCells({ force: true, columns: [column], rowNodes: [event.node] }); }, //单元获得焦点 onCellFocused(event) { let rowData = this.gridapi.getRowNode(event.rowIndex) selectRow = rowData.data selectColumn = event.column.colDef }, }, beforeMount() { this.gridOptions = {}; this.gridOptions.components = {agDateInput: DateComponent}; this.createRowData(); this.createColumnDefs(); this.showGrid = true; }, }   ]]></content></entry><entry><title>自定义vxe-table表头标题文字过多，显示两行多余省略号并给出tooltip</title><url>/article/119/</url><categories><category>前端</category><category>Vue</category></categories><tags><tag>vxe-table</tag><tag>tooltip</tag><tag>自定义提示</tag></tags><content type="html"><![CDATA[  自定义vxe-table表头标题文字过多，显示两行多余省略号并给出tooltip
在上一篇已经实现表头换行，本文将继续实现对含有省略号的标题做出tooltip提示。
最终效果如下图： 1、首先在body创建一个divlet tooltipDiv = document.createElement(&#39;div&#39;) tooltipDiv.setAttribute(&#34;class&#34;,&#34;vxe-table--tooltip-wrapper&#34;) document.body.appendChild(tooltipDiv); 2、对表头添加鼠标移入移出事件mounted() { let that = this setTimeout( () =&gt; { const tooltipDom = document.querySelector(&#39;.vxe-table--tooltip-wrapper&#39;) let th =document.querySelectorAll(&#39;.vxe-table--header th.vxe-header--column&#39;) let storeColumn = this.$store.state.autoFilter.columnTitleObj for(let i=0;i&lt;th.length;i++){ let colid = th[i].getAttribute(&#34;colid&#34;) let currColumn = that.$refs.table.getColumnById(colid) let isTooltip = false let orgTitle = &#39;&#39; for(let j = 0; j &lt; storeColumn.length; j++){ if(storeColumn[j][&#39;prop&#39;] == currColumn[&#39;property&#39;]){ isTooltip = storeColumn[j][&#39;tooltip&#39;] orgTitle = storeColumn[j][&#39;orgTitle&#39;] break } } if(isTooltip){ th[i].addEventListener(&#39;mouseenter&#39;,(e) =&gt; { const { scrollTop, scrollLeft, visibleWidth } = this.$TOOL.getDomNode() const { top, left } = this.$TOOL.getAbsolutePos(e.target) const el = th[i] const marginSize = 6 const offsetHeight = el.offsetHeight const offsetWidth = el.offsetWidth let tipLeft = left //let tipTop = top - offsetHeight - marginSize tipLeft = Math.max(marginSize, left + Math.floor((e.target.offsetWidth - offsetWidth) / 2)) if (tipLeft + offsetWidth + marginSize &gt; scrollLeft + visibleWidth) { tipLeft = scrollLeft + visibleWidth - offsetWidth - marginSize } if (top - offsetHeight &lt; scrollTop + marginSize) { //tipStore.placement = &#39;bottom&#39; //tipTop = top + e.target.offsetHeight + marginSize } let arrowLeft = `${left - tipLeft + e.target.offsetWidth / 2}px` tooltipDom.classList.add(&#34;theme--dark&#34;,&#34;size--small&#34;,&#34;placement--top&#34;,&#34;is--enterable&#34;, &#34;is--visible&#34;,&#34;is--arrow&#34;,&#34;is--actived&#34;) tooltipDom.setAttribute(&#34;style&#34;,&#34;width:auto;left:&#34;+tipLeft+&#34;px;top:126px;z-index:1000;&#34;) tooltipDom.innerHTML = &#39;&lt;div class=&#34;vxe-table--tooltip-content&#34;&gt;&#39;+orgTitle+&#39;&lt;/div&gt;&lt;div class=&#34;vxe-table--tooltip-arrow&#34; style=&#34;left:&#39;+arrowLeft+&#39;&#34;&gt;&lt;/div&gt;&#39; }) th[i].addEventListener( &#39;mouseleave&#39;,() =&gt; { console.log(&#39;鼠标移出&#39;) tooltipDom.classList.remove(&#34;placement--top&#34;,&#34;is--visible&#34;,&#34;is--actived&#34;) }) } } },1500) } 工具函数
/** * 获取某DOM节点的信息 * @param elem {object} DOM节点 * @returns {{boundingLeft: number, visibleWidth: *, top: *, left: *, boundingTop: number, visibleHeight: *}} */ tool.getAbsolutePos = function(elem){ const bounding = elem.getBoundingClientRect() const boundingTop = bounding.top const boundingLeft = bounding.left const { scrollTop, scrollLeft, visibleHeight, visibleWidth } = this.getDomNode() return { boundingTop, top: scrollTop + boundingTop, boundingLeft, left: scrollLeft + boundingLeft, visibleHeight, visibleWidth } } /** * 获取body DOM对象相关信息 * @returns {{visibleWidth: number, visibleHeight: number, scrollLeft: number, scrollTop: number}} */ tool.getDomNode = function() { const documentElement = document.documentElement const bodyElem = document.body return { scrollTop: documentElement.scrollTop || bodyElem.scrollTop, scrollLeft: documentElement.scrollLeft || bodyElem.scrollLeft, visibleHeight: documentElement.clientHeight || bodyElem.clientHeight, visibleWidth: documentElement.clientWidth || bodyElem.clientWidth } } 在vuex加入
export default { state: { columnTitleObj: [], //列表头标题 orgTitle: &#39;&#39;, //原表头标题 }, mutations:{ SET_COLUMN_TITLE(state,item){ state.columnTitleObj = item }, SET_ORG_TITLE(state,item){ state.orgTitle = item }, } } 在 resizableChange 方法添加如下内容
resizableChange({column}){ let orgColumn = this.$store.state.autoFilter.columnTitleObj for(let i = 0; i &lt; orgColumn.length; i++){ if(orgColumn[i].prop == column.property){ this.$store.commit(&#34;SET_ORG_TITLE&#34;, orgColumn[i][&#39;orgTitle&#39;]) break } } let orgTitle = this.$store.state.autoFilter.orgTitle let l = orgTitle.length //column.title.length let f = 16 //每一个字大小，实际上是每一个字的比例值，大概会比字体大小差很少大一点， let subLen = ~~(2 * (Number(column[&#39;resizeWidth&#39;]) - 30 )) / f let lineCount = ~~((Number(column[&#39;resizeWidth&#39;]) - 30 ) / f) let showTextNum = 2 * lineCount let isTooltip = false if(l &gt; showTextNum){ column.title = this.$TOOL.subString(orgTitle,10,true) isTooltip = true }else{ column.title = this.$TOOL.subString(orgTitle,subLen,false) isTooltip = false } for(let i = 0; i &lt; orgColumn.length; i++){ if(orgColumn[i].prop == column.property){ orgColumn[i].tooltip = isTooltip break } } this.$store.commit(&#34;SET_COLUMN_TITLE&#34;, orgColumn) }   ]]></content></entry><entry><title>vue vxe-table表格标题根据内容宽度自动换行</title><url>/article/117/</url><categories><category>golang</category></categories><tags><tag>vxe-table</tag><tag>内容过多省略</tag></tags><content type="html"><![CDATA[  表格标题内容过多时，换行显示且多余部分以省略号显示。
1、最终实现效果如下2、修改 vxe-table 表头样式.vTable-table .vxe-table .vxe-table--header .vxe-header--row .vxe-header--column .vxe-cell--title { white-space:pre-wrap; word-wrap: break-word; } 3、添加改变列宽度的回调方法&lt;vxeTable ref=&#34;table&#34; &lt;!--省略表格属性 以及方法 这些不是本文的重点--&gt; @resizable-change=&#34;resizableChange&#34;&gt;&lt;/vxeTable&gt; /** * 在改变表格宽度时 表头内容自适应宽度 * @param column {object} 当前移动的列对象 */ resizableChange({column }){ let orgColumn = this.$store.state.autoFilter.columnTitleObj orgColumn.forEach(item =&gt; { try{ if(item.prop == column.property){ this.$store.commit(&#34;SET_ORG_TITLE&#34;, item[&#39;orgTitle&#39;]) throw new Error(&#39;退出循环！&#39;); } }catch(e){ console.log(e) } }) let orgTitle = this.$store.state.autoFilter.orgTitle let l = orgTitle.length //column.title.length let f = 16 //每一个字大小，实际上是每一个字的比例值，大概会比字体大小差很少大一点， let labelWidth = f * l //字大小乘个数即长度 ,注意不要加px像素，这里minWidth只是一个比例值，不是真正 let minWidth = column[&#39;minWidth&#39;] let subLen = ~~(2 * (Number(column[&#39;resizeWidth&#39;]) - 30 )) / f let lineCount = ~~((Number(column[&#39;resizeWidth&#39;]) - 30 ) / f) let showTextNum = 2 * lineCount // 最小宽度 120 扣除 30 一行 90 显示两行 180 if(l &gt; showTextNum){ column.title = this.subString(orgTitle,10,true) }else{ column.title = this.subString(orgTitle,subLen,false) } }, /** * 截取中英文字符 * @param str {string} 原始字符 * @param len {number} 需截取的字符长度 * @param hasDot {boolean} 是否需要省略号 * @returns {string} 返回截取后的新字符 */ subString(str, len, hasDot) { var newLength = 0; var newStr = &#34;&#34;; var chineseRegex = &#34;/[^\x00-\xff]/g&#34;; var singleChar = &#34;&#34;; var strLength = str.replace(chineseRegex, &#34;**&#34;).length; for (var i = 0; i &lt; strLength; i++) { singleChar = str.charAt(i).toString(); if (singleChar.match(chineseRegex) != null) { newLength += 2; } else { newLength++; } if (newLength &gt; len) { break; } newStr += singleChar; } if (hasDot &amp;&amp; strLength &gt; len) { newStr += &#34;...&#34;; } return newStr; }, 4、使用vuex保留原始的表头标题export default { state: { columnTitleObj: [], //列表头标题 orgTitle: &#39;&#39;, //原表头标题 }, mutations:{ SET_COLUMN_TITLE(state,item){ state.columnTitleObj = item }, SET_ORG_TITLE(state,item){ state.orgTitle = item }, }   ]]></content></entry><entry><title>Chrome扩展程序开发入门（基于 V3）</title><url>/article/113/</url><categories><category>前端</category><category>Chrome扩展</category></categories><tags><tag>Chrome扩展</tag><tag>Chrome V3</tag></tags><content type="html"><![CDATA[  Chrome扩展指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + Javascript 语言开发[*]。比如著名的 Adblock plus。
1、Chrome插件与Chrome扩展的区别？完整的扩展可以在这里下载。
Chrome扩展
扩展（Extension），指的是通过调用 Chrome 提供的 Chrome API 来扩展浏览器功能的一种组件，工作在浏览器层面，使用 HTML + Javascript 语言开发[*]。比如著名的 Adblock plus。
Chrome插件
插件（Plug-in），指的是通过调用 Webkit 内核 NPAPI 来扩展内核功能的一种组件，工作在内核层面，理论上可以用任何一种生成本地二进制程序的语言开发，比如 C/C++、Delphi 等。比如Flash player 插件，就属于这种类型。一般在网页中用 或者 标签声明的部分，就要靠插件来渲染。
2、如何开发一个 Chrome 扩展 ？既然知道了 Chrome 扩展 是用 HTML + javascript 开发的了，那么我们首先要做的就是要搭建一个前端项目出来。
1、创建manifest
扩展从它们的manifest开始。创建一个名为manifest.json并包含以下代码的文件。
{ &amp;#34;name&amp;#34;: &amp;#34;Getting Started Example&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;Build an Extension!&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;1.0&amp;#34;, &amp;#34;manifest_version&amp;#34;: 3 } 2、在Chrome浏览器添加该扩展
保存清单文件的目录可以在其当前状态下作为开发人员模式的扩展添加。要在开发人员模式下加载解压缩的扩展，请按照下列步骤操作：
1、通过导航到 来打开扩展管理页面
chrome://extensions 或者，通过单击扩展菜单按钮并选择菜单底部的管理扩展来打开此页面。 或者，通过单击 Chrome 菜单打开此页面，将鼠标悬停在更多工具上，然后选择扩展 扩展已成功安装。因为清单中没有包含图标，所以将为扩展创建一个通用图标。
3、注册后台脚本编 …  ]]></content></entry><entry><title>Ubuntu 16.04LTS 安装 redis-6.2.6（源码安装）</title><url>/article/112/</url><categories><category>NOSql</category><category>redis</category><category>Linux</category><category>ubuntu</category></categories><tags><tag>Ubuntu 16.04LTS</tag><tag>redis</tag></tags><content type="html"> Ubuntu 16.04LTS 安装 redis-6.2.6（源码安装）
一、下载redis-6.2.6源码包
redis 官网下载地址： https://redis.io/download
二、解压文件
将下载好的文件上传到 Ubuntu上面。
tar xzvf redis-6.2.6.tar.gz 三、编译安装
cd redis-6.2.6 make make test make install 四、配置redis
创建redis配置目录：/etc/redis
mkdir /etc/redis 拷贝配置文件到该目录下。
cp /home/redis-6.2.6/redis.conf /etc/redis 修改配置文件
gedit /etc/redis/redis.conf 找到supervised一行，把no改为systemd：
supervised systemd Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程，设置为no
daemonize no 保护模式,关闭保护模式，否则外部ip无法连接
protected-mode no 将bind 127.0.0.1::1这一行注释起来。
找到dir一行，配置数据库的保存目录：
dir /home/redis-data 五、创建redis.service文件
gedit /etc/systemd/system/redis.service [Unit] Description=Redis In-Memory Data Store After=network.target [Service] User=redis Group=redis ExecStart=/usr/local/bin/redis-server /etc/redis/redis.conf ExecStop=/usr/local/bin/redis-cli shutdown Restart=always [Install] WantedBy=multi-user.target 六、创建redis用户、组和目录
adduser --system --group --no-create-home redis mkdir /var/lib/redis chown redis:redis /home/redis-data chmod 770 /home/redis-data 七、启动redis服务
systemctl start redis systemctl enable redis systemctl status redis 重启redis服务
systemctl restart redis 测试一下
redis-cli</content></entry><entry><title>Navicat Premium 12连接Oracle时提示oracle library is not loaded的问题解决</title><url>/article/111/</url><categories><category>SQL</category><category>Oracle</category></categories><tags><tag>oracle</tag><tag>Navicat12</tag><tag>oracle library is not loaded</tag></tags><content type="html"> 解决Navicat12连接Oracle报oracle library is not loaded的提示问题
打开Navicat12，如下图
连接Oracle时提示“oracle library is not loaded”。
原因是缺少本地Oracle dll文件 可到 Oracle官网下载对应的Instant Client https://www.oracle.com/technetwork/database/database-technologies/instant-client/downloads/index.html
下载对应自己系统的
当然你在下载之前得先有个Oracle的账号
笔者选择的版本是这个
将下载的文件进行解压并复制到Navicat安装目录下
这是Navicat原先安装目录文件
将刚才解压出来的文件夹放到这里就好了
而后再次打开Navicat12 选择 工具栏 选项…
在弹出的对话框中 左侧 选择 环境 这一项
确定并退出Navicat12 重启Navicat12</content></entry><entry><title>Git版本控制教程之在Visual Studio Code中如何使用（四）</title><url>/article/109/</url><categories><category>Git</category><category>版本控制</category></categories><tags><tag>VS Code</tag><tag>git</tag><tag>IDE</tag></tags><content type="html"><![CDATA[  在前面几篇讲解了git命令行的基本操作后，本篇将持续讲解git在VS code编辑器中是如何工作的？
1、初始化本地库使用VS Code打开一个还没被git管理的文件夹，则可以通过使用Initialize Repository命令创建 Git 存储库来启用 Git 源代码控制
接下来，尝试着创建文件并添加到本地git仓库。
依次按图中操作，从左至右依次操作，现将新建或已被git管理的文件修改，添加到暂存区，再从暂存区提交到git本地仓库， 当然在攥写提交信息时可以使用快捷键Ctrl+Enter。
2、分支与标签创建标签也是相当的简单。
切换分支Checkout to...
要切换到那个分支或标签就点击哪个
VS Code编辑器底部状态栏可以看出当前处于哪个分支
3、合并冲突首先我们切换到vscode分支下，修改HelloGit.java文件。并将其提交到git本地库中
然后再切换到master分支，同样也是修改HelloGit.java文件，并提交到git本地仓库。
在当前分支为master，合并vscode分支。
切换到master分支下，合并vscode分支。
可以看到修改同一文件合并时出现了冲突，&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD到=======之间的内容属于当前分支，而=======到&gt;&gt;&gt;&gt;&gt;&gt;&gt; vscode（要合并的分支）的内容是将要合并的分支内容，所以这样git没有处理，所以文件冲突交给了使用者自行处理。
经过手动处理后，再次提交到git本地仓库。
4、从远程仓库拉取如果您尚未打开文件夹，源代码管理视图将为您提供从本地计算机或**克隆存储库**打开文件夹的选项。
事例地址 https://gitee.com/zhenqi/qiucodeBlog.git5、推送到远程仓库我们修改文件，然后提交到git本地仓库并推送到远程仓库。
  ]]></content></entry><entry><title>Git版本控制教程之分支（三）</title><url>/article/108/</url><categories><category>Git</category><category>版本控制</category></categories><tags><tag>branch</tag><tag>merge</tag><tag>分支</tag></tags><content type="html"> 几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。
几乎所有的版本控制系统都以某种形式支持分支。 使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 在很多版本控制系统中，这是一个略微低效的过程——常常需要完全创建一个源代码目录的副本。对于大项目来说，这样的过程会耗费很多时间。
​ 有人把 Git 的分支模型称为它的“必杀技特性”，也正因为这一特性，使得 Git 从众多版本控制系统中脱颖而出。 为何 Git 的分支模型如此出众呢？ Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。 理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。
1、创建分支
Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 dev 分支， 你需要使用 git branch 命令：
git branch dev 那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。
你可以简单地使用 git log 命令查看各个分支当前所指的对象。 提供这一功能的参数是 --decorate。
git log --oneline --decorate 2、分支切换
要切换到一个已存在的分支，你需要使用 git checkout 命令。 我们现在切换到新创建的 testing 分支去：
git checkout dev 这样 HEAD 就指向 dev 分支了。
那么，不妨新建 …</content></entry><entry><title>Git版本控制教程之为项目打上标签（二）</title><url>/article/107/</url><categories><category>Git</category><category>版本控制</category></categories><tags><tag>tags</tag><tag>标签</tag></tags><content type="html"><![CDATA[  git为项目打上标签，例如，可以在项目稳定阶段或测试阶段，都可以打上一个版本号作为标签名。
1、列出标签首先先列出当前项目的已有标签。
git tag 你也可以按照特定的模式查找标签。 例如，Git 自身的源代码仓库包含标签的数量超过 500 个。 如果只对 1.8.5 系列感兴趣
git tag -l &#34;v1.8.5*&#34; # 按照通配符列出标签需要 -l 或 --list 选项 2、创建标签git tag -a v0.0.1 -m &#34;初始版本 0.0.1&#34; 显示 v0.0.1标签与之对应的提交信息
git show v0.0.1 3、后续打标签对已经提交过的版本但还未有标签的，也可创建标签
git log --pretty=oneline git tag -a v0.0.0.1 309bc6f # 309bc6f 是 SHA-1字符串前7个字符 4、推送标签到远程仓库默认情况下，git push 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 git push origin &lt;tagname&gt;。
git push origin v0.0.0.1 可以看到远程库上面没有任何标签，在推送远程库之后，刷新页面。
如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库服务器上的标签全部传送到那里。
git push origin --tags 5、删除标签有时候需要删除本地仓库的标签，可以使用git tag -d &lt;tagname&gt;
git tag -d v0.0.0.2 当然你在执行以上命令后，并未删除远程库对应的标签，需使用git push &lt;remote&gt; :refs/tags/&lt;tagname&gt;来更新远程库。
git push origin :refs/tags/v0.0.0.2 其实还有一种方法更为直观的删除远程库标签
git push origin --delete v0.0.0.2 6、检出标签（不建议这么做）​ 如果你想查看某个标签所指向的文件版本，可以使用 git checkout 命令， 虽然这会使你的仓库处于分离头指针（detached HEAD）的状态——这个状态有些不好的副作用： 在分离头指针状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：
敬请期待下一篇 git分支
  ]]></content></entry><entry><title>Git版本控制入门教程（一）</title><url>/article/106/</url><categories><category>Git</category><category>版本控制</category></categories><tags><tag>github</tag><tag>gitee</tag><tag>托管平台</tag></tags><content type="html"><![CDATA[  重新整理关于git版本控制的操作教程，相信你在看了这篇文章，你会更加清晰的认识git，和熟练的使用git
1、下载gitgit官网下载地址 https://git-scm.com/安装过程这里就不再赘述了，基本上默认就可以了。安装完 Git 之后，要做的第一件事就是设置你的用户名和邮件地址。 这一点很重要，因为每一个 Git 提交都会使用这些信息，它们会写入到你的每一次提交中，不可更改：
git config --global user.name &#34;zhangsan&#34; git config --global user.email zhangsan@qiucode.cn 2、获取git仓库2.1、将尚未进行版本控制的本地目录转换为 Git 仓库 执行：
git init 而刚才的文件夹也就多了.git目录了。
例如创建新文件
从上面图中可以看出，新建的文件在git本地仓库上一次快照没有找到，也没有放入暂存区，它属于未跟踪文件，执行了以下命令才会添加到暂存区。
git add . # . 表示当前目录所有文件夹及文件 从图中可以看出文件已放入暂存区。 使用以下命令可以将暂存区文件提交到本地仓库。
git commit -m &#39;第一次提交写的信息&#39; 可以看得出，目前没有任何文件需要提交，也就是说本地仓库中保存是最新的文件。 接下来我们试着修改文件，再来看看git文件处于什么状态呢？
说明已跟踪文件的内容发生了变化，但还没有放到暂存区。再次执行
git add . 从git仓库中移除文件，我们得把文件添加到暂存区。
执行移除文件命令：
git rm code/UserInfo.java 该命令会连同将你物理文件也删除了。
2.2、从其它服务器克隆一个已存在的 Git 仓库
git clone https://github.com/zhenqicai/qiucodeBlog.git # 可能会很慢 git clone https://gitee.com/zhenqi/qiucodeBlog.git # 这个毕竟是国内的，就比较快了 3、查看历史提交记录git log # 选项是 -p 或 --patch ，它会显示每次提交所引入的差异（按 补丁 的格式输出）。 你也可以限制显# 示的日志条目数量，例如使用 -2 选项来只显示最近的两次提交： git log -p -2 4、撤销操作在已在本地仓库的文件进行修改：
git reset HEAD code/UserInfo.java 该文件执行了以上命令后，文件从暂存区中撤销了。
git checkout -- code/UserInfo.java 执行以上命令后，该文件所修改的内容将被撤销了。
5、添加到远程仓库可参考 git使用教程之创建本地库并关联远程库（笔记整理篇一）git remote add gitlearn https://github.com/zhenqicai/gitlearn 推送到远程库
git push origin master   ]]></content></entry><entry><title>PHP 处理数据为树状结构</title><url>/article/105/</url><categories><category>PHP</category></categories><tags><tag>横向树状</tag><tag>二维数组</tag><tag>数组分组</tag></tags><content type="html"><![CDATA[  PHP处理没有父子级关系的数据为树状结构数据，对二维数组以某个键值相同的分组合并，最终形成树状结构数据
1、从数据库获取的数据2、对查询出来的数据按键值归类&lt;?php namespace app\index\controller; use think\Controller; use think\Db; use think\Log; class Data extends Controller { public function getTreeData(){ $res = Db::table(&#39;table_name&#39;) -&gt;select(); $erArr = self::getRepeatValGroup($res,&#39;platform&#39;); Log::info($erArr); $newArr = []; foreach($erArr as $erK =&gt; $erV){ $arr1 = []; foreach ($erV as $k =&gt; $v) { $arr1[$v[&#39;area&#39;]][] = $v; } $newArr[$erK][]=$arr1; } return json($newArr); } //$arr= 一个数组。$keys 是该数组里面的某一个值 该自定义函数主要是对二维数组里面的某一个值进行分组 public function getRepeatValGroup($arr,$keys) { if(!is_array($arr) || !$keys) { return false; } $temp = array(); foreach($arr as $key=&gt;$val) { $temp[$val[$keys]][] = $val; } return $temp; } } 3、页面通过ajax请求接口，使用第三方书组件$.ajax({ type:&#34;get&#34;, url:&#34;/index/channels/getPlatform&#34;, success:function(data){ let platformArr = [] Object.keys(data).map(platform =&gt; { let areaArr = [] data[platform].forEach(areaKey =&gt;{ //console.log(&#39;.........................&#39;) //console.log(areaKey) Object.keys(areaKey).map(area =&gt; { //console.log(&#39;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&#39;) ///console.log(area) //console.log(&#39;-------------区域-----------------------&#39;) //console.log(areaKey[area]) let countryArr = [] areaKey[area].forEach(country =&gt;{ countryArr.push({ id:country.channel_no, active: country.active, //parentId:data2[0].area, label:country.country }) }) areaArr.push({ label:area, children:countryArr }) }) }) if(platform == &#39;Amazon&#39;){ platformArr.unshift({ label: &#39;Amazon&#39;, children:areaArr }) }else{ platformArr.push({ label: platform, children:areaArr }) } }) } })   ]]></content></entry><entry><title>BootstrapTable 动态显示/隐藏某一行</title><url>/article/103/</url><categories><category>前端</category><category>BootstrapTable</category></categories><tags><tag>BootstrapTable 隐藏/显示表格行</tag></tags><content type="html"><![CDATA[  手写实现自动隐藏/显示BootstrapTable表格行
1、渲染表格既然你能阅读这篇文章，说明需要引入js、css等资源你是清楚不过的，这里就不在赘述了。
let twoTable = $(&#34;#twoTable&#34;); twoTable.bootstrapTable({ sortName: &#39;&#39;, escape: false, height:400, uniqueId:&#39;id&#39;, columns: [ [ { field:&#39;itemNO&#39;, title:&#39;货号&#39;, width: 160, formatter:function (value, row, index) { let divStr=&#39;&lt;div&gt; &#39;+ &#39;&lt;span&gt;&#39;+value+&#39;&lt;/span&gt;&#39;+ &#39;&lt;/div&gt;&#39; return divStr; } }, { field:&#39;title&#39;, title:&#39;量值&lt;span class=&#34;liangzhi glyphicon glyphicon-menu-hamburger&#34; style=&#34;cursor: pointer; margin-left: 5px;&#34; onclick=&#34;Backend.api.hideColsDialog()&#34;&gt;&lt;/span&gt;&#39;, width:90 }, //………… 省略其他 field ] ], data: [], //通过 append 动态加载数据 pagination: false, search: false, showSearch: false, showRefresh: false, showToggle: false, showColumns: false, showExport:false, commonSearch: false, }); 2、是否显示/隐藏行的选择弹框//根据选择栏位 是否需要隐藏哪位栏位 hideColsDialog: function(){ let dialogStr=&#39;&lt;div id=&#34;hideDialog&#34; class=&#34;modal fade bs-example-modal-sm&#34; tabindex=&#34;-1&#34; role=&#34;dialog&#34;&gt;&#39; +&#39;&lt;div class=&#34;modal-dialog modal-sm&#34; role=&#34;document&#34;&gt;&#39; +&#39;&lt;div class=&#34;modal-content&#34;&gt;&#39; +&#39;&lt;div class=&#34;modal-header&#34; style=&#34;background:#3b3a3a&#34;&gt;&#39; +&#39;&lt;h4 class=&#34;modal-title&#34; style=&#34;text-align:center;color:#fff&#34;&gt;选择栏位&#39; +&#39;&lt;span class=&#34;pull-right&#34;&gt;&#39; +&#39;&lt;span class=&#34;glyphicon glyphicon-ok&#34; style=&#34;padding-right: 10px;cursor: pointer;&#34; onclick=&#34;Backend.api.queryHideColsDialog()&#34; &gt;&lt;/span&gt;&#39; +&#39;&lt;span class=&#34;liangzhi-close-dialog glyphicon glyphicon-remove&#34; style=&#34;cursor: pointer;&#34; onclick=&#34;Backend.api.closeColsDialog()&#34;&gt;&lt;/span&gt;&#39; +&#39;&lt;/span&gt;&#39; +&#39;&lt;/h4&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;div class=&#34;modal-body&#34; style=&#34;padding-top: 5px;&#34;&gt;&#39; +&#39;&lt;div class=&#34;row&#34;&gt;&#39; +&#39;&lt;div class=&#34;col-md-8&#34;&gt;&#39; +&#39;&lt;fieldset&gt;&#39; +&#39;&lt;legend&gt;销售额&lt;/legend&gt;&#39; +&#39;&lt;label class=&#34;checkbox-inline&#34;&gt;&#39; +&#39;&lt;input type=&#34;checkbox&#34; name=&#34;beforeSales&#34; id=&#34;beforeSalesCheckbox&#34; value=&#34;beforeSales&#34; &gt;&lt;span&gt;去年同期&lt;/span&gt;&#39; +&#39;&lt;/label&gt;&#39; +&#39;&lt;label class=&#34;checkbox-inline&#34;&gt;&#39; +&#39;&lt;input type=&#34;checkbox&#34; name=&#34;salesRate&#34; id=&#34;salesRateCheckbox&#34; value=&#34;salesRate&#34; &gt;&lt;span&gt;成长率&lt;/span&gt;&#39; +&#39;&lt;/label&gt;&#39; +&#39;&lt;/fieldset&gt;&#39; +&#39;&lt;fieldset&gt;&#39; +&#39;&lt;legend&gt;销量&lt;/legend&gt;&#39; +&#39;&lt;label class=&#34;checkbox-inline&#34;&gt;&#39; +&#39;&lt;input type=&#34;checkbox&#34; name=&#34;beforeSalesCount&#34; id=&#34;beforeSalesCountCheckbox&#34; value=&#34;beforeSalesCount&#34; &gt;&lt;span&gt;去年同期&lt;/span&gt;&#39; +&#39;&lt;/label&gt;&#39; +&#39;&lt;label class=&#34;checkbox-inline&#34;&gt;&#39; +&#39;&lt;input type=&#34;checkbox&#34; name=&#34;salesCoumtRate&#34; id=&#34;salesCountRateCheckbox&#34; value=&#34;salesCoumtRate&#34; &gt;&lt;span&gt;成长率&lt;/span&gt;&#39; +&#39;&lt;/label&gt;&#39; +&#39;&lt;/fieldset&gt;&#39; +&#39;&lt;div style=&#34;margin-left: 10px;&#34;&gt;&#39; +&#39;&lt;label class=&#34;checkbox-inline&#34;&gt;&#39; +&#39;&lt;input type=&#34;checkbox&#34; name=&#34;salary&#34; id=&#34;salaryCheckbox&#34; value=&#34;salary&#34; &gt;&lt;span&gt;平均单价&lt;/span&gt;&#39; +&#39;&lt;/label&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;div class=&#34;col-md-4&#34;&gt;&#39; +&#39;&lt;p&gt;&#39; +&#39;&lt;label class=&#34;radio-inline&#34;&gt;&#39; +&#39;&lt;input type=&#34;radio&#34; name=&#34;inlineRadioOptions&#34; id=&#34;inlineRadio1&#34; value=&#34;option1&#34;&gt;图片&#39; +&#39;&lt;/label&gt;&#39; +&#39;&lt;/p&gt;&#39; +&#39;&lt;p&gt;成本&lt;/p&gt;&#39; +&#39;&lt;p&gt;颜色&lt;/p&gt;&#39; +&#39;&lt;p&gt;尺寸&lt;/p&gt;&#39; +&#39;&lt;p&gt;长宽高&lt;/p&gt;&#39; +&#39;&lt;p&gt;净重&lt;/p&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;/div&gt;&#39; +&#39;&lt;/div&gt;&#39; if($(&#39;#hideDialog&#39;).length==0){ $(&#39;body&#39;).append(dialogStr) } let checkObjStr = localStorage.getItem(&#39;checkObj&#39;) if(checkObjStr == null || checkObjStr == undefined){ $(&#39;input[type=checkbox]&#39;).prop(&#39;checked&#39;,true) }else{ let checkObj = JSON.parse(checkObjStr) Object.keys(checkObj).map(key =&gt; { $(&#39;input[name=&#39;+key+&#39;]&#39;).prop(&#39;checked&#39;,checkObj[key]) }) } $(&#39;input[type=radio]&#39;).prop(&#39;checked&#39;,false) let x=window.event.clientX let y=window.event.clientY let pageX=window.event.pageX let pageY=window.event.pageY var modalHeight=$(window).height() / 2; $(&#39;#hideDialog&#39;).find(&#39;.modal-dialog&#39;).css({ &#39;margin-top&#39;: modalHeight }); $(&#39;#hideDialog&#39;).modal({ backdrop:&#39;static&#39;, show:true }) },   ]]></content></entry><entry><title>xhr模拟表单下载文件</title><url>/article/97/</url><categories><category>前端</category><category>javascript</category></categories><tags><tag>表单</tag><tag>文件下载</tag></tags><content type="html"><![CDATA[  使用javascript原生XHR下载流文件，可进行计时下载，当然也是可以通过from表单进行下载文件的，但页面可能会有跨域问题，索性就在PHP做个桥接处理了。
一、在页面添加一个按钮&lt;a href=&#34;javascript:;&#34; class=&#34;btn btn-xs btn-primary btn-success btn-install&#34; id=&#34;exportBtn&#34; data-url=&#34;{:url(&#39;ajax/downloadExcel&#39;)}&#34; &gt; &lt;i class=&#34;fa fa-cloud-download&#34;&gt;&lt;/i&gt; 导出Excel &lt;/a&gt; 干嘛有那么麻烦，一个form不就可以解决的事情，非要弄的怎么麻烦呢？原因是下载远程服务器文件，且与本项目不在同一服务器上。
二、xhr模拟表单下载$(&#39;#exportBtn&#39;).on(&#39;click&#39;,function(){ let url= $(this).data(&#39;url&#39;) let itime = 0; $(&#34;#exportBtn&#34;).html(`正在下载,耗时&lt;i style=&#34;color:red;font-size:16px;font-weight:700;padding: 0 5px;&#34;&gt;${itime}&lt;/i&gt;秒`); let xhr = new XMLHttpRequest(); xhr.open(&#39;get&#39;, url, true); xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;); xhr.responseType = &#39;blob&#39;; xhr.send(null); xhr.onload = function () { if (this.status == 200) { let blob = this.response; let yLink = document.createElement(&#39;a&#39;); let myDate = new Date(); let nowDateStr=Controller.dateFormat(&#34;YYYYmmddHHMMSS&#34;, myDate) yLink.style.display = &#39;none&#39;; let contentTypeHeader = xhr.getResponseHeader(&#34;Content-Type&#34;); // 字符内容转变成blob地址 yLink.href = window.URL.createObjectURL(new Blob([blob], { type: contentTypeHeader })); yLink.download = nowDateStr+&#39;.xlsx&#39;;; // 触发点击 document.body.appendChild(yLink); yLink.click(); // 然后移除 document.body.removeChild(yLink); clearTimeout(downloadTimer); $(&#34;#exportBtn&#34;).html(&#34;&lt;i class=&#39;fa fa-cloud-download&#39;&gt;&lt;/i&gt; 导出Excel&#34;); $(&#34;#exportBtn&#34;).removeAttr(&#34;disabled&#34;); } } let downloadTimer = setInterval(() =&gt; { $(&#34;#exportExcel&#34;).children(&#34;i&#34;).text(++itime); }, 1000); }) 三、通过PHP CURL 间接性下载流文件/** * 导出Excel */ public function downloadExcel(){ $url = &#39;http://XXX.XXX.XXX.XXX/api/export/excel&#39;; $temp = [ &#39;start_time&#39;=&gt;date(&#34;Y-m-d H:i:s&#34;,time()) ]; $stremData = self::getWebFileStream($url,$temp,&#39;post&#39;); $t=time(); $today=date(&#34;YmdHis&#34;,$t); $file_name= $today . &#39;.xlsx&#39;; $excelFile = $_SERVER[&#39;DOCUMENT_ROOT&#39;].&#34;/excel-file/&#34; . $file_name; // 保存文件到指定路径 $ret=file_put_contents($excelFile,$stremData); Log::info(&#39;====download方法中====当前系统时间=======&#39;.date(&#34;Y-m-d H:i:s&#34;,time())); Log::info(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;流文件&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;.$ret); // 释放文件内存 //unset($stremData); self::output_for_download($excelFile, $file_name); } /** * 获取网络接口里面的文件流 **/ protected function getWebFileStream($url,$params,$type){ $stream = &#34;&#34;; if(!isset($url) || empty($url)) return &#34;&#34;; $ch=curl_init(); if($type === &#34;post&#34;){ $temp = json_encode($params); curl_setopt_array($ch,[ CURLOPT_URL =&gt; $url, CURLOPT_RETURNTRANSFER =&gt; 1, CURLOPT_POST =&gt; 1, CURLOPT_HEADER =&gt; 0, CURLOPT_POSTFIELDS =&gt; $temp ]); curl_setopt($ch, CURLOPT_HTTPHEADER, array( &#39;Content-Type: application/json&#39;, &#39;Content-Length: &#39; . strlen($temp)) ); }else{ curl_setopt_array($ch,[ CURLOPT_URL =&gt; $url, CURLOPT_RETURNTRANSFER =&gt; 1, CURLOPT_HEADER =&gt; 0 ]); } //输出结果 $stream = curl_exec($ch); //推断curl请求是否超时 if(curl_errno($ch)){ $stream = file_get_contents($url); } //关闭 curl_close($ch); return $stream; } /** * 将文件输出到浏览器页面 */ function output_for_download($filename, $title){ $fp = fopen($filename,&#34;r&#34;); header(&#34;Content-type: application/vnd.ms-excel;charset=gb2312&#34;); header(&#34;Accept-Length: &#34;.filesize($filename)); header(&#34;Content-Transfer-Encoding: binary&#34;); header(&#39;Content-Disposition: attachment; filename=&#34;&#39;.basename($filename).&#39;&#34;&#39;); // 输出文件内容 while(!feof($fp)) { echo fread($fp,filesize($filename)); } fclose($fp); unlink($filename); //删除文件 exit; }   ]]></content></entry><entry><title>SpringBoot使用FreeMarker模板发送邮件</title><url>/article/96/</url><categories><category>Springboot2.x</category></categories><tags><tag>FreeMarker</tag><tag>模板发送邮件</tag></tags><content type="html"><![CDATA[  Springboot2.x结合FreeMarker使用模板定制属于自己的邮件，瞬间是不是觉得很炫酷啊，那还不赶快去试试看啊
1、添加相关依赖1.1、使用Maven，在pom.xml添加如下依赖： &lt;!-- 邮件所需依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Boot Freemarker 依赖，发送HTML格式的邮件的方式 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; 1.2、使用Gradle，则在 build.gradle 添加依赖： dependencies { implementation &#39;org.springframework.boot:spring-boot-starter-freemarker&#39; implementation &#39;org.springframework.boot:spring-boot-starter-mail&#39; //... 其他依赖库 } 2、application.yml 配置#其他配置信息 spring: #其他配置信息 freemarker: suffix: .ftl template-loader-path: - classpath:/templates cache: false charset: UTF-8 content-type: text/html mail: host: smtp.163.com username: #添加您自己163邮箱 password: #授权第三方登录的授权码 不是邮箱密码哦 别弄混了 protocol: smtp properties.mail.smtp.auth: true properties.mail.smtp.port: 994 #465或者994 #properties.mail.display.sendmail: Javen #properties.mail.display.sendname: Spring Boot Guide Email properties.mail.smtp.starttls.enable: true properties.mail.smtp.starttls.required: true properties.mail.smtp.ssl.enable: true default-encoding: utf-8 from: #添加您自己163邮箱 3、编写MailService服务package cn.qiucode.blog.service; import cn.qiucode.blog.entity.Message; /** * @program: qiucode-blog * @description: 发送邮箱sevice类 * @author: 上官江北 * @create: 2021-04-17 20:02 */ public interface MailService { /** * 使用模板发送邮件 * @param message 评论或留言对象 * @param title 邮件标题 * @param templateName 模板名称 */ public void sendMessageMail(Message message, String title, String templateName); }   ]]></content></entry><entry><title>PHP使用curl上传文件到远程服务器接口</title><url>/article/94/</url><categories><category>PHP</category></categories><tags><tag>CURL</tag><tag>文件上传</tag></tags><content type="html"><![CDATA[  PHP使用CURL上传文件到远程服务接口
当然你的php.ini开启了curl扩展功能
1、文件上传/** * 以文件上传 第二种方法 */ public function upload(){ $result = array(&#39;code&#39; =&gt; 0, &#39;message&#39; =&gt; &#39;ok&#39;); ini_set(&#39;upload_max_filesize&#39;, &#39;20M&#39;); ini_set(&#39;post_max_size&#39;, &#39;20M&#39;); ini_set(&#39;memory_limit&#39;, &#39;128M&#39;); $url=&#34;http://xx.xx.xx.xx/api/file/upload&#34;; //远程接口地址 $file = $_FILES[&#39;file&#39;]; if ($file[&#39;error&#39;] != 0) { $result[&#39;code&#39;] = 40001; $result[&#39;message&#39;] = &#39;上传出错&#39;; $this-&gt;error(); //使用Thinkphp5.1内置controller方法 } else { $filename = $file[&#39;name&#39;]; $tmpfile = $file[&#39;tmp_name&#39;]; $filetype = $file[&#39;type&#39;]; $data = self::upload_file($url, $filename, $tmpfile, $filetype); $data = json_decode($data,true); $this-&gt;success(); ////使用Thinkphp5.1内置controller方法 die; } } /** * curl上传文件 * * @param unknown $url * @param unknown $filename * @param unknown $path * @param unknown $type */ protected function upload_file($url,$filename,$path,$type){ //php 5.5以上的用法 if (class_exists(&#39;\CURLFile&#39;)) { $data = array(&#39;file&#39; =&gt; new \CURLFile(realpath($path),$type,$filename)); } else { $data = array( &#39;file&#39;=&gt;&#39;@&#39;.realpath($path).&#34;;type=&#34;.$type.&#34;;filename=&#34;.$filename ); } $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_POST, true ); curl_setopt($ch, CURLOPT_POSTFIELDS, $data); curl_setopt($ch, CURLOPT_HEADER, false); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); $return_data = curl_exec($ch); curl_close($ch); echo $return_data; } 2、文件接收端（不限定于PHP)/** * 接收文件 */ public function upload(){ Log::info(&#39;--------------$_FILES--------------------&#39;); Log::info($_FILES); if( $_FILES){ $filename = $_FILES[&#39;file&#39;][&#39;name&#39;]; $tmpname = $_FILES[&#39;file&#39;][&#39;tmp_name&#39;]; if(move_uploaded_file($tmpname, $_SERVER[&#39;DOCUMENT_ROOT&#39;].&#34;/excel-file/&#34; .$filename)){ echo json_encode(&#39;上传成功&#39;); }else{ $data = json_encode($_FILES); echo $data; } } } 3、以下是以二进制文件上传偶尔会失败，故而不推荐使用，在此记录下！/** * 以二进制文件上传 */ public function upload_stream(){ $url=&#34;http://xx.xx.xx.xx/api/file/upload&#34;; //上传远程接口地址 $info = $_FILES[&#39;file&#39;]; $fp = fopen($info[&#39;tmp_name&#39;], &#39;r&#39;); $filebinary = fread($fp, filesize($info[&#39;tmp_name&#39;])); fclose($fp); $opts = array( &#39;http&#39; =&gt; array( &#39;method&#39; =&gt; &#39;POST&#39;, &#39;header&#39; =&gt; &#39;content-type:application/x-www-form-urlencoded&#39;, &#39;context&#39; =&gt; $filebinary ) ); $context = stream_context_create($opts); $response = file_get_contents($url, false, $context); //就是这个方法 偶尔会失败哦！ $ret = json_decode($response, true); return $ret[&#39;success&#39;]; } //以下服务部署于服务端(不限定于PHP) /** * 接收二进制流文件 */ public function upload_stream(){ $streamData = isset($GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;]) ? $GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;] : &#39;&#39;; $receiveFile = $_SERVER[&#39;DOCUMENT_ROOT&#39;].&#34;/excel-file/receiv.xlsx&#34;; if(empty($streamData)){ $streamData = file_get_contents(&#39;php://input&#39;); } if($streamData!=&#39;&#39;){ $ret = file_put_contents($receiveFile, $streamData, true); }else{ $ret = false; } return $ret; }   ]]></content></entry><entry><title>docker 安装[7.2-fpm-alpine]与nginx-1.13.0-alpine</title><url>/article/93/</url><categories><category>Docker</category></categories><tags><tag>PHP-FPM</tag><tag>Nginx</tag></tags><content type="html"> docker 容器安装php-fpm和nginx
拉取 7.2-fpm-alpine官方镜像
docker pull php:7.2-fpm-alpine 启动php-fpm
docker run --name test-php -d \ -v /home/mynginx/html:/var/www/html \ -v /home/myphpini:/usr/local/etc/php \ php:7.2-fpm-alpine 从docker容器中将/php.ini-production复制并重命名为php.ini到宿主机上。
docker cp test-php:/usr/local/etc/php/php.ini-production /home/myphpini/php.ini nginx:1.13.0-alpine
docker pull nginx:1.13.0-alpine 编辑 nginx 配置文件 /home/mynginx/conf.d/default.conf
server { listen 80; server_name localhost; location / { root /usr/share/nginx/html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root /usr/share/nginx/html; } location ~ \.php$ { fastcgi_pass php:9000; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME /var/www/html/$fastcgi_script_name; include fastcgi_params; } } 启动nginx
docker run --name test-nginx -p 80:80 -d \ -v /home/mynginx/html:/usr/share/nginx/html \ -v /home/mynginx/conf.d:/etc/nginx/conf.d \ --link test-php:php \ nginx:1.13.0-alpine 测试结果
在 /home/mynginx/html 新建 index.php 文件
&amp;lt;?php phpinfo();</content></entry><entry><title>Ubuntu 16.04 LTS 安装redis</title><url>/article/92/</url><categories><category>Linux</category><category>Ubuntu</category></categories><tags><tag>Ubuntu 16.04LTS</tag><tag>redis</tag></tags><content type="html"> redis缓存替换为最新版本，所以记录一下安装过程，【秋码记录】redis缓存也做了相应更换，故而微信小程序就没空写了
1、下载redis源码
1.1、使用命令下载redis-6.2.1 sudo wget http://download.redis.io/releases/redis-6.2.1.tar.gz 1.2、1.2、将下载好的redis-6.2.1传到Ubuntu16.04服务器上 redis官网下载地址： https://redis.io/download
2、解压编译刚下载的redis-6.2.1.tar.gz
2.1、在编译redis源码时，需要先安装gcc
apt-get install gcc 2.2、解压redis-6.2.1压缩包
tar xzf redis-6.2.1.tar.gz 2.3、进入redis-6.2.1目录进行编译
cd redis-6.2.1 make &amp;amp;&amp;amp; make install 3、相关配置信息与启动redis服务
3.1、经过安装后，会将redis服务命令安装在 /usr/local/bin
cd /usr/local/bin ls -all redis-server redis服务器 redis-cli redis命令行客户端 redis-benchmark redis性能测试工具 redis-check-aof AOF文件修复工具 redis-check-rdb RDB文件检索工具
3.2、把配置⽂件移动到/etc/redis⽬录下 一般在/etc/下是没有redis的，需要创建redis
cd /etc/ sudo mkdir redis sudo cp /home/redis-6.2.1/redis.conf /etc/redis/ 3.3、修改配置文件redis.conf
1） 允许远程访问 注释以下内容
# bind 127.0.0.1 2）设置为守护进程运行 将 no 修改为yes
daemonize yes 3）保护模式 将 no 修改为yes
protected-mode yes 4）设置密码 在 #requirepass foobared 去掉 # 号变requirepass foobared ，注：foobared是密码;
3.4、进入到/usr/local/bin目录下，执行命令：（默认端口6379）
redis-server /etc/redis/redis.conf redis-cli -p 6379</content></entry><entry><title>微信小程序电商实战—首页篇（上）</title><url>/article/91/</url><categories><category>微信小程序</category></categories><tags><tag>电商</tag><tag>实战</tag><tag>首页</tag></tags><content type="html"><![CDATA[  本文将接上一篇，实现首页上半部分，导航滚动与首页轮播图，首页部分分为两篇来讲解
上一篇 微信小程序电商实战—环境搭建篇1、定义模块与设置头部首先先在app.json文件中定义首页、分类、购物车以及我的四个模块。
背景颜色为白色，名称是秋码淘好货
&amp;#34;pages&amp;#34;:[ &amp;#34;pages/index/index&amp;#34;, &amp;#34;pages/category/category&amp;#34;, &amp;#34;pages/cart/cart&amp;#34;, &amp;#34;pages/personal/personal&amp;#34; ], &amp;#34;window&amp;#34;:{ &amp;#34;backgroundTextStyle&amp;#34;:&amp;#34;light&amp;#34;, &amp;#34;navigationBarBackgroundColor&amp;#34;: &amp;#34;#fff&amp;#34;, &amp;#34;navigationBarTitleText&amp;#34;: &amp;#34;秋码淘好货&amp;#34;, &amp;#34;navigationBarTextStyle&amp;#34;:&amp;#34;black&amp;#34; }, 2、滑块导航栏编辑index.wxml和index.wxss这两个文件
index.wxml
&amp;lt;view class=&amp;#34;page&amp;#34;&amp;gt; &amp;lt;!-- 搜索框 --&amp;gt; &amp;lt;view class=&amp;#34;search&amp;#34;&amp;gt; &amp;lt;view class=&amp;#34;searchBar&amp;#34;&amp;gt; &amp;lt;icon class=&amp;#34;weui-icon-search&amp;#34; type=&amp;#34;search&amp;#34; size=&amp;#34;14&amp;#34;&amp;gt;&amp;lt;/icon&amp;gt; &amp;lt;input class=&amp;#34;input&amp;#34; placeholder=&amp;#34;大家都在搜&amp;#34; bindtap=&amp;#34;entrySearch&amp;#34; disabled /&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;/view&amp;gt; &amp;lt;!-- 导航栏 --&amp;gt; &amp;lt;view class=&amp;#34;navBar&amp;#34;&amp;gt; &amp;lt;scroll-view …  ]]></content></entry><entry><title>微信小程序电商实战—环境搭建篇</title><url>/article/90/</url><categories><category>微信小程序</category></categories><tags><tag>电商</tag><tag>实战</tag><tag>环境搭建</tag></tags><content type="html"> 微信小程序电商实战之环境搭建篇，首先先去微信公众号—小程序下载微信开发者工具。
可体验 秋码淘好货 微信小程序哦！ 1、开发工具下载 可到微信公众号—小程序 下载 https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/devtools.html
2、创建小程序项目
2.1、打开微信开发者工具，创建项目 如果没有AppID 点击“测试号”也可以哦 申请AppID: https://mp.weixin.qq.com/wxopen/waregister?action=step1
3、代码结构
3.1、微信开发工具生成的初始文件结构 3.2、.json 后缀的 JSON 配置文件 app.json 是对当前小程序的全局配置，包括了小程序的所有页面路径、界面表现、网络超时时间、底部 tab 等。 3.3、.wxml 后缀的 WXML 模板文件 网页编程采用的是 HTML + CSS + JS 这样的组合，其中 HTML 是用来描述当前这个页面的结构，CSS 用来描述页面的样子，JS 通常是用来处理这个页面和用户的交互。 而这个wxml后缀的 WXML 模板文件就相当于html文件，只是微信对此做了封装而已。 3.4、.wxss 后缀的 WXSS 样式文件 WXSS 具有 CSS 大部分的特性，小程序在 WXSS 也做了一些扩充和修改。 新增了尺寸单位。在写 CSS 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。WXSS 在底层支持新的尺寸单位 rpx ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。 提供了全局的样式和局部样式。和前边 app.json, page.json 的概念相同，你可以写一个 app.wxss 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 page.wxss 仅对当前页面生效。 此外 WXSS 仅支持部分 CSS 选择器 3.5、.js 后缀的 JS 脚本逻辑文件 一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 JS 脚本文件来处理用户的操作。 好了，关于微信小程序电商环境搭建，就先告一段落了，敬请期待下一篇 微信小程序电商实战—首页篇
可体验 秋码淘好货 微信小程序哦！</content></entry><entry><title>Fastadmin后台管理之表格行内编辑requireJS加载x-editable.js</title><url>/article/89/</url><categories><category>PHP</category><category>Fastadmin</category></categories><tags><tag>requireJS</tag><tag>x-editable.js</tag><tag>表格行内编辑</tag></tags><content type="html"><![CDATA[  由于Fastadmin官方只有安装表格可编辑的插件才有这个功能，但笔者是一个爱折腾的人，所以也就有了本文，requireJS加载BootstrapTable扩展功能，表格可编辑，基于x-editable.js扩展库
1、下载x-editable js以及cssx-editable官网https://vitalets.github.io/x-editable/
2、在require-backend.js文件添加以下内容找到 public/assets/js/require-backend.js 文件，进行如下操作
require.config({ ..., ..., paths: { ..., ..., &#39;editable&#39;: &#39;../libs/bootstrap-table/dist/extensions/editable/bootstrap-table-editable.min&#39;, &#39;x-editable&#39;: &#39;../libs/bootstrap-x-editable/bootstrap-editable.min&#39;, }, // shim依赖配置 shim: { ..., ..., &#39;editable&#39;: { deps: [&#39;x-editable&#39;, &#39;bootstrap-table&#39;] }, &#34;x-editable&#34;: { deps: [&#34;css!../libs/bootstrap-x-editable/bootstrap-editable.css&#34;] } }, ..., ..., }); ..., ... 3、需要在控制器所对应的JS文件头部添加依赖，追加一个editable，如下：define([&#39;jquery&#39;, &#39;bootstrap&#39;,&#39;backend&#39;, &#39;table&#39;, &#39;form&#39;, &#39;template&#39;,&#39;editable&#39;], function ($, undefined, Backend, Table, Form, Template,undefined) { 4、在bootstrapTable渲染是，添加一个属性 editable:truetable.bootstrapTable({ ..., columns: [ [ { field:&#39;title&#39;, title: &#39;标题&#39;, width: &#39;120px&#39;, editable: true }, ..., ] ], ..., }) 最终实现效果如下：
关于 editable 更多配置 可参考 x-editable官网https://vitalets.github.io/x-editable/
  ]]></content></entry><entry><title>Centos7 安装配置 PHP7 Nginx 并部署开源后台系统Fasadmin</title><url>/article/88/</url><categories><category>PHP</category><category>Fastadmin</category><category>Linux</category></categories><tags><tag>ThinkPHP.1</tag><tag>Nginx</tag></tags><content type="html"> 由于Fastadmin官网文档没有关于Centos7的部署文档，其实与Ubuntu安装部署差不了多少，故而笔者在Centos7部署了Fastadmin。
1、源码编译安装Nginx
1、查看是否安装过Nginx
rpm -qa|grep -E &amp;amp;#34;nginx&amp;amp;#34; 2、安装Nginx前需要提前安装以下这些依赖
2.1、查看gcc版本
gcc -v 若有内容输出说明已安装了gcc。否则，需使用以下命令进行安装。
yum -y install gcc 2.2、pcre、pcre-devel安装
yum install -y pcre pcre-devel 2.3、zlib安装
yum install -y zlib zlib-devel 2.4、安装openssl
yum install -y openssl openssl-devel 3、 安装Nginx
3.1、下载Nginx源码并解压到 /home/nginx-php/
tar -zxvf nginx-1.10.3.tar.gz 3.2、切换到 /home/nginx-php/nginx-1.10.3
./configure make make install 3.3、切换到/usr/local/nginx/conf 配置目录，编辑nginx.conf
server { listen 8001; set $root /home/ecspadmin/public; location ~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ { root $root; } location / { root $root; index index.html index.php; if ( -f $request_filename) { break; } if ( !-e $request_filename) { rewrite ^(.*)$ /index.php/$1 last; break; } } location ~ ^/(uploads|assets)/.*\.(php|php5|jsp)$ { deny all; } location ~ .+\.php($|/) { #fastcgi_pass unix:/var/run/php/php7.1-fpm.sock; …</content></entry><entry><title>git使用教程之创建本地库并关联远程库（笔记整理篇一）</title><url>/article/85/</url><categories><category>Git</category></categories><tags><tag>远程仓库</tag><tag>本地仓库</tag><tag>版本控制</tag></tags><content type="html"> Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑 上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各 自的修改推送给对方，就可以互相看到对方的修改了。
好久没写文章了，本篇文章笔者就来讲讲什么是Git版本控制系统的使用教程。
SVN与Git的最主要的区别
SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活， 干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网 速慢的话，就纳闷了。 Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑 上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各 自的修改推送给对方，就可以互相看到对方的修改了。
在windows上如何安装Git
官网下载地址：https://git-scm.com/downloads 在任意文件夹下，右键鼠标，弹出选项包括如下两个选项，那就说明安装成功了。
添加用户信息
git config --global user.name &amp;amp;#34;上官江北&amp;amp;#34; git config --global user.email shanguanjb@qiucode.cn 创建本地仓库
git init 添加文件到本地仓库
新建一个README.md文件，并输入相应的内容。
第一步：使用命令 git add README.md 添加到暂存区里面去。如下：
第二步：用命令 git commit告诉Git，把文件提交到仓库。
现在我们已经提交了一个README.md文件了，我们下面可以通过命令git status来查看是否还有文件未提交，如下：
接下来我想看下README.md文件到底改了什么内容，如何查看呢？可以使用如下命令：
git diff README.md …</content></entry><entry><title>Springboot对上传图片添加水印后存储到阿里云OSS对象存储中</title><url>/article/79/</url><categories><category>Springboot2.x</category></categories><tags><tag>添加水印</tag><tag>阿里云OSS</tag><tag>Springboot上传图片</tag></tags><content type="html"><![CDATA[  好些时候没发表文章了，由于最近有点忙，又更兼qiucode站点页面大改，新版页面也较旧版整洁多了！那具体该是如何实现呢？（言外之意无非就是程序怎么实现的），其实无非就是将MultipartFile对象进行二次处理（这里所说的处理就是在上传的原图的基础上添加水印），二次处理好了的图片远程存储到阿里云oss存储对象中。
好些时候没发表文章了，由于最近有点忙，又更兼qiucode站点页面大改，新版页面也较旧版整洁多了！ 好了，废话少扯，切入正题，别把本文所讲的主题偏离了。先看下最终实现的效果图吧：
效果图也看了，那具体该是如何实现呢？（言外之意无非就是程序怎么实现的），其实无非就是将MultipartFile对象进行二次处理（这里所说的处理就是在上传的原图的基础上添加水印），二次处理好了的图片远程存储到阿里云oss存储对象中。 首先得先在pom.xml文件中引入阿里云OSS对象存储的SDK依赖jar，具体如下：
pom.xml文件添加阿里云OSS SDK依赖&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;com.aliyun.oss&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;aliyun-sdk-oss&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;2.5.0&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt; OSSClientUtil工具类/*由于篇幅有限，若实在需要OSSClientUtil类的话，可添加笔者QQ：2834491983 备注：qiucode.cn 图片添加水印 本文只贴出与本文相关的核心代码*/ public String uploadImg2Oss(MultipartFile file) { if (file.getSize() &amp;gt; 1024 * 1024) { throw new ImgException(&amp;#34;上传图片大小不能超过1M！&amp;#34;); } String originalFilename = file.getOriginalFilename(); String substring = …  ]]></content></entry><entry><title>池塘中鱼的困惑</title><url>/article/118/</url><categories><category>生活随笔</category></categories><tags><tag>池塘</tag><tag>困惑</tag><tag>花鸟市场</tag></tags><content type="html"> 盛夏，多云，晌午时分。一群隐蔽于桥底下乘凉地鱼正往池边四处游来游去，从东边游到西边，游速不是很快，大家在游的过程，都在望着从池塘边路过的人，似乎在期待人们施舍食物。为什么这么说呢？且听当事鱼讲述这池塘的生活经历。
盛夏，多云，晌午时分。一群隐蔽于桥底下乘凉地鱼正往池边四处游来游去，从东边游到西边，游速不是很快，大家在游的过程，都在望着从池塘边路过的人，似乎在期待人们施舍食物。为什么这么说呢？且听当事鱼讲述这池塘的生活经历。
我（泛指鱼）到这池塘已然不知多少时日了，反正是上次下暴雨时，池塘里游走了好几条鱼，而后雨停了，这里的管理员（泛指人类）发现池塘地鱼没剩下几条了，剩下的都是些体型微胖，年衰体弱游不动的。出于园区的人文景观的考虑，管理员（泛指人类）只得先从花鸟市场买些景观鱼来凑数了！我（泛指鱼）就是那一批的其中一条鱼，其实我（泛指鱼）是挺喜欢这里的，因为这里比我（泛指鱼）原先待在花鸟市场的“破”鱼缸不知大了多少倍。
在吃的方面这边也比原先待在花鸟市场天天都是鱼饲料要好的多，管理员（泛指人类）每天定时喂食，最重要的一点就是每次喂食的食物都不尽相同。除此之外，工作日（除周末，虽然也有个把人，我们（泛指人类）暂且称之为“工作狂”）期间，园区内人们午饭后，或三五成群、或结伴而行，他们（泛指人类）都会买些饼干之类的面食小零食，路过池塘边，他们（泛指人类）驻足挥洒着手中的零食。由此我们（泛指鱼）都会在晌午时分，无论太阳多么大，我们（泛指鱼）都会从桥底下阴凉处向池边四处游来游去的缘由了。
既然这里有我（泛指鱼）说的这么好，在池塘遭了暴雨，那些年轻地鱼为什么要游走呢？出于什么原因呢？其实我（泛指鱼）刚到这里时，我也纳闷了，他们（泛指鱼）为什么要游走呢？后来在这里呆久了，与这里在那场暴雨还没游走（不是游不走，而是游不动了）的“老一辈”交谈中。我（泛指鱼）知道了其中的原委了，原来他们（泛指鱼）这批都来自不同的地方，或附近地水库、或小湖里，或有些也是在下暴雨时从外面游进来的！总之没有一条像我们（泛指鱼）这批是直接从花鸟市场买过来的。
那些微胖的一天只吃管理员（泛指人类）喂的食，初时我（泛指鱼）当他（泛指鱼）是在减肥呢！殊不知，我（泛指鱼）只知其一，不知其二。后来，在某一天的晚边，他（泛指鱼）叹了一口气，腮边呼吸大，水中冒了大泡，我（泛指鱼）顺势游过去问他（泛指鱼），为何叹气？他（泛指鱼） …</content></entry><entry><title>Java8四大核心内置函数式接口</title><url>/article/1/</url><categories><category>Java</category></categories><tags><tag>Java8</tag><tag>函数式接口</tag><tag>Java8新特性</tag></tags><content type="html"><![CDATA[  在前面简单介绍了一些Lambda表达式得好处与语法，我们知道使用Lambda表达式是需要使用函数式接口得，那么，岂不是在我们开发过程中需要定义许多函数式接口，其实不然，java8其实已经为我们定义好了4类内置函数式接口，这4类接口其实已经可以解决我们开发过程中绝大部分的问题，只有一小部分比较特殊得情况需要我们自己去定义函数式接口，本文就简单来学习一下java8内置得4大核心函数式接口。
在前面简单介绍了一些Lambda表达式得好处与语法，我们知道使用Lambda表达式是需要使用函数式接口得，那么，岂不是在我们开发过程中需要定义许多函数式接口，其实不然，java8其实已经为我们定义好了4类内置函数式接口，这4类接口其实已经可以解决我们开发过程中绝大部分的问题，只有一小部分比较特殊得情况需要我们自己去定义函数式接口，本文就简单来学习一下java8内置得4大核心函数式接口。
一、Function&lt;T, R&gt;：函数型接口（R apply（T t））/** * 字符串操作 * @param str 需要处理得字符串 * @param fun Function接口 * @return 处理之后得字符串 */ public String operatorStr(String str,Function&lt;String,String&gt; fun){ return fun.apply(str); } /** * 函数型接口：Function&lt;T,R&gt; */ @Test public void test5(){ String s=operatorStr(&#34;中国四大名著&#34;,str-&gt;str.substring(0,2)); System.out.println(s); } 上面就是一个函数型接口，输入一个类型得参数，输出一个类型得参数，当然两种类型可以一致。
二、Consumer：消费型接口（void accept(T t)）由于网站不幸被抽查审核，个站不允许出现付费等内容，后续将改成关注公主号可继续阅读。  ]]></content></entry><entry><title>Java 8 函数式接口编程</title><url>/article/78/</url><categories><category>Java</category></categories><tags><tag>Java8</tag><tag>函数式接口</tag><tag>Lambda</tag></tags><content type="html"> Java8与2014年9月份发布的，经过多年市场体验，俨然已有很多开源框架和企业在使用Java8了。介于于此，也该回顾下Java8的新特性了，这样也便于后面看开源框架源码也不至于不知其新语法。
Java8与2014年9月份发布的，经过多年市场体验，俨然已有很多开源框架和企业在使用Java8了。介于于此，也该回顾下Java8的新特性了，这样也便于后面看开源框架源码也不至于不知其新语法。 好了，废话少许，切入正题。
函数式接口
Java 8 引入的一个核心概念是函数式接口（Functional Interfaces）。通过在接口里面添加一个抽象方法，这些方法可以直接从接口中运行。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为函数式接口。同时，引入了一个新的注解：@FunctionalInterface。可以把他它放在一个接口前，表示这个接口是一个函数式接口。这个注解是非必须的，只要接口只包含一个方法的接口，虚拟机会自动判断，不过最好在接口上使用注解 @FunctionalInterface 进行声明。在接口中添加了 @FunctionalInterface 的接口，只允许有一个抽象方法，否则编译器也会报错。
Lambda 表达式
函数式接口的重要属性是：我们能够使用 Lambda 实例化它们，Lambda 表达式让你能够将函数作为方法参数，或者将代码作为数据对待。Lambda 表达式的引入给开发者带来了不少优点：在 Java 8 之前，匿名内部类，监听器和事件处理器的使用都显得很冗长，代码可读性很差，Lambda 表达式的应用则使代码变得更加紧凑，可读性增强；Lambda 表达式使并行操作大集合变得很方便，可以充分发挥多核 CPU 的优势，更易于为多核处理器编写代码； Lambda 表达式由三个部分组成：第一部分为一个括号内用逗号分隔的形式参数，参数是函数式接口里面方法的参数；第二部分为一个箭头符号：-&amp;amp;gt;；第三部分为方法体，可以是表达式和代码块。语法如下： \1. 方法体为表达式，该表达式的值作为返回值返回。
(parameters) -&amp;amp;gt; expression \2. 方法体为代码块，必须用 {} 来包裹起来，且需要一个 return 返回值，但若函数式接口里面方法返回值是 void，则无需返回值。
(parameters) -&amp;amp;gt; { …</content></entry><entry><title> Extjs 3.3 tree以下的版本在IE10无法点击的解决办法</title><url>/article/114/</url><categories><category>前端</category><category>extjs</category></categories><tags><tag>extjs</tag><tag>treePanel</tag><tag>IE10兼容</tag></tags><content type="html"><![CDATA[  距上篇文章已过去好几天了，说好的一周发表1到3篇文章，难道都让狗吃了吗？现在才发布一篇而且还是转载的文章。好了，闲话少叙，切入正题，Extjs前端框架是比较早的前端mvc框架了，可能很多人都没接触过，而且现在也很少有项目用Extjs框架搭建了，原因是什么？那就不得而知了，有人说是Extjs比较重……
距上篇文章已过去好几天了，说好的一周发表1到3篇文章，难道都让狗吃了吗？现在才发布一篇而且还是转载的文章。 好了，闲话少叙，切入正题，Extjs前端框架是比较早的前端mvc框架了，可能很多人都没接触过，而且现在也很少有项目用Extjs框架搭建了，原因是什么？那就不得而知了，有人说是Extjs比较重…… 在使用Extjs3.3及以下的版本，在IE10环境中却无法点击树节点，而在IE的其他版本（IE7，IE8，IE9,IE11）均可正常。经过在网上查找资料得知，原因是因为Extjs3.3的ext-all.js中的getAttribute方法不能兼容IE10出错引起。 以下是Extjs3.3的ext-all.js的getAttribute方法
getAttribute : Ext.isIE ? function(name, ns){ var d = this.dom, type = typeof d[ns + &#34;:&#34; + name]; if([&#39;undefined&#39;, &#39;unknown&#39;].indexOf(type) == -1){ return d[ns + &#34;:&#34; + name]; } return d[name]; } : function(name, ns){ var d = this.dom; return d.getAttributeNS(ns, name) || d.getAttribute(ns + &#34;:&#34; + name) || d.getAttribute(name) || d[name]; }, Extjs3.4的ext-all.js的getAttribute方法
getAttribute: (function(){ var test = document.createElement(&#39;table&#39;), isBrokenOnTable = false, hasGetAttribute = &#39;getAttribute&#39; in test, unknownRe = /undefined|unknown/; if (hasGetAttribute) { try { test.getAttribute(&#39;ext:qtip&#39;); } catch (e) { isBrokenOnTable = true; } return function(name, ns) { var el = this.dom, value; if (el.getAttributeNS) { value = el.getAttributeNS(ns, name) || null; } if (value == null) { if (ns) { if (isBrokenOnTable &amp;&amp; el.tagName.toUpperCase() == &#39;TABLE&#39;) { try { value = el.getAttribute(ns + &#39;:&#39; + name); } catch (e) { value = &#39;&#39;; } } else { value = el.getAttribute(ns + &#39;:&#39; + name); } } else { value = el.getAttribute(name) || el[name]; } } return value || &#39;&#39;; }; } else { return function(name, ns) { var el = this.om, value, attribute; if (ns) { attribute = el[ns + &#39;:&#39; + name]; value = unknownRe.test(typeof attribute) ? undefined : attribute; } else { value = el[name]; } return value || &#39;&#39;; }; } test = null; })(), 将3.4中的方法覆盖3.3的ext-all.js中，ie10中tree恢复正常。
  ]]></content></entry><entry><title>Ztree整合SpringMVC实现异步加载树</title><url>/article/116/</url><categories><category>Springboot2.x</category></categories><tags><tag>Ztree</tag><tag>异步加载树</tag></tags><content type="html"><![CDATA[  正值清明时节，天气也将开始升温了，夏天即将到来，你做好准备了吗？好了，废话少扯，切入正题，本文笔者将要讲解的是JQuery的树插件Ztree。现在web项目基本上也都是使用Ztree作为树组件进行实现的。
正值清明时节，天气也将开始升温了，夏天即将到来，你做好准备了吗？好了，废话少扯，切入正题，本文笔者将要讲解的是JQuery的树插件Ztree。现在web项目基本上也都是使用Ztree作为树组件进行实现的。 好了，来看下最终实现的效果图： 笔者这里使用的是Mysql数据库，先创建一张表。
CREATE TABLE `city_ztree` ( `id` varchar(36) NOT NULL, `city_name` varchar(50) DEFAULT NULL, `parent_id` varchar(36) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 而后插入些测试数据。
insert into `city_ztree`(`id`,`city_name`,`parent_id`) values ( &amp;#39;1a&amp;#39;,&amp;#39;福建省&amp;#39;,&amp;#39;0&amp;#39;); insert into `city_ztree`(`id`,`city_name`,`parent_id`) values ( &amp;#39;2b&amp;#39;,&amp;#39;浙江省&amp;#39;,&amp;#39;0&amp;#39;); insert into `city_ztree`(`id`,`city_name`,`parent_id`) values ( &amp;#39;3c&amp;#39;,&amp;#39;广东省&amp;#39;,&amp;#39;0&amp;#39;); insert into `city_ztree`(`id`,`city_name`,`parent_id`) values ( &amp;#39;4d&amp;#39;,&amp;#39;江苏省&amp;#39;,&amp;#39;0&amp;#39;); insert into `city_ztree`(`id`,`city_name`,`parent_id`) values ( &amp;#39;1a1&amp;#39;,&amp;#39;福州市&amp;#39;,&amp;#39;1a&amp;#39;); insert into …  ]]></content></entry><entry><title>在npm上发布基于Vue2.x开发的UI组件库（记录篇）</title><url>/article/104/</url><categories><category>前端</category><category>node.js</category></categories><tags><tag>npm发布项目</tag><tag>npm注册账号</tag><tag>npm adduser</tag></tags><content type="html"><![CDATA[  解决Navicat12连接Oracle报oracle library is not loaded的提示问题基于Vue开发的UI组件库肯定是要公用的，虽然可以在每创建一个Vue项目时可以复制这些组件，如果组件比较大的情况下呢？是不是很不方便呢？
基于Vue开发的UI组件库肯定是要公用的，虽然可以在每创建一个Vue项目时可以复制这些组件，如果组件比较大的情况下呢？是不是很不方便呢？ 解决这一办法，就是发布到npm官网上，要想在npm上发布你的js，你肯定要有npm账号。 https://www.npmjs.com官网上注册一直报错
所以就只能使用命令了！
npm adduser 原先npm镜像成淘宝的了，所以要改回来的！ npm config set registry https://registry.npmjs.org 然后在npm官网登录，首先你要进行邮箱验证！
再发布之前，你要在 build文件夹下新建一个文件。 webpack.config.dist.js
const path = require(&#34;path&#34;); const webpack = require(&#34;webpack&#34;); const uglify = require(&#34;uglifyjs-webpack-plugin&#34;); module.exports = { devtool: &#39;source-map&#39;, entry: &#34;./src/index.js&#34;, output: { path: path.resolve(__dirname, &#39;../dist&#39;), publicPath: &#39;/dist/&#39;, filename: &#39;qiucodeUI.min.js&#39;, libraryTarget: &#39;umd&#39;, library: &#39;qiucodeUI&#39;, umdNamedDefine: true }, module: { // noParse: /es6-promise\.js$/, rules: [{ test: /\.vue$/, loader: &#39;vue-loader&#39; }, { test: /\.less$/, use: [ { loader: &#34;style-loader&#34; }, { loader: &#34;css-loader&#34; }, { loader: &#34;less-loader&#34; } ] }, { test: /\.js$/, exclude: /node_modules|vue\/dist|vue-router\/|vue-loader\/|vue-hot-reload-api\//, loader: &#39;babel-loader&#39; }, { test: /\.(png|jpg|gif|ttf|svg|woff|eot)$/, loader: &#39;url-loader&#39;, query: { limit: 30000, name: &#39;[name].[ext]?[hash]&#39; } } ] }, plugins: [ new webpack.DefinePlugin({ &#34;process.env&#34;: { NODE_ENV: JSON.stringify(&#34;production&#34;) } }), new uglify( { uglifyOptions: { output: { beautify: false, comments: false }, compress: { warnings: false, drop_console: true, drop_debugger: true }, } } ), ] }; 而后在你项目根路径下的package.json文件进行以下修改！
一切都准备好了，那就在回到cmd命令窗口中，执行npm login命令。
登录成功后，执行npm publish命令进行发布项目！
注意：你发布的不能有大写字母存在！
那就改成小写的吧！
不报错那就是发布成功了！你也可以在npm网站上查看是否有发布上去。
  ]]></content></entry><entry><title>开发一套基于Vue2.x的UI组件库（环境搭建篇《一》）</title><url>/article/83/</url><categories><category>前端</category><category>Vuejs</category></categories><tags><tag>基于Vue2.x的UI组件库</tag><tag>UI框架</tag><tag>Nodejs</tag></tags><content type="html"> 基于Vue2.x开发的UI 组件库有很多，诸如 iView UI组件库、Element UI组件库 等等，既然有这么优秀的UI组件，我们干嘛非要自己开发一套组件呢？
基于Vue2.x开发的UI 组件库有很多，诸如 iView UI组件库、Element UI组件库 等等，既然有这么优秀的UI组件，我们干嘛非要自己开发一套组件呢？其主要原因有这几点吧，一、这样可以更加熟悉Vue的组件式开发流程，二、可能有些UI组件并未达到我们的需求所想要的结果，故而自己根据需求开发一套UI组件库。可能还有其他原因吧！ 好了，废话少扯，切入正题。Vue.js是基于Node.js的，笔者这里就使用Vue-cli命令行创建初始化工程，在这之前，你要确定你的电脑已经安装好了Node.js的。 Nodejs官网下载地址：
Nodejs下载地址
若你想下载历史版本，可点击 Other Downloads 链接跳转到历史版本页面。在该页面找到 Previous Releases 这个链接 再次点击进去！
在历史版本列表中可以找到自己想要的版本进行下载！
Nodejs下载好了，一键安装完成后，Nodejs高版本中已经包含npm工具了，所以可以省略安装npm工具这一步了！那就直接安装vue-cli命令行工具吧，使用以下命令进行全局安装vue-cli！
npm install --global vue-cli 这是笔者Nodejs的版本
现在就可以使用vue-cli命令工具来创建vue的项目了。创建一个基于 webpack 模板的新项目
vue init webpack qiucode-ui 基于 webpack 模板创建出来的项目结构如下图：
而后为项目安装依赖，使项目运行起来。命令如下：
cd qiucode-ui npm install npm run dev 打开浏览器访问：
http://localhost:8080
,界面显示如下</content></entry><entry><title>这条路，看似很远，望不见的路的“尽头</title><url>/article/115/</url><categories><category>生活随笔</category></categories><tags><tag>登山</tag><tag>天气很好</tag><tag>奇果</tag></tags><content type="html"> 今天天气很好，午后遂与家人去登山，天是那么的蓝，空气是那么的清新，虽然路是崎岖的，但笔者走的还是很开心的！
天气多云，可以说无风。这么好的天气，笔者也放松一下，午后，遂与家人去登山观景！ 望着天空，天是那么的蓝，空气是那么的清新，或许这就是笔者向往的生活吧！ 松树林立，何其的挺拔啊！ 途中，长在路崖旁的奇果引起笔者的注意，拨开果子，里面满是籽，扑鼻而来的是那苹果的味道！</content></entry><entry><title>Nexus 2.14.x本地仓库安装与maven配置</title><url>/article/87/</url><categories><category>Java</category></categories><tags><tag>Nexus</tag><tag>Maven</tag><tag>版本控制</tag></tags><content type="html"><![CDATA[  Nexus私服是架设在局域网的一种特殊的远程仓库，目的是代理远程仓库及部署第三方构件。有了私服之后，当 Maven 需要下载构件时，直接请求私服，私服上存在则下载到本地仓库；否则，私服请求外部的远程仓库，将构件下载到私服，再提供给本地仓库下载。
跟着笔者一起来maven的私仓Nexus安装与配置，拥有属于自己的本地仓库或是公司内部的私有仓库！ 首先进入Nexus官网：https://www.sonatype.com/download-oss-sonatype 而后在本页面，找到 寻找 Nexus2.X 字样
在这个页面找到 较旧版本
nexus是基于java的，所以对jdk版本有要求，你电脑安装了什么版本的jdk 就下载jdk支持范围的nexus版本
笔者下载的 Nexus2.14.10版本
下载 zip文件后 进行解压 并以管理员打开cmd窗口
nexus install 这行命令就会把nexus以服务进行安装 启动nexus服务
nexus start 服务启动好了之后，就可以在浏览器输入：
http://localhost:8081/nexus nexus默认用户： admin 密码 admin123
修改本地maven 的settings.xml文件 镜像到nexus 私仓
&lt;mirror&gt; &lt;!--This sends everything else to /public --&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; 现在可以在IDEA创建一个maven项目 填写相应的信息
先在pom.xml引入一个jar 并且在nexus私仓上没有的 maven远程库也找不到的jar
&lt;dependency&gt; &lt;groupId&gt;IKAnalyzer&lt;/groupId&gt; &lt;artifactId&gt;IKAnalyzer&lt;/artifactId&gt; &lt;version&gt;2012FF_u1&lt;/version&gt; &lt;/dependency&gt; 执行 mvn install 就报错了
然后笔者这里就在nexus上传一个jar包
而后再次执行 mvn instll 注意：在执行以上命令前，要把本地仓库，刚才下载报错的文件删除
这回就成功了
  ]]></content></entry><entry><title>MPVue开发微信小程序（一）</title><url>/article/84/</url><categories><category>微信小程序</category></categories><tags><tag>mpvue</tag><tag>微信小程序</tag><tag>nodejs</tag></tags><content type="html"> 跟着笔者使用mpvue快速开发微信小程序，徐循渐进地开发微信小程序，使用html构建你想要的界面布局
1、安装必要的软件工具 node.js 下载地址：https://nodejs.org/en/download/ 安装完成后，打开你的命令行输入如下命令，验证安装是否成功：
node -v npm -v 然后，我们需要执行以下命令，将npm的下载源切换到国内淘宝的镜像，以提高下载时的速度和成功率：
npm set registry https://registry.npm.taobao.org/ 2、安装vue-cli工具包，它可以快速搭建一个vue项目，当然，mpvue是完全基于vue的，所以安装这个，可以快速搭建一个mpvue项目。
npm install vue-cli -g 安装完成后，输入如下命令进行验证：
3、微信开发者工具 这个工具是开发、调试和模拟运行微信小程序的最核心的工具了，所以必须安装。 下载地址：https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 4、你可以下载sumbline text3来编辑vue文件，当然你也可以使用vs code或其他编辑器，只要你愿意就好。 好了，那么来创建第一个基于mpvue的小程序项目。
vue init mpvue/mpvue-quickstart qiucodeblog 这份代码暂时还运行不起来，因为它还缺少依赖的库，我们需要执行以下命令进行依赖库的安装：
cd qiucodeblog npm install 经过几分钟的下载安装，依赖库安装到了qiucodeblog目录下，你可以看到该目录下多出了一个node_modules目录。
然后，执行命令让这个代码运行起来，进入开发模式：
npm run dev 成功运行后，这个项目代码就进入开发模式，一旦有源代码发生修改，就会触发自动编译。因为mpvue使用的是Vue + HTML Web的开发方式开发小程序，它最终还是需要被转换成小程序的代码才可以在小程序环境运行，所以这里的自动编译的目的就是要把Web代码编译成小程序代码。编译后的代码会在dist目录下：
在左边的小程序模拟器中就能看到qiucodeblog小程序的执行结果了：</content></entry><entry><title>双十一抢购云服务器，总有一款适合您</title><url>/article/82/</url><categories><category>云服务器</category></categories><tags><tag>阿里云</tag><tag>腾讯云</tag><tag>双十一</tag><tag>拼团</tag></tags><content type="html"> 深夜发表文章，只为阿里云云服务器双十一搞活动，1核2G 云服务器 1年 84元。如果你错过了上次阿里云拼团的机会，那就在双十一这次拼团不要再错过了，这次拼团也是相对来说性价比也是比较优惠的！
阿里云
首先先来看下双十一前夕阿里云有哪些优惠呢？在购买阿里云服务器之前，可先获取阿里云通用代金券： 阿里云通用代金券
阿里云双十一拼团
对于个人建站，1核2G配置已经足够了，这次拼团不要再错过了！
阿里云这次又多了个加油包优惠券，
价值4500元加油包
腾讯云
在看完阿里云后，您是不是觉得阿里云好像都是对新用户特别优惠呢？既然这样，那接下来我们来瞧一眼腾讯云云服务器双十一又有怎样的 优惠力度呢？
腾讯云双十一
腾讯云海外云服务器，优惠力度还是相对可疑的。
腾讯云境外服务器</content></entry><entry><title>ThinkPHP5.x入门（重拾知识篇）</title><url>/article/110/</url><categories><category>PHP</category><category>ThinkPHP</category></categories><tags><tag>ThinkPHP</tag><tag>php</tag><tag>Apache</tag></tags><content type="html"> 由于这段时间可能会不怎么有空，但基本上每周写一篇吧！看到重拾知识篇就应该知道了吧！笔者肯定对PHP也是了解的，没错，是的，笔者是懂得PHP，那你是不是也跟笔者一样啊？是否也熟知PHP这门号称“世界上最好用的语言”呢？ 是不是曾几何时，有过从事PHP方面的工作呢？
由于这段时间可能会不怎么有空，但基本上每周写一篇吧！看到重拾知识篇就应该知道了吧！笔者肯定对PHP也是了解的，没错，是的，笔者是懂得PHP，那你是不是也跟笔者一样啊？是否也熟知PHP这门号称“世界上最好用的语言”呢？ 是不是曾几何时，有过从事PHP方面的工作呢？ 不管你是否从事过PHP工作，还是从事其他任何工作，这都没关系了，最主要的是兴趣与爱好，那就与笔者一起重温PHP吧！ 好了，闲话少叙，切入正题。本篇要讲的是PHP的web框架ThinkPHP，官网地址：http://www.thinkphp.cn/
笔者选择的5.x版本！下载并解压放在本地Apache目录下的htdocs目录下！启动本地Apache服务器
ThinkPHP5.X访问路径与之前的版本有所不同，是访问public目录下的
敬请期待下一篇。。。。。</content></entry><entry><title>CentOS 7安装Nginx反向代理服务器（云服务器篇）</title><url>/article/102/</url><categories><category>Linux</category><category>CentOS</category></categories><tags><tag>CentOS7</tag><tag>nginx</tag><tag>防火墙</tag><tag>https配置</tag></tags><content type="html"> 距上一篇在CentOS 7 安装mysql也已经过去好几天了，正值云服务器试用结束之际，要把原在试用机的配置重新再新服务器安装一遍，在此借这个机会（也正值周日）记录一下Nginx反向代理服务器的配置。
距上一篇在CentOS 7 安装mysql也已经过去好几天了，正值云服务器试用结束之际，要把原在试用机的配置重新再新服务器安装一遍，在此借这个机会（也正值周日）记录一下Nginx反向代理服务器的配置。 好了，闲话少叙，切入正题。 CentOS 7 使用yum 安装 Nginx，命令如下：
yum install nginx 遇到 y/n之类的，就直接敲 y 即可。直到出现 complete！Nginx就安装好。
启动Nginx服务，默认安装Nginx不会启动的。
systemctl start nginx 打开浏览器，输入服务器ip或域名，出现如下图，说明Nginx安装成功！
可以在防火墙配置 http、https和443端口，以便后期Nginx配置SSL做准备！
firewall-cmd --permanent --zone=public --add-service=http firewall-cmd --permanent --zone=public --add-service=https firewall-cmd --reload 在执行以上命令如果出现以下提示，说明服务器的防火墙没有开启。
不要着急，那就开启防火墙吧！
systemctl start firewalld 现在再执行配置防火墙的命令就好了，也可以查看防火墙的状态！
systemctl status firewalld firewall-cmd --list-ports #列出防火墙所有开放的端口 firewall-cmd --permanent --zone=public --add-port=8080/tcp #让防火墙开放8080端口 firewall-cmd --permanent --zone=public --remove-port=8080/tcp #让防火墙移除8080端口（也就是不能访问）</content></entry><entry><title>cocos2d-x实现跑酷游戏之一（重拾知识篇）</title><url>/article/101/</url><categories><category>cocos2d-x</category></categories><tags><tag>跑酷</tag></tags><content type="html"> 好久没去关注cocos2d-x游戏引擎了！时隔多久，我是记不太清楚了，本篇属于温习知识吧，毕竟笔者最初的梦想是开发一个像现在大家平时没事就爱消磨时间的游戏，然而，事与愿违，没能成为一个游戏开发者，竟成了一个Java开发者（请允许我也可以在你们这些Java大佬面前自称为Java开发者）。
好久没去关注cocos2d-x游戏引擎了！时隔多久，我是记不太清楚了，本篇属于温习知识吧，毕竟笔者最初的梦想是开发一个像现在大家平时没事就爱消磨时间的游戏，然而，事与愿违，没能成为一个游戏开发者，竟成了一个Java开发者（请允许我也可以在你们这些Java大佬面前自称为Java开发者）。 无论是作为游戏开发者、还是成了Java开发者（Java大佬们应该是不介意我如此称呼吧）！好了，闲话少叙，切入正题。 既然文章标题是写cocos2d-x实现跑酷游戏的，那总要说一下什么是cocos2d-x吧（只针对那些不知cocos2d-x的小白们），如果你在看篇文章，说明你知道cocos2d-x是什么？又或者你不知道cocos2d-x是什么？但你对游戏感兴趣，这就足够了！ cocos2d-x是用于快速编写游戏的引擎（可能有些游戏资深大佬就嗤之以屁了），大家可以去cocos2d-x官网： cocos2d-x官网
最终实现的跑酷游戏效果如下，以下均在Win32环境编译的。
点击领取或点击右上方的 X 皆可消失该弹框！进入开始游戏界面
点击 进入游戏，直接进入游戏！ 游戏可暂停，可继续进行玩！
敬请期待下一篇将介绍cocos2d-x创建初识工程！</content></entry><entry><title>CentOS 7 安装mysql5.6 （云服务器篇）</title><url>/article/100/</url><categories><category>Linux</category><category>CentOS</category></categories><tags><tag>mysql</tag><tag>CentOS</tag><tag>数据库</tag><tag>云服务器</tag></tags><content type="html"> 无论是互联网行业，还是其他任何行业，数据对于一个公司来讲是至关重要的，也是企业维系用户的得以持续发展的重要资源！\n对于前两篇文章已经讲解了在CentOS 7如何安装JDK8 和Tomcat7，那么作为JavaWeb开发，显然数据库是必不可少的，至少目前来说是这样的。那好，那就跟笔者循序渐进地开始下去吧！
无论是互联网行业，还是其他任何行业，数据对于一个公司来讲是至关重要的，也是企业维系用户的得以持续发展的重要资源！ 对于前两篇文章已经讲解了在CentOS 7如何安装JDK8 和Tomcat7，那么作为JavaWeb开发，显然数据库是必不可少的，至少目前来说是这样的。那好，那就跟笔者循序渐进地开始下去吧！ 1.下载Mysql的repo源 命令如下：
wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm 2.下载完成后我们安装mysql-community-release-el7-5.noarch.rpm包
sudo rpm -ivh mysql-community-release-el7-5.noarch.rpm 3.开始安装mysql
sudo yum install mysql-server 4.成功安装之后重启mysql服务
service mysqld restart 5.初次安装mysql是root账户是没有密码的
mysql -u root 设置密码的方法:
set password for ‘root’@‘localhost’ = password(&amp;#39;mypasswd&amp;#39;); 至此CentOS 7安装Mysql5.6就到此结束了，在CentOS 7搭建Java Web所需的环境就已经弄好了！</content></entry><entry><title>CentOS 7 安装 Tomcat 7（云服务器篇）</title><url>/article/98/</url><categories><category>Linux</category><category>CentOS</category></categories><tags><tag>CentOS</tag><tag>Tomcat</tag><tag>云服务器</tag></tags><content type="html"> 在前一篇介绍在CentOS 7如何安装 JDK，而这一篇可以说是开发Javaweb所需的web容器可选之一，如果你在浏览上一篇时已是得心应手了，相信你在CentOS 7安装Tomcat 已经不是什么事了！虽然有点傲慢，但还是可以窃喜的！
在上一篇我们介绍了如何在云服务器环境下的CentOS 7 安装 JDK，详情请查看 CentOS 7 安装JDK 8（云服务器篇）
本文将带领大家CentOS 7 安装 Tomcat7.
1、安装Tomcat
在命令行执行以下语句：
yum install tomcat tomcat7-webapps tomcat7-admin-webapps 中途碰到Is this ok [y/d/N] 直接y下去
等待一小会，等出现complete!说明安装结束
tomcat7安装好了，都安装在CentOS 7系统的哪里呢？别急……，请看下边。
注意：
配置信息在目录：/etc/tomcat下
webapps在目录：/var/lib/tomcat下
2、测试Tomcat是否安装成功
在webapps目录下建立demo/demo.html文件
cd /var/lib/tomcat ls cd webapps/ mkdir demo ls cd demo/ vim demo.html 用 vim 编辑 hello.html 输入内容：
注意：vim进入后 按I是插入内容 编辑结束后先按esc，然后用:wq 保存并退出 开启了tomcat服务 命令
service tomcat start 然后再浏览器输入ip或域名，打开页面说明配置成功！
至此CentOS 7 安装 Tomcat 7就到此结束。谢谢你的浏览。</content></entry><entry><title>CentOS 7 安装JDK 8（云服务器篇）</title><url>/article/99/</url><categories><category>Linux</category><category>CentOS</category></categories><tags><tag>CentOS</tag><tag>JDK8</tag><tag>云服务器</tag></tags><content type="html"> 云服务器Centos 7 如何安装JDK？这一篇文章你不容错过！它将介绍你在云服务器CentOS 7 如何安装JDK 8，图文并茂，通俗易懂，新手也能搭配！更何况你呢？如果你正在为如何在云服务器 CentOS 7 中如何安装JDK？那这篇文章再合适不过了！相信我，当你阅读完这篇文章后，云服务器CentOS 7 安装 JDK已不是什么触不可及了，让人望而却步了！
1、查看yum库中的Java安装包
yum -y list java* 输入之后回车，会看到各种不同版本的jdk包
2、使用yum安装Java环境 本文安装的是JDK8，安装java-1.8.0版本的所有相关程序
yum -y install java-1.8.0-openjdk* 等待一小会，等出现complete!说明安装结束！
3、查看刚安装的Java版本信息
java -version 出现下图信息，说明安装成功
至此在云服务器中的Linux的CentOS 7安装JDK 8就告一段落了。下一篇将介绍如何安装Tomcat7，敬请期待…………</content></entry><entry><title>关于 本站点 的一些秘闻</title><url>/about/</url><categories/><tags/><content type="html"> 关于博主
这该怎么介绍呢？按简介说是‘一个游离于山间之上的Java爱好者’，其实这样说也不为过， 的确是一个Java从业者。然这只是他爱好之一，他对中国历史很是推崇备至，尤其是先秦时期， 特别是春秋战国那段历史，那时候诸子百家，思想空前。而此后便从未有过像春秋战国这样的思想辩论了， 虽说春秋战国时期也有过勾心斗角，但这段历史却没有像后续各个王朝内的奸佞小人与忠臣间的攻于心计来的凶狠。 他还偏爱书法，优爱草书，但苦于无闲暇之余，故许久未曾研习书法，待他日得空，必当重习书法，书体不限！ 除了历史、书法，他还是个文字控，尤其是对古文、古诗词特喜好，每每读到绝佳好词、好诗，他都会将其抄录下来。 当然抛去以上种种爱好，他还想立志成为一个小说家呢，这都是后话了……
秋码记录
其实很早之前就有想弄一个属于自己的网站，但由于种种原因吧，最终也就没建成。时间追溯到2018年10月初， 国庆期间，放假闲暇之余偶然浏览了Layui官网，在其案例页面内浏览了 诸多使用Layui快速搭起了个人博客，在浏览之余，觉得使用Layui 搭建的个人博客界面看上去很是优美，故而自己便马上着手准备开干起来。说干就干，先买了个服务器。而后又注册了 qiucode.cn域名，随后一个基于Springboot2.x+Mybatis+Mysql5.7，前端使用Layui 的个人博客便部署到了服务器上。现在从某种意义上来说，暂且称为【秋码记录】第一版吧！这一版的博客源码也已于 2019年06月27日开源了，源于开源，回馈于开源！
Github地址： https://github.com/zhenqicai/qiucodeBlog
码云地址： https://gitee.com/zhenqi/qiucodeBlog
qiucode-ui
基于Vue2.x开发的一套UI组件库，主要是学习Vue2.x。
github地址： https://github.com/zhenqicai/qiucodeUI
qiucode-ui在线文档地址： https://zhenqicai.github.io/qiucodeUI-docs
同一地方
首部文学作品发表
起点中文网
，笔名：上官江南。初写或许可能并不是写的那么的好，但既然写了，就会把它写好，写完， 不管怎样都会坚持写下去的。更多的是以
起点中文网
作为锻炼文学功底的平台。
联系方式
公众号：你我杂志刊
QQ： 2834491983</content></entry><entry><title>友情链接</title><url>/flinks/</url><categories/><tags/><content type="html"> 如想交换本站友情链接，请在评论区留下你的站点信息，格式参考如下：
- name: 秋码记录 desc: 一个游离于山间之上的Java爱好者 avatar: https://qiucode.cn/static/front/images/qiu-logo.png link: https://qiucode.cn</content></entry></search>