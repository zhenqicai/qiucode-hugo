---
title: "玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）"
description: "玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）"

lastmod: 2022-12-12T22:08:10+08:00
date: 2022-12-12T22:08:10+08:00

categories:
 - 区块链
 - 智能合约
 - Solidity
tags:
 - 以太坊
 - 区块链
 - 智能合约
 - 基本类型
comment:
  enable: true
url: article/163
toc: true

cover:
   image: "https://qiucodeimg.oss-rg-china-mainland.aliyuncs.com/qiucode2020/1670853755174.png" #图片路径例如：posts/tech/123/123.png
   zoom: 50% # 图片大小，例如填写 50% 表示原图像的一半大小
   caption: "玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）" #图片底部描述
   alt: "玩以太坊链上项目的必备技能（基本类型转换以及推断-Solidity之旅六）"
   relative: false

---

某些情况下，编译器不支持`隐式转换`，而这时，作为开发人员的您就不得不使用`强硬手段`了。`显式转换`可能会发生些您无法预料的状况，所以您需要繁琐的测试，看最终是否能达到您的要求。

<!--more-->

### 基本类型之间的转换

熟悉过其他编程语言的您，对`基本类型`之间的转换并不陌生吧！当然，这`基本类型`进行转换可分为`隐式转换`和`显示转换`。

#### 隐式转换

Solidity 支持`隐式转换`，通过编译器自动进行转换，而不要开发人员的干涉，这便是`隐式转换`。

诸如`赋值`、`函数传递实参`以及`运算操作`，通常，是可以进行类型之间的`隐式转换`，且并不会丢失任何数据。

例如：`uint8`可以转换成`uint16`,`uint16`可以转换成`uint32`，`uint128`可以转换成`uint256`，但`uint8`却不能转换成`uint256`.（因为`uint256`不能覆盖某些值，比如：`-1`）

假使两个不同类型的值进行操作运算时，编译器则会隐式地将一个类型转换成另一个类型（赋值也是如此），这意味着操作始终是操作数其中一个的类型去执行。

```solidity
uint8 a = 3;
uint16 b = 4;
uint32 c = a + b;
```



![img](https://qiucodeimg.oss-rg-china-mainland.aliyuncs.com/qiucode2020/1670853755174.png)

无符号整型可以转换成跟它大小相等或更大的字节类型，但反之不能。 任何可以转换成 `uint160` 的类型都可以转换成 `address` 类型。

#### 显式转换

某些情况下，编译器不支持`隐式转换`，而这时，作为开发人员的您就不得不使用`强硬手段`了。`显式转换`可能会发生些您无法预料的状况，所以您需要繁琐的测试，看最终是否能达到您的要求。

```solidity
int8 y = -3;
uint x = uint(y); //0xfffff..fd （64 个 16 进制字符）  因为这是 -3 的 256 位补码形式。
```



如果一个类型显式转换成更小的类型，相应的高位将被舍弃

```solidity
uint32 a = 0x12345678;
uint16 b = uint16(a); // 此时 b 的值是 0x5678
```



### 类型推断

`类型推导`好像是很多编程语言都支持的`语法糖`吧！无非让您减少代码的编写。

就像`Java 8`语言设计者好不容易整了个`Lambda 表达式`，可您却始终没在您的`Java`代码中去使用它。

苹果（Apple）公司好容易把苹果手机（iphone）设计的越来愈薄，可是到了国内呢，即给手机贴上了膜又让手机套上了那专为手机量身定做的`外套`，最终这样一来，手机厚了（当然咯，我们还是喜欢厚一点的手机，毕竟拿在手上，能察觉手上确实拿了个东西！）

说到底，`类型推到`就是为了让开发人员偷下懒，方便声明变量，可不用敲些类型关键字，让其值推导出该变量的类型。

```solidity
uint24 x = 0x123;
var y = x;
```



这里 `y` 的类型将是 `uint24`。不能对函数参数或者返回参数使用 `var`。

**注意**：类型只能从第一次赋值中推断出来，因此以下代码中的循环是无限的， 原因是`i` 的类型是 `uint8`，而这个类型变量的最大值比 `2000` 小。 `for (var i = 0; i < 2000; i++) { ... }`

高版本可能不支持了。

![img](https://qiucodeimg.oss-rg-china-mainland.aliyuncs.com/qiucode2020/1670853771087.png)